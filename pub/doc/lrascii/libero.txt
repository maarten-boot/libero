




                                          Libero
                                       User's Guide

                                       Version 2.11




       Released:         15 February, 1996

       Author:           Pieter A. Hintjens  
                         Pijlstraat 9, 2060 Antwerpen, Belgium

                         (+323)231.5277      
                         ph@imatix.com

       Copyright:        Copyright (c) 1991-96 Pieter A. Hintjens.



     Summary


        + Libero is  a Programmer's Tool and Code Generator.  You define the high-
          level logic  of a  problem as  a diagram:  Libero generates  the code to
          implement this  logic.   Your applications  are easier  to  write,  more
          robust, easier  to understand.   Libero  uses a  finite-state machine as
          underlying model.

        + Libero supports  these languages:  C, C++,  80x86 assembler,  COBOL  74,
          COBOL 85, Visual Basic, MS Test Basic 1.0 (Setup Toolkit), UNIX C Shell,
          UNIX Korn  Shell, UNIX  Bourne Shell, GNU Bash Shell, Awk, Perl 4.0, Ada
          9x, Borland  Delphi.   It is  extensible to other languages via external
          schema files.

        + Libero runs  on these  platforms: UNIX  (tested on  Linux, HP/UX, SunOS,
          Irix 5.2,  AIX 3.2.5,  Solaris), MS-DOS, MS-Windows, Digital VAX/VMS and
          Open-VMS.   It is  in theory  portable to  any ANSI  C compiler  and  is
          supplied with full sources.


     Terms and Disclaimer


        + This program  is free software; you can redistribute it and/or modify it
          under the  terms of  the GNU  General Public License as published by the
          Free Software  Foundation; either  version 2 of the License, or (at your
          option) any later version.  This program is distributed in the hope that
          it will  be useful,  but WITHOUT  ANY WARRANTY; without even the implied
          warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
          GNU General Public License for more details.

        + Any user  of Libero  is welcome  to register  by sending me their e-mail
          contact information.   Registered users will be notified of new versions
          when available, if possible.



     Printed 15 February, 1996                                                Page 1





     Libero User's Guide                                                 Version 2.11

                                    Table Of Contents




       Introduction ...................................... 4
          How It All Started ............................. 4
          Some Examples .................................. 5
            Example 1: A Coke Machine .................... 6
            Example 2: Using A Telephone ................. 7
            Serious Stuff: Events and Names ............. 10
            Example 3: Controlling A Telephone .......... 11
            Source Code For Phone.c ..................... 13
            Serious Stuff: Using Get-External-Event ..... 15
            Example 4: C/C++ Comment Stripper ........... 16
            Example 5: Parsing An Arithmetic Expression . 19
            Serious Stuff: Using Exceptions ............. 21
            Serious Stuff: Using Super-States ........... 22
          When To Use Libero ............................ 22
          Suggested Exercises ........................... 23

       Installing Libero ................................ 24
          Getting Libero ................................ 24
          What You Should Have Received ................. 24
            What You Will Need .......................... 24
            Installing Libero for UNIX .................. 25
            Installing Libero for MS-DOS ................ 26
            Installing Libero for Digital VMS ........... 26
            Installing Libero for Windows ............... 27
            Installing The Examples ..................... 28
          Configuring and Testing Libero ................ 28
          Deinstalling Libero ........................... 29

       Using Libero ..................................... 30
          The Dialog File Syntax ........................ 30
          Running Libero ................................ 30
          Libero Options ................................ 31
          Programming With Dialogs ...................... 34
            Exception Handling .......................... 34
            The Defaults State .......................... 35
            Efficiency of The Generated Code ............ 36
            Efficiency of The Dialog .................... 36
            Style - Good, Bad, and Ugly ................. 36
            Choosing Names .............................. 38
          Choosing A Language ........................... 39
            The Awk Language ............................ 39
            The C Language .............................. 39
            The COBOL Language .......................... 40
            The 80x86 Assembler Language ................ 40
            The GNU Borne-Again Shell Language .......... 41
            The Microsoft Setup Basic Language .......... 41
            The Perl Language ........................... 41
            The UNIX Bourne Shell Language .............. 42
            The UNIX C Shell Language ................... 42
            The UNIX Korn Shell Language ................ 42
            The Visual Basic Language ................... 42
          Working In Specific Languages ................. 43

     Printed 15 February, 1996                                                Page 2





     Libero User's Guide                                                 Version 2.11
            Standard Public Names ....................... 43
            Working With Awk ............................ 44
            Working With C .............................. 46
            Working With COBOL .......................... 47
            Working With 80x86 Assembler ................ 49
            Working With The GNU Borne-Again Shell ...... 52
            Working With Microsoft Setup Basic .......... 53
            Working With Perl ........................... 54
            Working With The UNIX Bourne Shell .......... 56
            Working With The UNIX C Shell ............... 57
            Working With The UNIX Korn Shell ............ 58
            Working With Visual Basic ................... 59

       Reference Section ................................ 61
          Libero Schema Language ........................ 61
            A First Look ................................ 61
            Read-Only Variables ......................... 62
            Schema Commands ............................. 63
            Syntax Of Expressions ....................... 66
            Syntax Of Logical Conditions ................ 66
            Control Variables ........................... 67
            Standard :do Conditions ..................... 68
            Extra Variables In a :do Loop ............... 69
            General Rules for Code Generation ........... 71
            Generating Module Stubs ..................... 72
            Generating COBOL Code ....................... 72
          The State Machine Algorithm ................... 73
          Compiled-In Limitations ....................... 74
          Supported Platforms ........................... 75
          Release History ............................... 75
          Compatibility With Earlier Versions ........... 75

       Examples ......................................... 76
          Libero 'install' Script for UNIX .............. 76
          COBOL Picture Parser .......................... 77
          TCP/IP Server ................................. 78
          Expression Parser ............................. 78
          Configuration Management System ............... 78
          Multithreaded Agent For VAX/ACMS .............. 79

       Copyright and Licensing Information .............. 80


















     Printed 15 February, 1996                                                Page 3





     Libero User's Guide                                                 Version 2.11

                                       Introduction



       "Laziness

          The quality  that makes  you go to great effort to reduce overall energy
          expenditure.   It makes  you write  labour-saving  programs  that  other
          people will  find useful,  and document what you wrote so you don't have
          to answer so many questions about it.  Hence the first great virtue of a
          programmer."

          - Larry Wall1.


     How It All Started


       In 1982,  as a  student, I  got into games programming as a way of making some
     money.   I skipped  the build-it-yourself-from-an-old-TV-screen-and-a-hex-keypad
     phase of  personal computers,  and jumped straight into the world of ready-to-go
     colour and  sound.  My first PC had 5K of RAM, and 25x22 colour video.  It could
     beep in  three-part harmony.   My  first published  work  was  an  article  that
     explained how  to tweak  the video output to 30x33 (hi resolution!).  Soon I was
     writing sprite  painters,  assembly  libraries  for  sound  and  graphics,  even
     languages to  replace the  built-in Basic.   Anything  to let  me write my games
     faster and  better.   Before I knew what had hit me, I was hooked into the cycle
     of writing tools to improve the world I lived in.

       I haven't  written a  game for  a long time, but I've continued writing tools.
     Libero is  one of  the best - it's simple, clean, portable, and has hit the mark
     so often that I feel it's unfair to keep it for myself.

       The ideas  behind Libero  evolved in  Brussels, Belgium  during the 1980's.  I
     worked with  Leif Svalgaard, on what we would now call a CASE tool - ETK2 - that
     let COBOL  programmers produce  clean, portable  code instead  of  the  mess  we
     generally saw.  One of the key techniques we used was a programming method based
     on finite state machines.

       Historically, the  first real  programs that  used finite  state machines were
     compilers.   Finite state  machines are  also called  Turing machines.  In 1967,
     Peter Naur describes a new way of using Turing machines in a compiler, and shows
     how they simplify error checking.  He goes on to say:

       "The above  description has stressed the checking aspect of the Turing machine
     approach.  However, an equally important aspect is the ease with which arbitrary
     actions may  be specified.   (...) By using this approach it is usually possible
     to avoid tests in individual actions to a surprisingly high degree.  This in our



     ____________________
     1   Programming Perl,  Larry Wall  and Randal.  L.  Schwartz,  1992  O'Reilly  &
     Associates, Inc., page 426.

     2   ETK Programmer's  Reference Manual, P. Hintjens and L. Svalgaard; 1994, Sema
     Group Belgium.

     Printed 15 February, 1996                                                Page 4





     Libero User's Guide                                                 Version 2.11
     experience is  a very  effective way  of reducing the bulk and execution time of
     the translator algorithm."3

       ETK provides  an interactive  editor that you use to describe the logic of the
     program as  a finite state machine.  This approach encourages you to think about
     the complete  problem.   You describe  everything that  can happen,  and how the
     program should  react.  The end-result looks a little like a flow-chart, but has
     more arrows, and fewer different kinds of boxes.

       Now, in  a conventional  state machine, these boxes are given numbers, and the
     programmer build  some tables  that encode  the arrows.  To make such a table by
     hand -  or, just  as bad, encode the table directly in the logic of the program,
     using GOTOs  - is  a Bad  Thing, since  the result  is  near  to  impossible  to
     maintain.   The neat  part  of  our  solution  was  that  we  took  the  textual
     description (called  a 'dialog'),  and generated the mystical tables directly as
     COBOL code.   This is a Good Thing, since the original dialog is easy to change,
     and suddenly becomes excellent (and always accurate) documentation.

       In 1992  I began working as a consultant, and found that I wanted to use these
     techniques in my work.  I was writing in C, so I threw together a code generator
     that could  output C  code using  the same  dialog methodology I was used to.  I
     called this  tool 'Libero'  after the  guy who  runs around the sidelines at the
     football/soccer pitch  doing all  the dirty  work.   My first  serious job was a
     bunch of  TCP/IP clients  and servers.   It  was nice  to come back to the place
     three years  later and  find that the guy maintaining my work had only found one
     bug, and  was happy to go into the programs.  He said that the dialogs made them
     easy to understand and modify.

       This kind  of experience  convinced me that there was real value in this tool.
     I've written  lots of cute programs that are really useful for my own needs, but
     that just don't hack it in the real world.  Libero is different.

       The first release of Libero generated C code using an external model, called a
     'schema'.   I had  a couple  of schemas;  one for  ANSI  C  code,  and  one  for
     multithreaded DEC/VMS code.

       I released  version 2.0  onto the  Net after  adding schemas for UNIX scripts.
     This release  gave me  a lot of feedback, and I rewrote the code-generator again
     to make  it much  more generic.   The  current version  has a  lot more language
     schemas and a lot fewer bugs, plus a front-end for MS-Windows.

       I hope  to continue  in both  these directions.  Libero has become a tool that
     lets you  switch between  languages at  ease.   The first  step is to accept the
     state-machine as  a valid  method for  program development.  This takes a little
     effort, but  I hope  that the examples which follow will help convince you.  The
     second step is to see that this method is language-independent.  You can write a
     program in C, then recode it in COBOL without changing its design.

       A hypothetical development team might write mainframe business applications in
     COBOL, Web  servers in  Perl, batch  processing using  the  Korn  shell  and  C,
     communications layers  in C/C++,  a Web  client in Borland Delphi, and a Windows
     installation script  using the  MS Setup  language.    Yet  instead  of  a  team



     ____________________
     3   Annual Review in Automatic Programming, "Design Of The Gier Algol Compiler",
     Ed. Richard Goodman; 1964 Pergamon Press, page 77.

     Printed 15 February, 1996                                                Page 5





     Libero User's Guide                                                 Version 2.11
     fragmented into  specialists in each domain, you would have a team that enjoys a
     common design technique and who can quickly take on each other's work4.


     Some Examples


       I've not  found a  quick way  to convey  the  true  nature  of  state  machine
     programming.   In my  experience, it  invariably takes  a few  days of practice.
     After three  or four days' exposure to the idea there is a near-audible 'click!'
     and something in the brain connects all the pieces together and you go 'Oh, it's
     like THAT!'.   Maybe  people cultured  on event-driven  programming will  get it
     faster.

       In this  section I'll  describe some everyday situations as state machines, in
     the hope that this will help the process.


     Example 1: A Coke Machine

       The coke  machine (once  awake and  gently humming5)  sits against  the  wall,
     waiting.   Like all  coke machines,  it's very  good at  waiting, due to Natural
     Selection.   All the  impatient proto-coke  machines ran  off screaming 'I can't
     take it  anymore' and  were crunched underfoot by brontosaurii back in the mists
     of prehistory.   (I  noted the  part about the mists specifically to explain why
     the dinosaur  trampled the  proto-coke machine  instead of  extracting something
     cool to  drink.   The prevailing  mists also  explain the  later demise  of  the
     dinosaurs due  to extreme  thirst.   The  surviving  proto-coke  machines  moved
     patiently back against the proto-walls, out of danger.)

       A punter arrives with a handful of loose change.  The coke-machine (covered by
     the modern  and tasteful metal grid that serves both as a defensive covering and
     as an  attraction for  coke machines of the opposite sex) moves into 'attention'
     mode.  When it hears the clink of tasty cash, rather that the ominous clunk of a
     heavy crow-bar,  it relaxes  into 'ready  mode'.   The machine  is now  ready to
     handle any eventuality, so long as it includes coinage.

       As the  last coin  falls and  the punter presses the button labelled 'healthie
     waye sparkling  spring water',  the machine considers the possibilities.  Should
     it play  dead, and  just take  the punter's money?  Or maybe it can substitute a
     can of  30% sucrose 'sweeto-sap'?  Finally it rumbles once, then again for added
     effect, then  excretes a  can of water.  It munches the coins, then settles back
     against the wall, quietly humming again.


     ____________________
     4   In practice,  you also get a certain communality of programming style, which
     disturbs language  purists.   However, I like it when - say - a COBOL programmer
     that knows  only Libero  take a  C program written with Libero and says: "But it
     looks like  COBOL!".   Of course  neither the Libero+C nor Libero+COBOL programs
     look anything like 'COBOL'.

     5   There is  a theory  about this,  notably that  coke machines  have  terrible
     memories, and  can't remember  the words.   A second school of thought says that
     the coke  machines are  humming because  they're thinking about all the terrible
     things they're  going to do to humans with crow bars.  A third school of thought
     reckons that  the coke  machines have  already done  something, and  are humming
     because they thought it was really funny.

     Printed 15 February, 1996                                                Page 6





     Libero User's Guide                                                 Version 2.11
       Just  to  prove  that  you  can  describe  any  sequence  of  events,  however
     improbable, with  a state  machine6,  here  goes.    Act  1,  scene  1  has  our
     protagonist against  the wall,  trying to  remember the  words of the song.  Our
     hero is  normally OK; if something went terribly wrong with the rehearsals (e.g.
     a dinosaur  got sucked  through a  five-dimensional space-time  vortex stretched
     between the  middle terrasic  to five  minutes into  rehersals; the  dinosaur  a
     little off  balance after the trip puts down its left foot, and 'crunch'...), it
     might be  Dead, in  which case  we have to call the whole thing off.  We'll call
     this scene 'Should Be Gently Humming'...

       Should-Be-Gently-Humming:
           (--) Ok                                 -> Something-Happened
                 + Wait-For-A-Punter
           (--) Dead                               ->
                 + Stop-The-Programme

       The coke  machine has  been waiting,  perhaps for  days, for  a punter to come
     along.  When the footprints fade in from the distance (a coke machine's ears are
     always against  the ground,  which explains why you rarely find coke machines on
     wet or  dirty surfaces),  the machine  hears either  a cashy  'clink' or  a more
     sinister 'clunk':

       Something-Happened:
           (--) Clink                              -> Before-Cooperating
                 + Accept-Punter's-Cash
                 + Wait-For-Punter's-Choice
                 + Shall-We-Cooperate?
           (--) Clunk                              ->
                 + Exit-Stage-Left-Running
                 + Stop-The-Programme

       The advent  of a  'Clunk' tells the machine to beat it, smartly.  If a 'Clink'
     happened, the  machine goes  on to  think about  a game  plan for the coming few
     minutes.   It accepts  whatever spare  change the  punter  has  to  spare,  then
     pounces, metaphorically:

       Before-Cooperating:
           (--) Ok                                 -> Cooperate
                 + Consider-Punter's-Choice
           (--) Nasty                              -> Let's-Be-Nasty
                 + Consider-Punter's-Choice
           (--) Play-Dead                          -> Something-Happened
                 + Switch-Off-All-Lights
                 + Wait-Until-Punter-Has-Left
                 + Switch-On-The-Lights
                 + Wait-For-A-Punter







     ____________________
     6   The observant reader will have skipped to the next section by now, realising
     that this  one is  not worth  the paper it's printed on.  If you're reading this
     on-line, then  this section  is not  worth the  phosphor  it's  been  digitised,
     rasterised, and sprayed by an electronic beam gun onto.

     Printed 15 February, 1996                                                Page 7





     Libero User's Guide                                                 Version 2.11
       If it's  in a  good mood,  the machine  ejects more or less the drink that the
     punter chose:

       Cooperate:
           (--) Coke                               -> Something-Happened
                 + Eject-Can-Of-Coke
                 + Wait-For-A-Punter
           (--) Spring-Water                       -> Something-Happened
                 + Eject-Can-Of-Spring-Water
                 + Wait-For-A-Punter
           (--) Juice                              -> Something-Happened
                 + Eject-Can-Of-Juice
                 + Wait-For-A-Punter
           (--) Sweeto-Sap                         -> Something-Happened
                 + Eject-Can-Of-Sweeto-Sap
                 + Wait-For-A-Punter
           (--) Empty                              ->
                 + Switch-Off-All-Lights
                 + Stop-The-Programme

       If the  coke machine's  pretty weak  internal moral system failed, it supplies
     the opposite of whatever the punter wanted:

       Let's-Be-Nasty:
           (--) Coke                               -> Something-Happened
                 + Eject-Can-Of-Juice
                 + Wait-For-A-Punter
           (--) Spring-Water                       -> Something-Happened
                 + Eject-Can-Of-Sweeto-Sap
                 + Wait-For-A-Punter
           (--) Juice                              -> Something-Happened
                 + Eject-Can-Of-Coke
                 + Wait-For-A-Punter
           (--) Sweeto-Sap                         -> Something-Happened
                 + Eject-Can-Of-Spring-Water
                 + Wait-For-A-Punter
           (--) Empty                              ->
                 + Switch-Off-All-Lights
                 + Stop-The-Programme

       This diagram  is a little complex for a first example.  Remember however, that
     we are modelling a rich behaviour pattern that took several hundreds of millions
     of years  to evolve.  Real software is usually developed much faster, and should
     therefore be much simpler, only it isn't.


     Example 2: Using A Telephone

       In a  more technical  example, we'll model the steps we take in using making a
     telephone call.   By  convention, the  first state  is always called After-Init.
     Another convention is to use Terminate-The-Program to halt the dialog.








     Printed 15 February, 1996                                                Page 8





     Libero User's Guide                                                 Version 2.11
       After initialisation  (I would  recommend a  good coffee  or a  decent  beer7,
     depending on the time of day), we pick-up the handset, and listen to the dialing
     tone.

       After-Init:
           (--) Ok                                 -> Want-Dialing-Tone
                 + Pick-Up-Telephone-Handset
                 + Listen-For-Dialing-Tone
           (--) Error                              ->
                 + Terminate-The-Program

       This leads  us to  the state  Want-Dialing-Tone.   Here we  handle each of the
     possible events  produced by  Listen-For-Dialing-Tone.   Let's look  at these in
     detail:


       This event:       Means this:

       Ok; dialing tone  We can  dial the  number.   This is  the  normal,  expected
                         event.

       Silent; no tone   The telephone  exchange is  having a  hard day,  or someone
                         unplugged the  phone.  Or maybe a ninja attack team has cut
                         the phone  cables and  is at  this moment  sneaking up  the
                         stairs and  AAAARGH...   In this  simple  example  we  loop
                         forever; in  a real program we would allow a limited number
                         of attempts.

       Voices on the line                    Some other  member of  the household is
                         making the  phone company  richer.  We apologise and forget
                         it.

       Modem noise       The young bro' is downloading some more bootleg GIF's.


       We give each of these events a short snappy name and list them in a reasonable
     order.   Like a  'case' statement,  the actual  order makes no difference to the
     machine, but  helps the  person reading  the dialog.   Typically we put the most
     frequent or  expected events first, with the more bizarre ones at the end.  Each
     event provokes one or more actions that correspond to modules of code.  This can
     be  a   function,  procedure,  subroutine,  paragraph,  etc.  depending  on  the
     programming language.  A module is where you do the real work.

       Want-Dialing-Tone:
           (--) Ok                                 -> Want-Ringing-Tone
                 + Dial-Required-Number
                 + Listen-For-Ringing-Tone
           (--) Silent                             -> Want-Dialing-Tone
                 + Put-Down-Telephone-Handset
                 + Pick-Up-Telephone-Handset
                 + Listen-For-Dialing-Tone



     ____________________
     7   Belgians (especially  the Flemish)  handle beer  with the  respect that  the
     French reserve for wine.  I think that for the above exercise, a 9-degree Chimay
     (Red label) would be appropriate.  Any year.  Cool but not cold.

     Printed 15 February, 1996                                                Page 9





     Libero User's Guide                                                 Version 2.11
           (--) Voices                             ->
                 + Apologise-Telephone-Busy
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program
           (--) Modem                              ->
                 + Put-Down-Telephone-Handset
                 + Apologise-Cutting-Modem
                 + Terminate-The-Program

       Here we  are waiting for a ringing tone.  We can reuse some of the event names
     - Ok,  Silence, Voices - from the previous state.  This makes the generated code
     smaller, and is nice for the reader, since there are fewer names to remember:

       Want-Ringing-Tone:
           (--) Ok                                 -> Want-Answer
                 + Listen-For-Answer
           (--) Silence                            -> Want-Dialing-Tone
                 + Put-Down-Telephone-Handset
                 + Pick-Up-Telephone-Handset
                 + Listen-For-Dialing-Tone
           (--) Engaged                            -> After-Engaged
                 + Put-Down-Telephone-Handset
                 + Consider-Trying-Again
           (--) Voices                             -> Want-Dialing-Tone
                 + Complain-Crossed-Connection
                 + Put-Down-Telephone-Handset
                 + Pick-Up-Telephone-Handset
                 + Listen-For-Dialing-Tone

       You get  the  picture.    The  remaining  states  map  out  the  rest  of  the
     conversation.   The next  state has  an event, Doorbell, that is not produced by
     any previous  module, but  that can  happen at  any time8.    We  call  this  an
     exception event,  and we  add the  handling for  it in  the state  where it  can
     happen:

       Want-Answer:
           (--) Ok                                 ->
                 + Have-Conversation
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program
           (--) Wrong-Number                       ->
                 + Apologise-Wrong-Number
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program
           (--) Impatient                          ->
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program
           (--) Answering-Machine                  -> Have-Answering-Machine
                 + Consider-Leaving-Message
           (--) Modem-Or-Fax
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program



     ____________________
     8   Not true,  strictly speaking:  an exception event can only be produced by an
     action module

     Printed 15 February, 1996                                               Page 10





     Libero User's Guide                                                 Version 2.11
           (--) Doorbell                           ->
                 + End-Conversation-Quickly
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program

       After-Engaged:
           (--) Ok                                 -> Want-Ringing-Tone
                 + Dial-Required-Number
                 + Listen-For-Ringing-Tone
           (--) Impatient                          ->
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program

       Have-Answering-Machine:
           (--) Message                            ->
                 + Leave-The-Message
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program
           (--) Impatient                          ->
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program

       The Defaults  state is  special; we  never come  here explicitly.  Rather, the
     state holds  events that  are implicitly  valid in any other state.  Here we say
     that whenever  the Doorbell  event strikes,  we put  the phone  down and beat it
     doorwards.   Note that the Doorbell event is handled explicitly in Want-Answer -
     the action in that state is a little different from the other states.

       Defaults:
           (--) Doorbell                           ->
                 + Put-Down-Telephone-Handset
                 + Terminate-The-Program


     Serious Stuff: Events and Names

       Now I  want to show how an action module 'produces' an event.  Libero provides
     a standard  variable called  The-Next-Event.   An event  like 'Ok'  is  actually
     called Ok-Event  in the program (Libero tacks-on '-Event' for you).  This is how
     you would set The-Next-Event in various languages:

       C and C++:        the_next_event = ok_event

       80x86 assembler:  mov the_next_event,ok_event

       UNIX Korn Shell:  the_next_event=$ok_event

       COBOL:            MOVE OK-EVENT TO THE-NEXT-EVENT

       Visual Basic:     the_next_event = ok_event

       Libero applies this rule: at least one of the action modules for an event must
     supply a  value for The-Next-Event.  If no value for The-Next-Event is supplied,
     the dialog  halts with  some kind  of error  message.   You can mitigate this by
     using the Get-External-Event module (see page 18).




     Printed 15 February, 1996                                               Page 11





     Libero User's Guide                                                 Version 2.11
       The names  of events  and action  modules can take various forms, depending on
     the language  and your  preferences.  For example, the C/C++ code could take any
     of these forms:

       Plain style:      the_next_event = ok_event

       Caps style:       TheNextEvent = OkEvent

       Headline style:   The_Next_Event = Ok_Event

       Title style:      The_next_event = Ok_event

       Personally I prefer the first style, which is why it's the default.  The later
     section on using Libero explains how to set the -style option.


     Example 3: Controlling A Telephone

       This next example is one that a correspondent at a telephone company proposed.
     It's a design for a simple but dedicated subprogram (we'll call it 'Rover') that
     hangs-around on  the corner of our telephone central.  Rover springs into action
     (presumably woofing  and waggling a shaggy tail) when we pick-up the handset, or
     when a  call comes  in for  us.   The dialog  loops around and around, each time
     driven by an 'incoming message'.  This message is one of these events:


       Event:            Means this:

       Offhook           We picked-up  the handset.   Presumably  this  affects  the
                         current on the line, which the central can detect.

       Onhook            We put the phone down.

       Request           Another person is calling us from a 'remote' phone.

       Digit             We pressed a digit on the touchpad.

       Whole Number      We pressed enough digits to form a recognised number9.

       Accept            The remote  phone accepted  the call - ie. the remote Rover
                         gets a Request event of its own.

       Busy              The remote phone was busy.

       Reject            The remote  phone number  was rejected  - we made a mistake
                         with the  number, or  (if dialing into Britain) the British
                         changed their dialing prefixes again.

       Answer            Finally, contact.  I hope it was worth it.



     ____________________
     9   It has  been proven  that if  you place a thousand chimpanzees in front of a
     thousand telephones  and get  them to  dial random numbers for a thousand years,
     not one  will compose  a new  Shakespearean sonnet.   You  will, however,  get a
     humungous phone  bill, which  is the chimps' way of saying 'aren't you sorry now
     that you didn't leave us in the African bush'.

     Printed 15 February, 1996                                               Page 12





     Libero User's Guide                                                 Version 2.11
       Release           The remote  phone cut  the Talking.   At  our end we hear a
                         tone that  signals this.  (This is how my telephone central
                         works.)


       Here is the dialog.  Rover waits for anything to happen, then leaps:

       After-Init:
           (--) Ok                                 -> Idle
                 + Wait-For-Incoming-Message
           (--) Error                              ->
                 + Terminate-The-Program

       The two  possible events  at this  stage are  Offhook (coming  from the  local
     phone), and  Request (from  a remote  phone).   We call this state 'Idle'.  Some
     people get confused at this point, and point out that Rover is exactly not idle,
     so why  the name.   Why  not call the very first state 'Idle'?  I answer so: the
     name of  a state  reflects the  state we were in when the event happened.  Thus,
     when Rover  was idle,  the only  two events  that could  happen were Offhook and
     Request.

       Idle:
           (--) Offhook                            -> Dialing-First
                 + Start-Dial-Tone
                 + Reset-Dialed-Number
                 + Wait-For-Incoming-Message
           (--) Request                            -> Ringing
                 + Start-Ringing-Local
                 + Wait-For-Incoming-Message

       The next  two states  show what  happens when  we dial the first digit.  Rover
     stops with  the dial  tone, and  slurps up  the digits  we press, one by one.  I
     distinguish Dialing-First  from Dialing-Next  to ensure  that Rover does a Stop-
     Local-Tones the first time only:

       Dialing-First:
           (--) Digit                              -> Dialing-Next
                 + Stop-Local-Tones
                 + Have-Dialed-Digit
                 + Wait-For-Incoming-Message
           (--) Whole-Number                       -> Seizing
                 + Stop-Local-Tones
                 + Send-Outgoing-Request
                 + Wait-For-Incoming-Message
           (--) Onhook                             -> Idle
                 + Stop-Local-Tones
                 + Wait-For-Incoming-Message

       Rover doesn't  bother handling the Onhook event here, since the Defaults state
     handles it just fine:

       Dialing-Next:
           (--) Digit                              -> Dialing-Next
                 + Have-Dialed-Digit
                 + Wait-For-Incoming-Message




     Printed 15 February, 1996                                               Page 13





     Libero User's Guide                                                 Version 2.11
           (--) Whole-Number                       -> Seizing
                 + Stop-Local-Tones
                 + Send-Outgoing-Request
                 + Wait-For-Incoming-Message

       Okay, we just tried to 'seize' the remote phone.  This is either accepted (and
     the remote phone starts ringing) or rejected for various reasons:

       Seizing:
           (--) Accept                             -> Ringing
                 + Start-Ringing-Remote
                 + Wait-For-Incoming-Message
           (--) Busy                               -> Seize-Failed
                 + Start-Busy-Tone
                 + Wait-For-Incoming-Message
           (--) Reject                             -> Seize-Failed
                 + Start-Reject-Tone
                 + Wait-For-Incoming-Message

       Seize-Failed:
           (--) Onhook                             -> Idle
                 + Stop-Local-Tones
                 + Wait-For-Incoming-Message

       The next  three states  show how Rover handles a ringing phone (at either end)
     and the  eventual Talking,  if any.   I  combined the handling for the local and
     remote phones  into two  states; I  could  also  write  this  more  clearly  but
     verbosely as four states (Ringing-Local, Ringing-Remote, Talking-Local, Talking-
     Remote).

       Ringing:
           !  Events from local phone
           (--) Offhook                            -> Talking
                 + Stop-Ringing-Local
                 + Wait-For-Incoming-Message
           (--) Onhook                             -> Idle
                 + Stop-Ringing-Remote
                 + Wait-For-Incoming-Message
           !  Event from remote phone
           (--) Answer                             -> Talking
                 + Stop-Ringing-Remote
                 + Wait-For-Incoming-Message

       Talking:
           !  Event from local phone
           (--) Onhook                             -> Idle
                 + Send-Outgoing-Release
                 + Wait-For-Incoming-Message
           !  Event from remote phone
           (--) Release                            -> Released
                 + Start-Released-Tone
                 + Wait-For-Incoming-Message

       Released:
           (--) Onhook                             -> Idle
                 + Stop-Local-Tones
                 + Wait-For-Incoming-Message


     Printed 15 February, 1996                                               Page 14





     Libero User's Guide                                                 Version 2.11
       The Defaults  state handles the Onhook event in those states where there is no
     local tone.   In  those states  (like Released), Rover silences the local phone,
     then loops back to the Idle state:

       Defaults:
           (--) Onhook                             -> Idle
                 + Wait-For-Incoming-Message


     Source Code For Phone.c

       When I  take the above dialog (called phone.l), and give it to Libero, this is
     what happens:



         C:\CTOOLS\LIBERO>lr phone+                         
         LIBERO v2.11 (c) 1991-95 by Pieter A. Hintjens     
         lr I: processing 'phone.l'...                      
         lr I: creating skeleton program phone.c...         
         lr I: building phone.d...                          
         lr I: building phone.i...                          
         lr I: Building stub for have dialed digit          
         lr I: Building stub for reset dialed number        
         lr I: Building stub for send outgoing release      
         lr I: Building stub for send outgoing request      
         lr I: Building stub for start busy tone            
         lr I: Building stub for start dial tone            
         lr I: Building stub for start released tone        
         lr I: Building stub for start ringing local        
         lr I: Building stub for start ringing remote       
         lr I: Building stub for stop local tones           
         lr I: Building stub for stop ringing local         
         lr I: Building stub for stop ringing remote        
         lr I: Building stub for wait for incoming message  
                                                            
         C:\CTOOLS\LIBERO>                                  



       Libero assumes  that I  want to make a program called phone.c. Since this file
     does not  exist, it  creates a  skeleton program  for me.  This only happens the
     first time.   Once the program is created, Libero will add missing pieces to it,
     at the end, but will never change it again otherwise.

       I get  two other  files as  well, phone.d and phone.i.  These are the data and
     interpreter for  my dialog.  I need these files to compile phone.c.  Each time I
     run Libero, it recreates these two files.











     Printed 15 February, 1996                                               Page 15





     Libero User's Guide                                                 Version 2.11
       If I  was working  in another  language, I  would get  different  files,  with
     different extensions.   The default language is C.  Here is the skeleton program
     that Libero gave me, slightly truncated:

       /*===========================================================================*
        *                                                                           *
        *  phone.c     description...                                               *
        *                                                                           *
        *  Written:    95/07/29    Your Name                                        *
        *  Revised:    95/07/29                                                     *
        *                                                                           *
        *  Skeleton generated by LIBERO 2.11 on 29 Jul, 1995, 11:50.                *

       *===========================================================================*/

       #include "prelude.h"                    /*  Public definitions
       */
       #include "phone.d"                      /*  Include dialog data
       */

       /*- Function prototypes -----------------------------------------------------
       */

       /*- Global variables used in this source file only --------------------------
       */

       static int
           feedback;                           /*  Feedback for calling program
       */

       static char
           *some_param;                        /*  Example of parameter
       */


       /********************************   M A I N
       ********************************/

       int my_funct (char *p_some_param)
       {
           feedback = 0;                       /*  No errors so far
       */
           some_param = p_some_param;          /*  Local copy of parameters
       */

       #   include "phone.i"                   /*  Include dialog interpreter
       */
       }


       /*************************   INITIALISE THE PROGRAM
       ************************/

       MODULE initialise_the_program (void)
       {
           the_next_event = ok_event;
       }


     Printed 15 February, 1996                                               Page 16





     Libero User's Guide                                                 Version 2.11
       /***************************   GET EXTERNAL EVENT
       **************************/

       MODULE get_external_event (void)
       {
       }


       /*************************   TERMINATE THE PROGRAM
       ************************/

       MODULE terminate_the_program (void)
       {
           the_next_event = terminate_event;
       }


       /***************************   HAVE DIALED DIGIT
       ***************************/

       MODULE have_dialed_digit (void)
       {
       }


       /**************************   RESET DIALED NUMBER
       **************************/

       MODULE reset_dialed_number (void)
       {
       }
       ... etc.

       I'll discuss  the details  of programming  in C  later.    Some  things  apply
     whatever language you use:

        + Libero creates  a program  that is ready to compile and run.  The dialog
          will halt  with an error message since we don't supply any events beyond
          the initial Ok.

        + There are  some standard  modules: a  main entry  point  of  some  kind,
          Initialise-The-Program, Get-external-event, and Terminate-The-Program.

        + Libero adds a module stub for each action that you use in your dialog.

        + The program  relies heavily  on source-local  variables.  I.e. variables
          that are  global to all functions in the source file, but not visible to
          other source  files.   This can  be disturbing  to some people, but is a
          natural consequence  of the  way Libero  restructures your  program.  It
          actually works quite well, as we'll see later.









     Printed 15 February, 1996                                               Page 17





     Libero User's Guide                                                 Version 2.11
       The standard modules are used in this way:


       Module:           Does this:

       Main              Just passes  control to the Libero generated code.  In some
                         languages, such  as the  C program above, it must also copy
                         any arguments  into variables that can be accessed by other
                         modules.

       Initialise-The-Program                Initial  sanity  checks,  then  usually
                         pass an  Ok event  to the  dialog.    This  what  the  line
                         'the_next_event = ok_event;' does.

       Terminate-The-Program                 Halts  the   dialog  by  passing  it  a
                         Terminate event.   Generally  this is  the last action that
                         the dialog  executes, so  it is  also a convenient place to
                         shut log files, etc.

       Get-External-Event                    The dialog  calls this implicitly if it
                         didn't get an event from any of the modules it executed.



     Serious Stuff: Using Get-External-Event

       The Get-External-Event  module is  empty in  most types  of program,  and very
     important in  other ones.  This module lets you centralise any kind of interface
     to the  outside world  that collects  events.   An example  of this is the Rover
     subprogram we  designed above.   The dialog explicitly does a Wait-for-incoming-
     message before  each new  state.   We can put this code into Get-external-event,
     which makes the dialog simpler.

       Here I also move all handling for Onhook to the Defaults state - assuming that
     the Stop-Local-Tones module is safe to use at any time:

       After-Init:
           (--) Ok                                 -> Idle
                 +
           (--) Error                              ->
                 + Terminate-The-Program

       Idle:
           (--) Offhook                            -> Dialing-First
                 + Start-Dial-Tone
                 + Reset-Dialed-Number
           (--) Request                            -> Ringing
                 + Start-Ringing-Local

       Dialing-First:
           (--) Digit                              -> Dialing-Next
                 + Stop-Local-Tones
                 + Have-Dialed-Digit
           (--) Whole-Number                       -> Seizing
                 + Stop-Local-Tones
                 + Send-Outgoing-Request



     Printed 15 February, 1996                                               Page 18





     Libero User's Guide                                                 Version 2.11
       Dialing-Next:
           (--) Digit                              -> Dialing-Next
                 + Have-Dialed-Digit
           (--) Whole-Number                       -> Seizing
                 + Stop-Local-Tones
                 + Send-Outgoing-Request

       Seizing:
           (--) Accept                             -> Ringing
                 + Start-Ringing-Remote
           (--) Busy                               -> Seize-Failed
                 + Start-Busy-Tone
           (--) Reject                             -> Seize-Failed
                 + Start-Reject-Tone

       Seize-Failed:
           (--) Onhook                             -> Idle
                 + Stop-Local-Tones

       Ringing:
           !  Events from local phone
           (--) Offhook                            -> Talking
                 + Stop-Ringing-Local
           (--) Onhook                             -> Idle
                 + Stop-Ringing-Remote
           !  Event from remote phone
           (--) Answer                             -> Talking
                 + Stop-Ringing-Remote

       Talking:
           !  Event from local phone
           (--) Onhook                             -> Idle
                 + Send-Outgoing-Release
           !  Event from remote phone
           (--) Release                            -> Idle
                 + Start-Released-Tone

       Defaults:
           (--) Onhook                             -> Idle
                 + Stop-Local-Tones


     Example 4: C/C++ Comment Stripper

       One of  the classic  uses for state machines is in scanning and parsing text -
     e.g. source  programs.   People usually do this with tools like lex and yacc, or
     using languages  like awk  and perl  that are  good at pattern matching.  When I
     explain that  Libero uses  a state-machine  model, some  people think  that I am
     asking them  to use Libero in place of the honoured tools I just mentioned.  The
     next example shows why this is not the case.

       Here I  present a  C/C++ comment stripper based on an example by Robert Martin
     (who makes  a finite-state  machine code  generator for  C++).   In C  and  C++,
     comments are either enclosed between '/*' and '*/', or begin with '//' until the
     end of  the line.   This  program removes  all comments  from a  C or C++ source
     program, with some checking for errors like an unmatched '/*':

       !
       !   C/C++ comment stripper dialog
     Printed 15 February, 1996                                               Page 19





     Libero User's Guide                                                 Version 2.11
       !
       !   Written:    95/03/30  Pieter Hintjens
       !   Revised:    95/03/30
       !
       -source=stripper.c -schema=lrschema.c

       After-Init:
           (--) Ok                                 -> Outside-Comment
                 + Get-Char-From-Input
           (--) Error                              ->
                 + Terminate-The-Program

       Outside-Comment:
           (--) Slash                              -> After-Slash
                 + Get-Char-From-Input
           (--) Star                               -> Outside-Comment
                 + Put-Char-To-Output
                 + Get-Char-From-Input
           (--) NewLine                            -> Outside-Comment
                 + Put-Char-To-Output
                 + Get-Char-From-Input
           (--) Other                              -> Outside-Comment
                 + Put-Char-To-Output
                 + Get-Char-From-Input

       After-Slash:
           (--) Slash                              -> Skip-Eoln
                 + Get-Char-From-Input
           (--) Star                               -> Skip-Comment
                 + Get-Char-From-Input
           (--) NewLine                            -> Outside-Comment
                 + Put-Slash-To-Output
                 + Put-Char-To-Output
                 + Get-Char-From-Input
           (--) Other                              -> Outside-Comment
                 + Put-Slash-To-Output
                 + Put-Char-To-Output
                 + Get-Char-From-Input

       Skip-Eoln:
           (--) Slash                              -> Skip-Eoln
                 + Get-Char-From-Input
           (--) Star                               -> Skip-Eoln
                 + Get-Char-From-Input
           (--) NewLine                            -> Outside-Comment
                 + Get-Char-From-Input
           (--) Other                              -> Skip-Eoln
                 + Get-Char-From-Input

       Skip-Comment:
           (--) Slash                              -> Skip-Comment
                 + Get-Char-From-Input
           (--) Star                               -> After-Comment-Star
                 + Get-Char-From-Input
           (--) NewLine                            -> Skip-Comment
                 + Get-Char-From-Input
           (--) Other                              -> Skip-Comment
                 + Get-Char-From-Input

     Printed 15 February, 1996                                               Page 20





     Libero User's Guide                                                 Version 2.11
           (--) End-Of-File                        ->
                 + Signal-Unterminated-Comment
                 + Terminate-The-Program

       After-Comment-Star:
           (--) Slash                              -> Outside-Comment
                 + Get-Char-From-Input
           (--) Star                               -> After-Comment-Star
                 + Get-Char-From-Input
           (--) NewLine                            -> Skip-Comment
                 + Get-Char-From-Input
           (--) Other                              -> Skip-Comment
                 + Get-Char-From-Input
           (--) End-Of-File                        ->
                 + Signal-Unterminated-Comment
                 + Terminate-The-Program

       Defaults:
           (--) Exception                          ->
                 + Terminate-The-Program
           (--) End-Of-File                        ->
                 + Terminate-The-Program

       This is the source for the program:

       /*===========================================================================*
        *                                                                           *
        *  stripper.c  C/C++ comment stripper                                       *
        *                                                                           *
        *  Written:    95/03/30    Pieter Hintjens                                  *
        *  Revised:    95/03/30                                                     *
        *                                                                           *

       *===========================================================================*/

       #include "prelude.h"                    /*  Standard include file
       */
       #include "stripper.d"                   /*  Include dialog data
       */


       /*- Global variables used in this source file only --------------------------
       */

       static int
           thisch,                             /*  Current character
       */
           feedback;                           /*  Feedback for calling program
       */

       int main (void)
       {
           feedback = 0;                       /*  No errors so far
       */
       #   include "stripper.i"                /*  Include dialog interpreter
       */
       }


     Printed 15 February, 1996                                               Page 21





     Libero User's Guide                                                 Version 2.11
       /*************************   INITIALISE THE PROGRAM
       ************************/

       MODULE initialise_the_program (void)
       {
           the_next_event = ok_event;
       }

       /**************************   GET CHAR FROM INPUT
       **************************/

       MODULE get_char_from_input (void)
       {
           thisch = getchar ();
           switch (thisch)
             {
               case '/':   the_next_event = slash_event;         break;
               case '*':   the_next_event = star_event;          break;
               case '\n':  the_next_event = newline_event;       break;
               case EOF:   the_next_event = end_of_file_event;   break;
               default:    the_next_event = other_event;
             }
       }

       /***************************   PUT CHAR TO OUTPUT
       **************************/

       MODULE put_char_to_output (void)
       {
           putchar (thisch);
       }

       /**************************   PUT SLASH TO OUTPUT
       **************************/

       MODULE put_slash_to_output (void)
       {
           putchar ('\\');
       }

       /**********************   SIGNAL UNTERMINATED COMMENT
       **********************/

       MODULE signal_unterminated_comment (void)
       {
           fprintf (stderr, "stripper: unterminated comment\n");
           feedback = 1;                       /*  Return code for main program
       */
       }

       /*************************   TERMINATE THE PROGRAM
       ************************/

       MODULE terminate_the_program (void)
       {
           the_next_event = terminate_event;
       }


     Printed 15 February, 1996                                               Page 22





     Libero User's Guide                                                 Version 2.11
       The program  works, and  is easily  understood, but  it makes the problem seem
     more complex  than it really is.  In fact, this is a good example of the kind of
     problem that I would never use Libero for.

       Moral: Libero  is not  worth the  overhead on  trivial problems.  By contrast,
     when you  are wrestling  with a really complex problem, Libero lets you break it
     down into smaller, simpler pieces, and keep the central logic in a single place.


     Example 5: Parsing An Arithmetic Expression

       The next example is for an arithmetic expression evaluator that was originally
     proposed by  Leif Svalgaard.   The  program works out the value of a string like
     '2-SQR(2)*1.414'.  The program translates easily into most of the languages I've
     worked with so far, from assembler to Basic to C and COBOL.

       Here I  describe the  program lrcalc.c,  which is  a subroutine  that I use in
     Libero.   You can  find the source for this program along with the other sources
     for Libero  in the lrfull.zip archive (see 'Installing Libero').  There are also
     versions of this program in various languages in the examples archive.

       Lrcalc  chops  the  expression  into  tokens,  each  representing  an  operand
     (numbers) or operator.  The  operators are classified as:

        + term operator: '+' and '-'

        + factor operator: '*' and '/'

        + left-parenthesis: '('

        + right-parenthesis: ')'

        + end-mark: indicates the end of the expression.

       There are various ways of parsing an expression like this; lrcalc combines two
     basic techniques: push-down stacks for the operands and operators, and states to
     indicate how tokens are handled.  Each state accepts specific tokens and rejects
     others.   For instance,  at the start of the expression, an operator like '*' is
     not valid.   When  a state  accepts an  operand or  operator, it  adds it to the
     appropriate stack.   When  a state stacks an operator, it evaluates any previous
     operators that  have the  same, or  higher priority.   '*' and '/' have a higher
     priority than '+' and '-'.

       Operators like '(' and ')' are placeholders that group parts of the expression
     together with  a higher  priority.   Operators like  '*', '/',  '+', and '-' are
     binary operators  that take two values off the operand stack, do their work, and
     place the result back on the stack.

       The program  basically takes  tokens one  by one,  stacks and  evaluates  them
     according to the priority rules, until it reaches the end of the expression.  To
     make this  clean, the  program places a special end-mark token at the end of the
     expression when  it starts.   When  it reaches  the end-mark,  it evaluates  any
     remaining operators,  which leaves  the result  of the expression sitting on the
     stack.

       After-Init:
           (--) Ok                                 -> Expecting-Initial
                 + Get-Next-Token

     Printed 15 February, 1996                                               Page 23





     Libero User's Guide                                                 Version 2.11
           (--) Error                              ->
                 + Terminate-The-Program

       The two  states Expecting-Initial  and Expecting-Operand  are similar,  except
     that the  first allows  End-Mark while  the latter  does not.   Ie. we accept an
     empty expression (End-Mark in Expecting-Initial), but don't accept an expression
     that ends when we expect an operand:

       Expecting-Initial:
           (--) Term-Op                            ->
                 + Allow-Signed-Number
                 + Signal-Invalid-Token
                 + Terminate-The-Program
           (--) Number                             -> Expecting-Operator
                 + Stack-The-Number
                 + Get-Next-Token
           (--) Left-Par                           -> Expecting-Operand
                 + Stack-The-Operator
                 + Get-Next-Token
           (--) End-Mark                           ->
                 + Terminate-The-Program

       These two  states handle signed numbers (e.g.. -12, +100) by accepting Term-Op
     tokens (ie.  '+' or  '-') so long as these are stuck to a following number.  The
     module Allow-Signed-Number  gets the  next token,  and if  this is  a number, it
     kicks the  dialog into accepting a number in the same state.  It does this using
     an exception event called Number:

       Expecting-Operand:
           (--) Term-Op                            ->
                 + Allow-Signed-Number
                 + Signal-Invalid-Token
                 + Terminate-The-Program
           (--) Number                             -> Expecting-Operator
                 + Stack-The-Number
                 + Get-Next-Token
           (--) Left-Par                           -> Expecting-Operand
                 + Stack-The-Operator
                 + Get-Next-Token

       After stacking an operand, the dialog expects an operator:

       Expecting-Operator:
           (--) Term-Op                            -> Expecting-Operand
                 + Unstack-Ge-Operators
                 + Stack-The-Operator
                 + Get-Next-Token
           (--) Factor-Op                          -> Expecting-Operand
                 + Unstack-Ge-Operators
                 + Stack-The-Operator
                 + Get-Next-Token
           (--) End-Mark                           ->
                 + Unstack-All-Operators
                 + Unstack-If-End-Mark
                 + Terminate-The-Program




     Printed 15 February, 1996                                               Page 24





     Libero User's Guide                                                 Version 2.11
           (--) Right-Par                          -> Expecting-Operator
                 + Unstack-All-Operators
                 + Unstack-If-Left-Par
                 + Get-Next-Token

       The Defaults  state lists  all tokens.   If a state does not explicitly accept
     some token,  the Defaults  state handles  it: it  issues an  error  message  and
     terminates the program:

       Defaults:
           (--) Number                             ->
                 + Signal-Invalid-Token
                 + Terminate-The-Program
           (--) Term-Op                            ->
                 + Signal-Invalid-Token
                 + Terminate-The-Program
           (--) Factor-Op                          ->
                 + Signal-Invalid-Token
                 + Terminate-The-Program
           (--) End-Mark                           ->
                 + Signal-Token-Missing
                 + Terminate-The-Program
           (--) Left-Par                           ->
                 + Signal-Invalid-Token
                 + Terminate-The-Program
           (--) Right-Par                          ->
                 + Signal-Invalid-Token
                 + Terminate-The-Program
           (--) Exception                          ->
                 + Terminate-The-Program

       The expression  parsing technique  shown here  is easy to elaborate to support
     variables, functions,  other operators,  strings, etc.   It  is true  that  some
     languages have  easier ways  of evaluating  expressions, but  this technique  is
     easily applied  to languages  like assembler  and COBOL that do not have support
     from tools like lex and yacc.  Versions of this program in various languages are
     supplied in the examples archive.


     Serious Stuff: Using Exceptions

       Exceptions are  events that  interrupt the normal flow of a dialog.  Most real
     dialogs use exceptions, sometimes heavily, for two good reasons:

        + Exceptions are a good way to handle errors.

        + Exceptions can make a complex dialog simpler.

       A module  raises an  exception by  setting the  variable Exception-Raised to a
     'true' value.   The module then supplies an event in The-Exception-Event.  Quite
     often I  use an event called 'Exception' when I use an exception event to handle
     fatal errors.   This  is how  we raise  an exception  using  Exception-Event  in
     various languages:

       C and C++:        exception_raised = TRUE       
                         the_exception_event = exception_event

       80x86 assembler:  mov exception_raised,1        
                         mov the_exception_event,exception_event
     Printed 15 February, 1996                                               Page 25





     Libero User's Guide                                                 Version 2.11
       Korn Shell:       exception_raised=TRUE
                         the_exception_event=$exception_event

       COBOL:            MOVE "YES" TO EXCEPTION-RAISED  
                         MOVE EXCEPTION-EVENT TO THE-EXCEPTION-EVENT

       Visual Basic:     exception_raised = True       
                         the_exception_event = exception_event

       In most  languages (except  COBOL) Libero provides a function or macro 'Raise-
     Exception' that  does the above.  See the later sections on using Libero in each
     language for details.

       The dialog normally executes all the action modules for an event-in-state, one
     by one,  then switches to the next state for the event.  An exception interrupts
     this flow. The dialog handles exceptions in two steps:

        + It checks  Exception-Raised  after  executing  each  module.    It  this
          variable has  become 'true',  it stops  and checks  the  value  of  The-
          Exception-Event.

        + It looks  for The-Exception-Event  in the  current state  (or Defaults),
          then executes  the action  modules for that event.  These modules can in
          turn raise en exception.

       When a  module raises  an exception,  the dialog  does not  care what the next
     state was  supposed to  be.   This is  no longer  important, since the exception
     event will determine its own next state.

       Libero also  allows a  short-cut: if  the exception  event is  the same as the
     current event,  you don't  need to  supply it.  If you just set Exception-Raised
     but not  the event,  the dialog  loops back to the same event in the same state.
     Honestly, I  don't use  this very  often.  I prefer to separate exception events
     from 'normal' events.


     Serious Stuff: Using Super-States

       Some dialogs  have  a  lot  of  states  that  are  similar  except  for  small
     differences, like  Expecting-Initial and  Expecting-Operand above.  We can write
     these in a more compact way using a shorthand technique called super-states.  We
     put the super-state name between '<' and '>' after the state name:

       Expecting-Initial: <Expecting-Operand>
           (--) End-Mark                           ->
                 + Terminate-The-Program

       The state  inherits the  events in  the super-state,  if they  are not already
     defined.   In the  above example  we say  that Expecting-Initial inherits events
     from Expecting-Operand, and also handles the End-Mark event.

       A super-state  can itself  be based  on super-states, to any level.  My advice
     is: use  super-states with  care to  simplify large  dialogs.  Don't exaggerate.
     Some more points about super-states:

        + You can think of super-states as 'local defaults' states.

        + If a  super-state is not used anywhere in the dialog, it is not included
          in the generated code.
     Printed 15 February, 1996                                               Page 26





     Libero User's Guide                                                 Version 2.11
        + When a state inherits an event, it may change the 'next state' name.  If
          this is  blank, or  refers to the super-state (which is semantically the
          same), it is changed to be the name of the inheriting state.


     When To Use Libero


       Don't hammer  screws, or  vice-versa.   If a  program is like a building, then
     Libero is  like an  architectural design that automatically forms the foundation
     and  scaffolding.    In  any  programming  language  there  are  directions  and
     complexities where Libero is worth using.  Until you get there, you'll be losing
     time.

       As far  as I  can see, these are some typical cases where you will profit from
     Libero:

        + If you  need to  use some  kind of  pseudocode  or  other  technique  to
          document the  program.  Better to use a dialog - it will always be up to
          date.  Libero lets you attach comments anywhere in the dialog.

        + If you  are making  designs that another programmer will implement (i.e.
          you are  doing 'analysis').   The  programmer does not need to interpret
          your design.  Libero will generate a prototype program (with empty stubs
          for all modules), so you get feedback on your design right away.

        + If your  program analyses  text, and you don't have access to tools like
          yacc.   It is  harder to  build a  parser using  a dialog  than to use a
          parser generator,  but it  is still a lot simpler than doing it by hand.
          Libero lets you build really large dialogs.

        + If your  program is  a communications handler with incoming and outgoing
          messages.  A dialog is a perfect way of describing the handling for each
          message.  I've used Libero for TCP/IP servers in this way.

        + If your  program controls  a device.   A  dialog is  a  perfect  way  of
          describing the various states that a device can be in, with the handling
          for events in each state.

        + If your  program runs  a  complex  task  on  a  database;  for  example,
          processing data  from a  series of  tables depending on various criteria
          and conditions.   A  dialog shows  the processing  logic clearly, with a
          state for  each main  point in  the processing,  and an  event for  each
          condition or type of record.

        + If your program is 'just too damn complex'.  It is difficult to keep the
          'main logic'  separate from  the details.  Libero does this for you, and
          then splits  the detailed code into individual modules.  Your program is
          easy to understand, easy to maintain, and easy to reuse.

        + If you  have to  make design  a program  in several languages, or if you
          have  people   working  in   several  languages.    Libero  is  language
          independent.

        + If you  are working  in some  esoteric language that has no support from
          third-party tools.   You  can build a Libero schema for any language (or
          I'll change Libero).


     Printed 15 February, 1996                                               Page 27





     Libero User's Guide                                                 Version 2.11
     Suggested Exercises


       If you  run out  of breath  easily, try  doing  more  sport.    Alternatively,
     consider stopping whatever it is that makes you breathless.  Also, here are some
     problems that you can try to model using a dialog:

        + A  portable  CD  player.    As  events  you  have  the  various  buttons
          (play/pause, stop,  lock, previous,  next,  skip  back,  skip  forwards,
          repeat).   As states  you have:  idle, playing,  paused.  As actions you
          have check-disc-present,  start-playing-disc, skip-to-next-track,  stop-
          playing-disc, and so on.

        + An install script for your next software application.













































     Printed 15 February, 1996                                               Page 28





     Libero User's Guide                                                 Version 2.11

                                    Installing Libero




     Getting Libero


       You can download Libero from www.imatix.com.

       Libero is  free software.   This  means that you can distribute it freely, and
     use it  as you wish.  You get the sources, which you may modify and redistribute
     - see the file COPYING for the GNU General Public Licence.

       I made  Libero free  software for  the simple and selfish reason that I profit
     daily from  free software  written by others.  This is my way of reinforcing the
     system.

       Libero runs  on many  machines, and  therefore  comes  in  various  forms  for
     different platforms.   The  instructions below  make clear  what you need to run
     Libero on your system.

       The readme.txt  file  explains  briefly  how  to  install  Libero  on  various
     platforms.   If you  hate reading  the user  manual, at least read this file.  I
     recommend that you do not work in the same directory where you installed Libero.
     This makes it difficult to install newer versions of Libero.


     Distribution


       Libero is  available as  a ready-to-run binary kit for various platforms.  You
     can also  download the  source kit  and re-compile for a specific platform.  All
     files are in ftp://ftp.imatix.com.

       The binary kits are at pub/libero/bin.

       The source kit is at pub/libero/src/lrsrc.zip.

       The Libero User's Guide is available in various formats at: pub/libero/doc.


     What You Will Need

       1. Either the binary kit for your system, or the source kit.

       2. pkzip version 2.04g or later, or Infozip unzip to extract the archives.  If
     you do  not have  Infozip unzip  for your  UNIX or VAX system, you can unzip the
     files under MS-DOS and upload them individually.

       3. For  UNIX or  VMS installations  from the source kit, an ANSI C compiler to
     compile Libero.

       4. A  compiler or  interpreter for the language that you want to work in.  You
     don't necessarily  need this  on the machine where you want to run Libero; it is
     possible to  work on  one system,  then transfer  the  results  to  another  for
     compiling and running.

     Printed 15 February, 1996                                               Page 29





     Libero User's Guide                                                 Version 2.11
     Installing the Binary Kit for a UNIX System

       Upload the  lrxxxx.zip ('xxxx'  is something  that indicates  the system) file
     into a working directory and extract the contents using unzip:

       $ mkdir temp
       $ mv lrxxxx.zip temp
       $ cd temp
       $ unzip -a lrxxxx

       You are  now ready  to install  Libero into an install directory.  Run install
     like this  (you may need root access if you want to install Libero into a system
     directory):

       $ su root
       $ chmod +x install
       $ install

       Once you have installed Libero, you should check that the install directory is
     on the  PATH definition.   By default the install script proposes /usr/local/bin
     as an install directory.

       If you do not like placing non-executable files into a /bin directory, you can
     place lr  there, and  the remaining  files (lrmesg.txt, lrschema.*) into another
     directory.   This second  directory may be on the PATH or be defined in another,
     arbitrary environment  variable; for example, LRPATH.  You must then tell Libero
     which variable you are using with a command-line switch like: -path=LRPATH.  You
     can also  specify the  path literally:  -path=/usr/local/tools/bin.  Place  such
     global options in the lr.ini file.


     Installing the Source Kit for a UNIX System

       You may  need to  compile Libero  to run  it on  your UNIX system.  Upload the
     lrsrc.zip archive into a working directory and extract the contents using unzip:

       $ mkdir temp
       $ mv lrsrc.zip temp
       $ cd temp
       $ unzip -a lrsrc

       The install  script is  smart enough to try and detect the UNIX system and use
     appropriate compile options.  Make install executable, then run it.  It proposes
     various options:  start with (b)uild to compile and (maybe) install Libero.  You
     can run  Libero as  soon as  it is  built; you  don't need to install it into an
     install directory.   Run install like this (you may need root access if you want
     to install Libero into a system directory):

       $ su root
       $ chmod +x install
       $ install

       If you  have trouble  running install,  try something like this (it's what the
     script basically tries to do):

       $ cc lr.c lr????.c -o lr
       $ cp lr lrmesg.txt lrschema.* installdir
       $ rm *.o

     Printed 15 February, 1996                                               Page 30





     Libero User's Guide                                                 Version 2.11
       Once you  have built  the lr  file, and  installed it  and its data files, you
     should check  that the  install directory is on the PATH definition.  By default
     the install script proposes /usr/local/bin as an install directory.

       If you do not like placing non-executable files into a /bin directory, you can
     place lr  there, and  the remaining  files (lrmesg.txt, lrschema.*) into another
     directory.   This second  directory may be on the PATH or be defined in another,
     arbitrary environment  variable; for example, LRPATH.  You must then tell Libero
     which variable you are using with a command-line switch like: -path=LRPATH.  You
     can also  specify the  path literally:  -path=/usr/local/tools/bin.  Place  such
     global options in the lr.ini file.

       Note that  on UNIX,  all filenames  are lower-case.   If  you do not manage to
     install Libero  on a  non-MS-DOS system, you can always run Libero on a PC, then
     upload the generated code.

       System-specific notes:

       Linux, gcc: compile switches: -pedantic -O2 -Wall -c.

       HP/UX: compile switches: -Aa.

       SunOS, SunC: compile switches: -O -vc -Xa.

       SunOS, gcc: see Linux.

       AIX 3.2.5:  default compiler  switches.   LIBPATH must be set to /usr/lib when
     you link  lr, or  you'll get  an error  at runtime.   This  appears to be normal
     compiler behaviour.


     Installing Libero for MS-DOS

       Create a  new directory  and extract lrmsdos.zip file there.  This creates the
     set of files that you need to run Libero under MS-DOS.  You must either add this
     new directory  to your path, or copy certain Libero files into a directory (like
     C:\UTILS) which is already on your path:

       LR.EXE - the executable Libero program

       LRMESG.TXT - the message file

       LRSCHEMA.* - the code-generation schemas

       LR.INI - default initialisation file

       You can  also recompile  Libero from the sources.  Read the instructions above
     about installing  for UNIX.   I  have compiled Libero with these compilers under
     MS-DOS:

        - Borland C/C++:  command-line compile  switches: -c  -f -O -Z -w -C -ml -
          Id:\tc\include\.  I use Turbo-C 1.0.

        - MS C/C++:  command-line  compile  switches:  /c  /Ox  /W4  /Za  /Gs  /AL
          /Id:\msvc\lib.  I use Visual C++ 1.51.

       The LR.EXE  file is  not too large, and runs in a modest amount of memory.  If
     you are  writing really  enormous dialogs,  you may want to build LR.EXE using a

     Printed 15 February, 1996                                               Page 31





     Libero User's Guide                                                 Version 2.11
     DOS extender.   I haven't tried this, and I have not heard of anyone running out
     of memory with Libero under MS-DOS.


     Installing Libero for Digital VMS

       You can  install Libero  from the  binary kit for VAX/VMS or Alpha/OpenVMS, or
     you can recompile Libero from the source kit.  For this you need Vax C or Dec C.
     Upload the  lrsrc.zip archive  into a working directory and extract the contents
     using UNZIP:

       $ set def [.temp]
       $ create/dir []
       $ ... upload LRSRC.ZIP into this directory
       $ unzip -a -o lrsrc

       If you  do not  have UNZIP  on your VMS system, consider installing it - it is
     well worth  the bother.   You can also unzip the sources on a PC and upload them
     from there.

       The file  BUILDVAX.TXT is  a procedure that compiles and links Libero.  Run it
     ('@buildvax.txt').   Then copy  these files into an installation directory which
     is world-readable:

       LR.EXE - the executable Libero program

       LRMESG.TXT - the message file

       LRSCHEMA.* - the code-generation schemas

       LR.INI - default initialisation file

       To run Libero your LOGIN.COM file must include these lines:

       $ define/nolog path "<directory>"    <- name of Libero directory
       $ lr :== $<disk><directory>lr.exe    <- you may need two $'s


     Installing Libero for Windows

       Libero for  Windows is  an interactive  editor  that  provides  a  drool-proof
     interface to  the standard  Libero code  generation functions.   It  runs  under
     Windows 3.1, 95, NT, and other common varieties.

       The Libero for Windows binary kit comes in two parts:

       - lrmswin.zip - contains the software and associated files.

       - lrmswins.zip - contains 'system' files.

       Basically, lrmswin.zip  contains the latest version and will change whenever a
     new release  is made.   Lrmswins.zip  is unlikely to change often.  The split is
     made to save you download time.

       Install as follows:

       -  Create a  directory like  C:\LRWIN and  go there, or go to your existing
          Libero directory.

     Printed 15 February, 1996                                               Page 32





     Libero User's Guide                                                 Version 2.11
       -  Unzip lrmswin.zip.   This extracts a series of files, including the main
          executable -  LRWIN.EXE.   Note that  the standard  Libero files - e.g..
          schema files  - are  supplied in  both versions  of Libero (portable and
          Windows), so  if you  have a  more recent version of portable Libero, or
          have customised schemas, take care when you install Libero for Windows.

       -  You must  download and  unzip lrmswins.zip  at least once.  This holds a
          number of  VBX files and DLL files.  You can leave these where they are,
          or move them to your Windows system directory.  If you leave them alone,
          it's easier to de-install Libero afterwards.

       -  Open the  file manager  and drag  the LRWIN.EXE  program into  a program
          group or  onto your  speedbar if  you use  such.   You'll see the famous
          Libero icon, symbolising the victory of the spirit over brute matter, in
          the traditional  green and  purple colours.   If  you  don't  see  these
          colours, try  installing a  decent 256-colour SVGA driver, but above all
          don't worry - Libero will still work.

       -  Double-click on  the icon  and load  in your  current dialog  file.  The
          installation directory  does not need to be on your path, so long as the
          'Path' option in the Options screen points to this directory.

       Libero for Windows is compatible with standard portable Libero; they share the
     same files  and general  ideas about  the world.  However, Libero for Windows is
     not distributed  under the  same terms:  it is  free software,  but you  may not
     modify it, and you cannot get hold of the sources.


     Installing The Examples

       A set of examples is available at pub/libero/examples/lrexampl.zip

       In the  Libero directory,  unzip examples.zip  using the  zip command that re-
     creates the  directory structure.   Usually  this is  'unzip -d', but check your
     version of unzip.  Each example package is in a separate sub-directory.
























     Printed 15 February, 1996                                               Page 33





     Libero User's Guide                                                 Version 2.11
     Configuring and Testing Libero


       When you  have installed  Libero, run  the lr command without arguments.  This
     should show a page of help like this:






















































     Printed 15 February, 1996                                               Page 34





     Libero User's Guide                                                 Version 2.11

        C:\CTOOLS\LIBERO>lr                                                      
               
        LIBERO v2.11 (c) 1991-
        95 by Pieter A. Hintjens                                  
        State-
        Machine Code Generator                                                   
         
                                                                                 
               
        lr [file]... [-[no]option]...       
                                              
                                                                                 
               
          file     -
         name of dialog file, default extension is .l                       
          option   -
         parameter or command as follows:                                   
                                                                                 
               
             Option            Explanation                        Default        
               
                                                                                 
               
             -animate          include animation code             -
        noanimate            
             -check            generate full runtime checks       -
        check                
             -
        defaults=state   name of defaults state             =defaults            
         
             -generate         generate output code               -
        generate             
             -help             show this information              -
        nohelp               
             -idle             indicate idle modules              -
        noidle               
             -
        initial=file     read options from file             =lr.ini              
         
             -
        list=file        errors and trace to file           none                 
         
             -
        option=list      define generation options          none                 
         
             -
        path=variable    path variable for LIBERO files     =PATH                
         
             -plusd            enforce 'source+D' naming rule     -noplusd
                                                                                 
               
        [More --
         Q(uit)/F(irst)/Enter]                                                  





     Printed 15 February, 1996                                               Page 35





     Libero User's Guide                                                 Version 2.11
       Try this from the installation directory, then from a different directory.  If
     Libero cannot find its message file, you'll get an error like this:


        C:\CTOOLS\LIBERO>lr                                                      
               
        LIBERO V2.11 (c) 1991-95 by Pieter A. Hintjens.
        Options file 'lr.ini' not found.
        Cannot find message file lrmesg on 'PATH' path.


       Type 'path'  if you're  working on  MS-DOS, 'echo $PATH' if you're on UNIX, or
     'show log  path' if  you're on VMS.  Check that the installation directory is on
     the path.

       Next, type the command 'lr /settings' to see what settings Libero is using:


        C:\CTOOLS\LIBERO>lr -settings
        LIBERO v2.11 (c) 1991-95 by Pieter A. Hintjens
          Option settings for command:
            animate  . . .: No
            author . . . .: Your Name
            check  . . . .: Yes
            defaults . . .: defaults
            generate . . .: Yes
            help . . . . .: No
            idle . . . . .: Yes
            initial  . . .: lr.ini
            option . . . .: -
            path . . . . .: PATH
            plusd  . . . .: No
            schema . . . .: lrschema.c
            settings . . .: Yes
            source . . . .: -
            stubs  . . . .: Yes
            style  . . . .: plain
            trace  . . . .: No


       You can  change any  of these  default option  settings by  editing the lr.ini
     file, or by placing the settings you want in your dialog file.


     Deinstalling Libero


       I made Libero as simple as possible to deinstall.  It does not change anything
     in system  files, and  keeps its  own files  in the  single directory  where you
     installed it.  To de-install Libero, delete this directory.









     Printed 15 February, 1996                                               Page 36





     Libero User's Guide                                                 Version 2.11

                                       Using Libero




     The Dialog File Syntax


       This is the skeleton.l file - it is a useful starting point for new dialogs:

       !
       !   myprogd.l   Dialog description for myprog.c
       !
       !   Written:    yy/mm/dd  My name
       !   Revised:    yy/mm/dd
       !
       !   Syntax:  '!' comment header
       !            -option[=value]
       !            [ state-name ':' [ '<'superstate-name'>' ]...
       !                  [ '(' event-nbr ')' event-name [ '->' next-state ]
       !                  [ '+' module-name ]... ]... ]...
       !
       -source=myprog

       After-Init:
           (--) Ok                                 ->
                 +
           (--) Error                              ->
                 + Terminate-The-Program

       Defaults:
           (--) Exception                          ->
                 + Terminate-The-Program

       The dialog file syntax is not too complex.  Note that:

        + You can  put a  comment anywhere, starting with '!' until the end of the
          line.  I advise you to put comments on lines of their own.

        + You can  put options before the first state, several per line or one per
          line.  If you put several on one line, separate them by spaces as you do
          on the command line.

        + You need  one or  more spaces  between words.  Libero is not fussy about
          the amount  of blank  space or  line breaks  between words.   However, I
          recommend the  layout above as it is easy to read, and if you use Libero
          for Windows, it will rewrite the dialog in this format in any case.

        + Use an  editor that  lets you cut and paste lines easily, and that works
          in overwrite mode.  This is the easiest way to write dialogs.

        + If you  intend to  move dialog  files  between  systems  (MS-DOS,  UNIX,
          VMS,...) don't  use tabs.   These  don't align  the  same  on  different
          systems.




     Printed 15 February, 1996                                               Page 37





     Libero User's Guide                                                 Version 2.11
     Running Libero


       To run Libero, type the 'lr' command like this:


           lr [options] dialogname...+


       Libero is  a code  generator.   It  works  as  follows:  you  write  a  dialog
     description, and  Libero generates  (by default)  C code  to execute the dialog.
     This C code contains (a) various tables and definitions, and (b) the FSM engine.
     If necessary,  Libero also  generates (c) a skeleton C program to wrap the whole
     thing together.   When  you  change  your  dialog  (many  times  during  program
     development), Libero re-generates (a) and (b) and any new bits needed in (c).

       When you run the lr command, Libero goes through these steps:

        + It displays  a start-up  message and checks that it can find its message
          file.  If this fails, there is a problem with the PATH definition.

        + It reads the dialog file(s) you specified.

        + For each  dialog file,  it run  the language-specific  schema file.  The
          schema generates  code, the exact mechanics depending on the language in
          question:

          1. If necessary, the schema creates a skeleton program.

          2. If  necessary, the schema adds empty module 'stubs' to the end of the
          program for each module in the dialog.  You will often want to rearrange
          these in a meaningful order.

          3. The  schema generates the tables and code required to run your dialog
          program.  These go into include files or other code modules.

       The standard  C schema  is LRSCHEMA.C.  This schema creates two include files,
     with the  dialog's name,  but extensions  '.D' and  '.I'.   The first  of  these
     contains the  DATA, the  second the  INTERPRETER.    Other  schemas  (for  other
     programming languages)  have different  conventions.   I explain  these  in  the
     'Working With...' sections later on.

       Dialogs have  the extension  .l, though you can be bloody-minded and use other
     extensions.   On systems  that support long filenames, the name can be up to 128
     characters long,  including the extension.  I seriously recommend that you stick
     to eight-character  filenames for anything that is remotely useful.  When I were
     a lad,  filenames were  one hex  digit.  To create a new dialog, take skeleton.l
     and copy it.  I recommend that you give a dialog the same name as the program it
     drives.   For instance,  a source  file myprog.c  would use  a dialog  myprog.l.
     Sometimes I  append a  'd' to  the name to make the filename (without extension)
     unique.   Then, for  instance, the  .bak files  that  my  editor  creates  carry
     different names.


     Libero Options


       Like most  command-line programs,  lr accepts  various options.  These control
     things such as the language that Libero generates, the filenames it uses, etc.
     Printed 15 February, 1996                                               Page 38





     Libero User's Guide                                                 Version 2.11
       You can supply an option in various ways:

        + Type the  option when you run lr.  This is good for options that you use
          now and then.

        + Place the  option in  the dialog  file itself (at the start of the file,
          anywhere before  the first  state).   This is  good for options that are
          specific to that dialog file.

        + Place the option in a global initialisation file, usually called lr.ini,
          somewhere on  the path.   This is good for options that you want for all
          your work.

       It sometimes  gets a  little complex  to  remember  which  option  is  active,
     especially if you put the same option in various places.  For instance you could
     put '-nocheck'  in lr.ini,  then run  the lr  command with  the '-check' option.
     Which takes  precedence?   The answer  is: it  works like  it should.  This is a
     somewhat arrogant statement, so I'll explain:

        + Each option has a default value, as explained below.  When Libero starts
          up, this is the value.

        + Libero reads  the lr.ini  file and uses the options in that file.  These
          can change the default values.

        + Libero then looks at any options in the dialog file.

        + Libero looks  at the lr command line and processes any options you typed
          there10.

       If you  are unsure of the options in effect for your dialog, run lr with the -
     settings option.   This  displays the current options.  You can specify a Libero
     option in various forms:

       -option                      UNIX usage
       -option=value                Option takes value
       -option:value                Also okay
       -option="value"              Don't convert value to lowercase
       -option:'value'              The same as above
       -nooption                    switch off true/false option















     ____________________
     10  Libero picks-up  a /help  option right away, as well as a /initial or /path,
     since these affect which lr.ini file it reads.

     Printed 15 February, 1996                                               Page 39





     Libero User's Guide                                                 Version 2.11
       You can  abbreviate an option name to 3 or more characters.  Option values are
     converted to  lower-case unless you place them in single or double quotes.  Some
     options take  values; others  are true/false options.  These is a summary of the
     options that lr accepts:


             Option            Explanation                        Default

             -animate          include animation code             -noanimate
             -author=name      include animation code             ="My Name"
             -check            generate full runtime checks       -check
             -compress         compress generated tables          -compress
             -defaults=state   name of defaults state             =defaults
             -generate         generate output code               -generate
             -help             show this information              -nohelp
             -idle             indicate idle modules              -noidle
             -initial=file     read options from file             =lr.ini
             -option=list      define generation options          none
             -path=variable    path variable for LIBERO files     ="PATH"
             -plusd            enforce 'source+D' naming rule     -noplusd
             -schema=file      schema for code generation         =lrschema.c
             -settings         show option settings per file      -nosettings
             -source=file      program for dialog                 name of dialog
             -stubs            generate stubs for new modules     -stubs
             -style=plain      naming style: some_module_name     -style=plain
             -style=caps       naming style: SomeModuleName
             -style=headline   naming style: Some_Module_Name
             -style=title      naming style: Some_module_name
             -style=normal     naming style: Some-Module-Name
             -style=cobol      naming style: SOME-MODULE-NAME
             -trace            trace code generation to list file




       These are the options that Libero recognises:


       Option:           Purpose:

       -animate          Include or exclude animation code.  If you use this option,
                         the schema will generate code that displays each new state,
                         event, and  action as  the dialog runs.  This is useful for
                         debugging.  The default is -noanimate.

       -author           Libero uses  this value when it creates a new file for you.
                         Put the  string in  quotes to  include spaces:  -author='My
                         Name'.  On the MS-DOS command line, you must type this (two
                         sets of quotes): "-author='My name'".  The default is "Your
                         Name".

       -check            Generate full  runtime checks.  If you use this option, the
                         schema will  generate  code  that  checks  for  invalid  or
                         missing events  while the  program runs.   Keep this option
                         unless you  are sure  it is  slowing down a crucial dialog.
                         The default is -check.



     Printed 15 February, 1996                                               Page 40





     Libero User's Guide                                                 Version 2.11
       -compress         Compress the  generated tables.    Currently,  this  means:
                         removing unused  states.   You can disable this using the -
                         nocompress option.  The default is -compress.

       -defaults=state   The name  of the  Defaults state.   This  state  serves  to
                         collect events  that can happen in any other state; you can
                         make the  dialog smaller  and simpler by placing these into
                         the Defaults state.  The default is "Defaults".

       -generate         Generate output  code.  If you want to check the dialog but
                         not generate  any output,  use -nogen.   The  default is  -
                         generate.

       -idle             Indicate idle  modules.   Libero lists  any modules in your
                         program that  are not  referenced in  the dialog.  This can
                         happen when you change a dialog.  The default is -noidle.

       -initial=file     Tells Libero  to  read  options  from  some  specific  file
                         instead of  lr.ini.  You can use this option on the command
                         line only.  The default is "lr.ini".

       -option:name=value                    Supply a  specific option  value  to  a
                         schema.     This  allows   the  schema   to  generate  code
                         conditionally, or fill-in specific values.  The 'name' is a
                         variable defined  in the  schema; the 'value' overrides any
                         default that  the schema  specifies.   The 'value' can be a
                         full  expression,  including  references  to  other  schema
                         variables.   See the  reference section for details of this
                         business.

       -path=name        Libero uses  this path  to search  for the lr.ini file, its
                         message file,  and the  schema used  to generate code.  You
                         can use  the name of an environment variable (logical under
                         VMS) or  a literal path.  If the case is important, enclose
                         it in  quotes.   For example, under MS-DOS: -path="LRPATH".
                         Libero always  searches the  current directory  first.  The
                         default is "PATH" (in uppercase).

       -plusd            Enforce the  "source+D" naming  rule.   The  default  is  -
                         noplusd.

       -schema=file      Schema for  code generation.  If you override this default,
                         be sure  to specify  the file  extension.   The default  is
                         "lrschema.c".

       -settings         Show option settings for each file processed.   The default
                         is -nosettings.

       -source=file      Program that  uses the  dialog.  By default the name of the
                         dialog, unless  you use  -plusd option, in which case it is
                         the name of the dialog minus an obligatory 'D'.

       -stubs            Generate stubs  for modules  which are  referenced  in  the
                         dialog but  do not (yet) exist in the program.  The default
                         value for  this option is -stubs.  If you use -nostubs, you
                         will have  to make  new module  stubs by  hand.  So leave -
                         stubs on.  [Ed.: Hey, so why is this an option at all?  Me:
                         you never know what people want to do.]

     Printed 15 February, 1996                                               Page 41





     Libero User's Guide                                                 Version 2.11
       -style={ plain | caps | heading | title | normal | cobol }  
                         Style for  module names.   The default is 'plain'.  You can
                         use  this  to  adapt  Libero's  output  to  your  preferred
                         programming style;  do not change halfway through a project
                         unless you like doing major cleanups.

       -trace            Create a  report file  that  traces  the  code  generator's
                         output.   This is  useful if  you are writing or changing a
                         schema, and  cannot get  it to  work.   The trace  file  is
                         called mydialog.lst.



     Programming With Dialogs



     Exception Handling

       I covered  exceptions briefly  around page  25.   Exceptions  are  a  powerful
     technique that  make your  dialog leaner  and meaner.   In a typical dialog many
     actions do  some work  that may  result in an error condition.  For instance, an
     action that  reads some data from a file may discover that the file is no longer
     accessible  due   to  a  'hard'  error  (protection,  disk  crash,  insufficient
     memory,...).   Without exceptions,  the only way to handle such possibilities is
     to define additional states - for instance, 'after-reading-data', that check the
     outcome of each action with a questionable outcome.

       This quickly  leads to  dialogs with  dozens of states that serve only to keep
     track of  these minority  cases.   In the  majority of  cases, the  errors never
     happen.  This means that the main logic of the dialog can get diluted by all the
     extraneous states.   With exceptions, you write the dialog as though errors were
     incidental.   When an  error happens,  you treat  it as  a special  case, as  an
     'exception'.  Otherwise, the dialog carries on normally.

       Take the example of three actions which the dialog executes in series.  First,
     it reads  some data from a file.  Then it parses and converts the data.  Lastly,
     it writes the data to another file.  Each of these actions has a normal outcome,
     and possible  exceptional outcomes  (error during  reading, invalid  data, error
     during writing, etc.).  If we write the dialog without exceptions, we need these
     three states:

       Before-Reading:
           (--) Ok                                 -> After-Reading
                 + Read-Data-From-Input
           (--) Error                              ->
                 + Terminate-The-Program

       After-Reading:
           (--) Ok                                 -> After-Parsing
                 + Parse-and-Convert-Data
           (--) Error                              ->
                 + Terminate-The-Program

       After-Parsing:
           (--) Ok                                 -> Another-State
                 + Write-Data-To-Output
                 + ...

     Printed 15 February, 1996                                               Page 42





     Libero User's Guide                                                 Version 2.11
           (--) Error                              ->
                 + Terminate-The-Program

       In this  case, Read-Data-From-Input  does something  like this (I use C as the
     language):

       MODULE read_data_from_input (void)
       {
           if (read_from_file (file, input) != NULL)
               the_next_event = ok_event;
           else
               the_next_event = error_event;
       }

       By using  an exception  event (here,  Error), we can collapse the three states
     into a single state:

       Before-Reading:
           (--) Ok                                 -> Another-State
                 + Read-Data-From-Input
                 + Parse-and-Convert-Data
                 + Write-Data-To-Output
                 + ...
           (--) Error                              ->
                 + Terminate-The-Program

       Read-Data-From-Input now does this:

       MODULE read_data_from_input (void)
       {
           if (read_from_file (file, input) == NULL)
               raise_exception (error_event);
       }

       Some hints about using exception events:

        + Don't over-use exceptions.  What you gain from a more compact dialog you
          can loose in unclear logic.  Remember that exceptions should be used for
          error handling and special cases, not for primary logic.

        + Choose good  names, and  use one  exception event  for the  same purpose
          everywhere.   For  instance,  use  an  exception  event  Fatal-Error  to
          indicate a fatal i/o error that causes the dialog to halt.

        + The Defaults  state is  an ideal  place to  handle exceptions  which may
          occur in  many places.  However, do place specific exception handling in
          any state where it is useful.


     The Defaults State

       You can  define a  single Defaults state in any dialog.  You use this state to
     simplify dialogs.   Often,  the same  event can  happen in many states, with the
     same effect.   Typically,  you want  to handle  a fatal  error at  any point  by
     displaying a message and halting the program.

       Rather than  repeating the  event and  its (identical)  actions in every state
     where the  fatal error  may happen,  place it  in Defaults.   If  the event ever
     happens, Libero  looks in  the current state first.  If it cannot find the event
     Printed 15 February, 1996                                               Page 43





     Libero User's Guide                                                 Version 2.11
     there it  looks in  the Defaults  state.   The Defaults state is ideal for error
     exception events that require central handling.

       After processing  the actions for the event, the dialog sets the next state as
     follows: if the specified next state is empty, it returns to the original state.
     If some next state is specified, it goes to that state.

       When you use a Defaults state, the generated code for your dialog does not get
     smaller.  It will actually get a little larger.  But your dialog source code can
     usually be simplified, and this is always a good idea.


     Using Sub-Dialogs

       Libero supports  a simple  state call/return  mechanism.   This lets you build
     sub-dialogs that  are called  from other places in the dialog.  In the 'calling'
     state, use the action Dialog-Call to call the sub-dialog state:

       Calling-State:
           (--) Ok                                 -> Sub-State
                 + Do-Some-Normal-Work
                 + Dialog-Call
           (--) Return                             -> Next-State
                 + Continue-After-Call

       The Return event controls what happens when the sub-state returns.  The Return
     event can be in the same state, or in the  Defaults state.

       The sub-dialog  can consist  of one  or many  states.  You should probably use
     some kind  of naming  convention to  indicate that these states go together.  At
     some point,  the sub-dialog  uses the  action Dialog-Return.  This ends the sub-
     dialog and continues in the calling state with the Return event.


     Efficiency of The Generated Code

       People sometimes  ask of  Libero: "But  does it  produce efficient programs?".
     Bad grammar apart, this question gets a considered answer.  Usually I say: "What
     do you mean by 'efficient'?", or "Does a hammer build a solid table?".  I have a
     practical definition  of 'efficient':  if a  program is  easy to  write, easy to
     maintain, does  the job on time, and no-one has trouble with it, it's efficient.
     It's also unusual, but that is another soap-box.

       When I  wrote Libero,  my true  goal was to make programming easier and safer,
     whatever the  language.   This also  gives me  a convenient stock answer: if you
     write a  program using  Libero, and  you find  that it  runs too slowly, you can
     rewrite it in a faster language quickly and cheaply.


     Efficiency of The Dialog

       First of  all, the size of a dialog has no direct relationship to the speed of
     the program.   A  very large program will load and maybe run slower than a small
     one, but the program has to be a lot larger.

       Secondly, adding  a new state, event, or action module will make the generated
     code larger.   If  a dialog has 10 states, then a new event will add 20 words to
     the program  size.   If a  dialog has  50 states,  then a new event will add 100
     words.  A dialog with 100 states and 100 events will use a whopping 20,000 words
     Printed 15 February, 1996                                               Page 44





     Libero User's Guide                                                 Version 2.11
     of storage  for its main tables11.  However, a program this complex is likely to
     be several hundreds of thousands of lines long.

       So, I generally tell people: if you make your dialog smaller, do it because it
     is better design, not because it is more efficient.


     Style - Good, Bad, and Ugly

       Some of  the worst  dialogs that  I have  seen were written by people who were
     trying to  make their  dialogs 'efficient'.  It is not easy to write elegant and
     readable dialogs; it is a little like making pancakes: give the first one to the
     dog.  I have some advice: ask a colleague to read the dialog and explain how the
     program works.  If your colleague cannot understand something, rewrite it.

       The following  extracts are from real-life dialogs that went wrong.  I changed
     names and  did some  surgery to protect the guilty, and myself from prosecution.
     All I  can say  in defence  of the  authors was that these were early works, and
     that they had too little training.

       Example 1:  the author tries to reduce the number of states by looping back to
     the same  state several times.  Then he12 compounds the sin by using event names
     that are specific to the state:

       Valorisation:
           (--) Valori-Not-Ok                      -> Valorisation
                 + Update-Valorisation
                 + Get-Next-Valorisation
           (--) Valori-Ok                          -> Valorisation
                 + Process-Valorisation
                 + Get-Next-Valorisation
           (--) Ok                                 -> Valorisation
                 + Test-Valorisation
           (--) No-Valori                          -> Valorisation
                 + Get-Next-Valorisation
           (--) No-More                            -> Transfer
                 + Get-First-Transfer















     ____________________
     11  It is  possible to compress large FSM tables, but I never had a problem that
     was so  complex that  it was  worth it.   It is a function that one could add to
     Libero in the future.

     12  I know the lad, so I can safely use the pronoun.

     Printed 15 February, 1996                                               Page 45





     Libero User's Guide                                                 Version 2.11
       Transfer:
           (--) Transf-Not-Ok                      -> Transfer
                 + Update-Transfer
                 + Get-Next-Transfer
           (--) Transf-Ok                          -> Transfer
                 + Process-Transfer
                 + Get-Next-Transfer
           (--) Ok                                 -> Transfer
                 + Test-Transfer
           (--) No-Transf                          -> Transfer
                 + Get-Next-Transfer
           (--) No-More                            ->
                 + Close-Data-Files
                 + Terminate-The-Program

       This is the advice I gave:

        + Don't use  a single  state when the design demands several states.  This
          does not  save space  - since  you have  to invent more event names - it
          just makes the dialog hard to understand.

        + Use exceptions to reduce the complexity of a dialog.

        + Don't use  event names  that are  only meaningful  in  one  state,  like
          'Transf-Not-Ok'.   This makes  the code less reusable.  It also tightens
          the binding  between action  modules and  the state,  which is  makes it
          harder to reuse action modules and change the dialog.

        + Use meaningful  names for  states.  The state is an important concept in
          the design.

        + Use helpful  names for  the action  modules.   Test-Transfer  tells  the
          reader very little about what is happening.

       Example 2:  the author  is struggling  with a  complex batch process.  At this
     stage he  has to  do a  whole series  of  actions,  with  one  small  difference
     depending on the contents of a key field:

       After-Test-Key:
           (--) Key-Empty                          -> Have-Order
                 + Save-Current-Order-Record
                 + Get-Contract-For-Order
                 + Get-Company-For-Contract
                 + Create-Invoice-Header
                 + Update-Company
                 + Save-Contract-Key
                 + Call-Batch-012
                 + Call-Batch-013
                 + Get-Next-Order-Record










     Printed 15 February, 1996                                               Page 46





     Libero User's Guide                                                 Version 2.11
           (--) Key-Not-Empty                      -> Have-Order
                 + Treat-For-Current
                 + Save-Current-Order-Record
                 + Get-Contract-For-Order
                 + Get-Company-For-Contract
                 + Create-Invoice-Header
                 + Update-Company
                 + Save-Contract-Key
                 + Call-Batch-012
                 + Call-Batch-013
                 + Get-Next-Order-Record

       This was my advice (resisting the urge to say 'junk it!'):

        + Don't be  obsessed by  detailed breakdowns  of logic.  Perhaps the whole
          series of steps above could be better bundled into two modules: Process-
          Order-Record and Get-Next-Order-Record.

        + Don't copy  large chunks  of code  like this;  it creates  a maintenance
          problem.

        + The only  difference between  the two  action lists  is the extra action
          Treat-for-Current  (whatever   that  means).     It  is  quite  okay  to
          internalise this  step and  have a module like Treat-for-Current-If-Key-
          Filled.  Don't bring microdecisions up to the level of the dialog.

       These are some more common problems:

        + Dialog modules  that explicitly  set an  event, like  'Set-Ok'.  This is
          very rarely a useful way to shunt control to a specific state.  Usually,
          though, it is a sign of trouble.

        + Dialogs that are broken into very many small states.  This usually means
          that the designer has not figured-out how exceptions work.

        + Dialogs that use lots and lots of different event names.


     Choosing Names

       These are some guide-lines for names in a dialog:


       For:              Try this:

       States            In-Some-State,      After-Something,      Before-Something,
                         Expecting-Something, Have-Some-Data.

       Events            External actions:  Help, Exit,  Delete, Create,... Internal
                         conditions: Ok, Error, Locked, Fatal-Error, No-More; Types:
                         Number, String, Function,...

       Modules           Active   statements:    Delete-The-Record,   Print-Current-
                         Invoice, Start-The-Transaction, Commit-All-Changes,...


       A common  beginner's mistake is to confuse events and modules, so that a state
     has events  called 'Delete-Record',  'Print-Record', and  so on.  It can help to
     remember that event names must be as general as possible without losing meaning.
     Printed 15 February, 1996                                               Page 47





     Libero User's Guide                                                 Version 2.11
       One helpful  comparison is  to think  of events  as push-buttons  in a  pop-up
     window box.  Common events are 'Ok' and 'Cancel', 'Print', 'Delete', and 'Help'.
     A push-button like 'Delete Next Record' is too specific.


     Using Templates

       The standard  Libero schemas  support templates.  This just means that you can
     build a library of code that the generator will pull-in whenever you use it in a
     dialog.

       For example, let's say that you are working in a COBOL application where a lot
     of programs need to do the same work in Initialise-The-Program:

           MOVE LINKAGE-BLOCK TO OWN-LINKAGE-BLOCK
           PERFORM CHECK-LINKAGE-VALUES
           IF CURRENT-LANGUAGE = SPACES
               MOVE "ENGLISH" TO CURRENT-LANGUAGE

       You can either:

        + Retype or  copy this  code into  each new  program you  create.  This is
          extra effort for nothing.

        + Modify the  standard schema.   This is also extra effort, not today, but
          when the next release of Libero comes around.

        + Use a template.  Of course, this is the way to do it.

       Let's say you make a file called TEMPLATE.cob.  This looks like this:

       <Initialise-The-Program>
           MOVE LINKAGE-BLOCK TO OWN-LINKAGE-BLOCK
           PERFORM CHECK-LINKAGE-VALUES
           IF CURRENT-LANGUAGE = SPACES
               MOVE "ENGLISH" TO CURRENT-LANGUAGE
       <END>

       Now, when  you build a new program, Libero magically includes this code in the
     INITIALISE-THE-PROGRAM section.

       This is how templates work:

        + Each schema  looks for  a template  file with  the same extension as the
          schema.  If the template file does not exist, this is okay.

        + The schema  'pulls in' code at various points.  Again, if it cannot find
          the code it's looking for, that is okay.

        + Each section  in the  template starts with a keyword between "<" and ">"
          and ends  in "<END>".   The  schemas define a number of standard section
          keywords: "<HEADER>" and "<DATA>", plus one section per module.

        + The keywords  are case-sensitive.   <get-next-token>  is not the same as
          <Get-Next-Token>.  The second form is correct; the first will not work.

        + The template can be in the current directory, or on the path.

       The file template provides an example that you can use for your own templates.
     Printed 15 February, 1996                                               Page 48





     Libero User's Guide                                                 Version 2.11
     Choosing A Language


       One of  the great  advantages of  Libero is  the freedom  you get  to choose a
     language that  suits your  purpose.  This is not always an evident proposal.  If
     you develop a good style in one language, you can easily find that this does not
     translate to  another.   For example,  good C  coding practice  is irrelevant to
     assembler or  Basic.   So, these are the languages I have written schemas for so
     far, with the pro's and con's for each language as I see them.


     The Awk Language

       What it is        Part of  UNIX;  comes  in  several  flavours  -  'old'  awk
                         (/bin/awk), new  awk  (/bin/nawk),  GNU  gawk  (/bin/gawk).
                         Small interpreted  language, tastes  of C,  with  a  strong
                         flavour of sed pattern matching.  Mostly used to manipulate
                         text files,  but also  fun as a general-purpose programming
                         language.

       Portability       GNU gawk  is available  on many platforms.  Awk scripts are
                         highly portable  if  you  don't  rely  on  system-dependent
                         commands.

       Pros              Very  versatile,   easy  to   learn,  GNU  gawk  is  freely
                         available.  Interpreted language.  Looks a lot like C.

       Cons              A simple  language, not  powerful  enough  for  industrial-
                         strength work.   Interpreted  language (slower  than C  but
                         faster than a shell).  Looks a lot like C.

       How to get it     On UNIX boxes, 'awk'.  On other systems, get GNU gawk.

       Libero supports   new awk and gawk, but not old awk.



     The C Language

       What it is        Part of  UNIX originally,  now almost a universal language.
                         Very  general   purpose  and  typically  used  for  systems
                         programming.  ANSI C is a widely supported standard.

       Portability       ANSI C  compilers are  available on (almost) all platforms.
                         ANSI C  programs can  be  highly  portable  if  you  eschew
                         compiler extensions,  and don't  rely on libraries that are
                         not portable.

       Pros              Flexible, widely  known.   Small and  clean  language.    C
                         compilers   are    generally   well-tuned   and   sometimes
                         exceptionally good.

       Cons              Perhaps: no  object orientation.   Sloppy programmers write
                         horrendous C code.

       How to get it     On UNIX  boxes, 'cc',  or 'gcc'.  GNU C is widely available
                         and well-regarded.   Commercial  C compilers  are available
                         for  almost  all  platforms  from  mainframes  to  embedded
                         systems.
     Printed 15 February, 1996                                               Page 49





     Libero User's Guide                                                 Version 2.11
       Libero supports   ANSI C.



     The COBOL Language

       What it is        Standard language  for business  development.  Very heavily
                         used in  mainframe world.  Has an undeserved reputation for
                         inefficiency, and  a  deserved  reputation  for  verbosity.
                         Today,  many   COBOL  applications  are  being  moved  from
                         mainframes to UNIX boxes.

       Portability       Deaf, dumb,  blind COBOL  programs can  be  very  portable.
                         Otherwise you  can use  external libraries  to achieve 100%
                         portability (catch:  you may  have to write these libraries
                         yourself).

       Pros              Easy to  use and teach.  An excellent language for mediocre
                         developers, which  includes me  at least  two days  of  the
                         week.

       Cons              Tends  to  encourage  large,  monolithic  programs.    Like
                         unreadable C  code, this  is a  question of discipline.  No
                         way to define data types directly.  A verbose and over-rich
                         syntax.  COBOL compilers are often unimpressive.

       How to get it     No free  implementations exist, despite various attempts13.
                         You need to find a commercial COBOL vendor for your system.

       Libero supports   ANSI 74 COBOL and ANSI 85 COBOL.



     The 80x86 Assembler Language

       What it is        Native language  for most  of the  world's PCs.   Fast  and
                         dangerous.   Gives you  a 5-to-10  performance  improvement
                         over the best C compilers.

       Portability       Very portable  to all  compatible CPU's.   Comes in various
                         varieties, following  the evolution  in 80x86  CPU's.   The
                         common denominator is the 8086.

       Pros              Can't get it faster.  Can't make it smaller.

       Cons              Multiply your development and maintenance costs by ten.

       How to get it     There are  various free  and shareware  assemblers  around,
                         which are  not all  compatible in  terms of  syntax.    The
                         'standards'  are   the  Borland  TASM  and  Microsoft  MASM
                         products.

       Libero supports   MS MASM 5.0: .com files, .exe files, and subroutines.


     ____________________
     13  Including one  by me:  if a  COBOL compiler  is Mt. Everest, I got as far as
     London Heathrow airport.

     Printed 15 February, 1996                                               Page 50





     Libero User's Guide                                                 Version 2.11
     The GNU Borne-Again Shell Language

       What it is        GNU BASH  shell language, replaces the standard UNIX shells
                         (/bin/bash).

       Portability       Available for  all UNIX  systems that  I  know  of.    BASH
                         scripts can  be ported to other UNIX shells: the closest is
                         the Korn shell.

       Pros              Freely available and standardised.  Follows POSIX standard.
                         Has best of all UNIX shells in one package.

       Cons              Not necessarily installed on your UNIX box.

       How to get it     Get it  from your  local GNU shoppe.  Included in the Linux
                         system.

       Libero supports   GNU Borne-again shell.



     The Microsoft Setup Basic Language

       What it is        Scripting language  used and  pushed by  Microsoft for  MS-
                         Windows 3.1  setup procedures.   Identical  to the  MS-Test
                         Basic language, version 1.0.

       Portability       Not.  Unless you are heavily into MS-Test.

       Pros              Standard for setup procedures, easily available.

       Cons              You have  to be  an experienced Windows developer, and have
                         other visual development tools, to use it.

       How to get it     Part of the Windows SDK.

       Libero supports   MS Setup BASIC / Test Basic 1.0.



     The Perl Language

       What it is        Mutant child  of Awk,  C,  and  UNIX  shells.    Raised  on
                         radioactive crispies and steroid milk.  (/user/bin/perl).

       Portability       UNIX boxes, with ports to many other systems.

       Pros              Very powerful and flexible interpreted language.

       Cons              If you  can't handle  type-free languages  where just about
                         anything goes, go back to Pascal.

       How to get it     By Internet from ftp.uu.net and many other places.

       Libero supports   Perl 4.x.




     Printed 15 February, 1996                                               Page 51





     Libero User's Guide                                                 Version 2.11
     The UNIX Bourne Shell Language

       What it is        Original UNIX shell language (/bin/sh).

       Portability       Very standard across UNIX boxes.

       Pros              Standard.   Your scripts  will run  on most if not all UNIX
                         boxes.

       Cons              Limited and out-dated.

       How to get it     Should be part of your UNIX system.

       Libero supports   UNIX Bourne shell.



     The UNIX C Shell Language

       What it is        UNIX shell 'for C programmers' (/bin/csh).

       Portability       Very standard across UNIX boxes.

       Pros              Standard.   Your scripts  will run  on most if not all UNIX
                         boxes.  Looks a bit like C.

       Cons              Limited and out-dated.  No functions.  Looks a bit like C.

       How to get it     Should be part of your UNIX system.

       Libero supports   UNIX C shell.



     The UNIX Korn Shell Language

       What it is        Most advanced  'standard' UNIX  shell  (/bin/ksh),  public-
                         domain shell (/bin/pdksh)

       Portability       Standard across UNIX boxes.

       Pros              Your scripts will run on most UNIX boxes.

       Cons              Like all shells, slowish.

       How to get it     Should be part of your UNIX system.

       Libero supports   UNIX Korn  shell  and  public-domain  Korn  shell  by  Eric
                         Baalberger.



     The Visual Basic Language

       What it is        Microsoft's   rapid   application   development   language.
                         Standard scripting language for MS applications.

       Portability       Common macro  language for  MS applications;  supported  by
                         some third party applications.
     Printed 15 February, 1996                                               Page 52





     Libero User's Guide                                                 Version 2.11
       Pros              Easy to use, widely used.  Interpreted language.

       Cons              Slow screen updates.  Interpreted language.

       How to get it     From your local software shop.

       Libero supports   MS Visual Basic 3.0.



     Working In Specific Languages


       The way I add support for a particular language is to write a new schema file.
     This is  a kind  of script  that tells  Libero how  to generate  code  for  that
     particular language.   Inevitably, the solution I choose for a language tends to
     vary.  For example, the C schema generates a couple of include files to hold the
     generated code.   The UNIX shell schemas in contrast take a source 'module' file
     and generate the final script (which you don't work on directly).

       This section  documents the  special aspects  of each  language (ie.  schema).
     There are some concerns that apply to all languages:

        + All the  schemas separate the generated code from the hand-written code.
          This  means  either  a  strict  division  into  hand-written  files  and
          generated files,  or some  sleight-of-hand to get a similar result.  The
          mechanism varies  from language  to language  since I use the mechanisms
          that each  language offers  (if any).  You should understand which files
          you get when you work in a particular language.

        + Most languages  provide some  form of  function or subroutine.  I define
          one such  for each module in the dialog, and you are free to define your
          own 'private'  functions in  the code.   Libero provides the facility to
          detect unused  ('idle') modules,  but for this the syntax for the module
          functions  must  be  different  to  that  for  your  private  functions.
          (Otherwise Libero  can't  tell  the  difference,  and  issues  loads  of
          incorrect warning  messages.)   In a  few languages  I did  not find  an
          acceptable way  of making  the distinction,  so  the  -idle  options  is
          disabled.   In the  remaining languages you must take care to follow the
          recommended syntax for your private functions.

        + The generated code provides a number of public data items and functions.
          These have the same name in each language, as far as possible.  Reserved
          names start  with 'LR__'  or something  similar.   Never use or refer to
          these names.


     Standard Public Names

       All schemas should support these names, which change syntax according to the -
     style option:


       Item:             Purpose:

       xxxx_event        Defined for  each event  in the dialog, where 'xxxx' is the
                         name used  in the  dialog.   Use these event names whenever
                         you need to set the value of the_next_event.

     Printed 15 February, 1996                                               Page 53





     Libero User's Guide                                                 Version 2.11
       the_next_event    The event for the next state.  Set this event in one of the
                         action modules, before entering a new state.

       terminate_event   When you  assign this  to the_next_event, the state machine
                         halts.       Normally   you    will   do    this   in   the
                         terminate_the_program module.

       exception_raised  If you  set this to TRUE, the dialog engine stops executing
                         the current  action list, and goes into exception handling.
                         Exceptions are described later.

       the_exception_event                   Before you raise an exception, set this
                         to the  event you  want to  use as  exception event.   This
                         event must  be defined  in the current state you are in, or
                         in the Defaults state.

       initialise_the_program                This standard module is called when the
                         dialog  engine  starts;  here  you  can  access  and  check
                         parameters, and set a suitable next event like ok_event.

       get_external_event                    This standard module is called when the
                         dialog needs an event, i.e. when none of the action modules
                         put anything in the_next_event.

       raise_exception   This standard function sets exception_raised and places the
                         specified event into the_exception_event.



     Working With Awk


       Summary Of The Awk Schema

       Schema            lrschema.awk

       Program model     Shell-wrapped  awk   script;  directly   executable.    All
                         processing is done in the BEGIN block.

       Recommended for   Large awk scripts that handle multiple files.

       Files used/made   Own work in myprog.mod; generates program called myprog.

       Module functions  function module_function_name \

       Private functions function private_function_name () {

       Naming style      Any except -style=cobol.

       Limits            Standard Libero  limits, and system memory.  All tables are
                         defined dynamically at runtime.

       Development cycle Run lr  after you change the dialog or .mod file.  When you
                         add a new module, run lr, then edit the .mod file, then run
                         lr again.  Don't change the generated awk script except for
                         tests - you'll lose your changes.



     Printed 15 February, 1996                                               Page 54





     Libero User's Guide                                                 Version 2.11
       Example of code:


           #################   MODULE FUNCTION NAME   #################

           function module_function_name \
            ( local_var,... ) {              Place local variables here
               return                        Empty module needs 'return'
           }

           function private_function_name (argument,...) {
               the_next_event = ok_event
               raise_exception (error_event)
           }


       My awk  programs fall  between two extremes.  At the one end is a 'filter', to
     process text according to patterns in each line.  This is excellent for smallish
     problems.   As the  problem grows, I need to read other files 'on the side', and
     the logic  of my  awk program  grows until  a large part of it is sitting in the
     BEGIN or  END blocks.   Eventually  I find that I am perhaps reading and writing
     several files,  so I take the plunge and rewrite the program to handle all files
     with explicit  'getline' calls.   The  awk program  is no longer a filter, but a
     stand-alone program  that resembles  a classic procedural program.  Of course at
     this point  my Libero  hindbrain wakes  up and  starts muttering 'an' whaddabout
     Libero, eh?'.

       When I  wrote the  awk  schema,  I  started  with  the  Visual  Basic  schema.
     Bizzarely enough  this language  resembles awk  most in  terms of  structure and
     possibilities.  I've started thinking of awk as a kind of 'Basic for UNIX'.

       Awk presents  some of  the same  difficulties as  Visual Basic.   There  is no
     'include' statement  to take  an external file as part of the program.  The UNIX
     shells have the same problem.

       <gripe>Since awk  is tokenised,  then executed,  messieurs A,  W, and K had no
     real excuse for omitting an 'include' facility.</gripe>

       I really  don't want  to look at the chunk of code that Libero generates, so I
     always try  to find  a way  to separate  this from  the hand-written  code I  am
     working on.   If  the language  provides an  'include' statement,  I  place  the
     generated code  in an  include file.   This  works  great  in  serious  compiled
     languages which all have something like this.  You change the dialog, regenerate
     the code,  and recompile.   At any time you can change the program and recompile
     without having to run Libero again.

       For the  awk schema  I used another technique: you work in a separate 'module'
     file (myprog.mod).   Libero  combines the module file with the generated program
     to create  a final  program, which you don't change.  This effectively hides the
     generated code, but introduces an extra step: each time you change the .mod file
     you must  re-run Libero to create the final script.  In effect, Libero acting as
     a preprocessor in place of the missing 'include' statement.







     Printed 15 February, 1996                                               Page 55





     Libero User's Guide                                                 Version 2.11
       Notice the slightly unusual format of a generated module header:


           function module_function_name \
            ( local_var,... ) {
               ...
           }


       I break the function header over two lines so that you can add local variables
     easily if you need to.  Libero recognises the first line as a module header, and
     does not  look at  the next  line with  the local variables.  The unusual format
     also distinguishes  module functions from private functions, so ensures that the
     -idle option works correctly.


     Working With C


       Summary Of The C Schema

       Schema            lrschema.c

       Program model     Function with  arguments; you  can change the function name
                         and arguments in the proposed program.

       Recommended for   Large C programs; complex functions; batch programs.

       Files used/made   Own work  in myprog.c;  generates include  files mydialog.d
                         and mydialog.i.   You  will also  need the prelude.h header
                         file at compile time.

       Module functions  MODULE module_function_name (void)

       Private functions static type private_function_name ()

       Naming style      Any except -style=cobol.

       Limits            Standard Libero  limits.  All tables are defined statically
                         in the myprog.i file.

       Development cycle Run lr  after changing the dialog.  If you add new modules,
                         update the  .c program.   Compile, link, and run.  You need
                         the .i and .d files at compile time.















     Printed 15 February, 1996                                               Page 56





     Libero User's Guide                                                 Version 2.11
       Example of code:


           /****************   MODULE FUNCTION NAME   *****************/

           MODULE module_function_name (void)
           {
                                             Empty module needs no code
           }

           static type private_function_name (argument,...) {
               the_next_event = ok_event;
               raise_exception (error_event);
           }


       I've used  Libero to  help me  write C  programs for a few years.  It would be
     dishonest to  say I  used Libero all the time; this is simply not the case.  For
     example, I  wrote Libero  in C:  there are 12 separate source files, and four of
     these have  dialogs.   I used a dialog whenever I had a single function that got
     rather complex.  In Libero, this happens to be in:

        + the module that parses and loads a dialog (lrload);

        + the code  generator module,  which scans  the schema  and interprets the
          simple language embedded in the schema (lrcode);

        + the two modules that evaluate expressions (lrcalc and lreval).

       It's probably  no coincidence  that all these modules do some kind of parsing.
     Libero is  a code  generator, so  it's normal  that the most complex modules are
     parsers.  As a consultant, I've written some profoundly complex C programs using
     Libero.  In at least one case (see page 96) I still don't see any other way that
     I could have done the project.

       When you write a C program using Libero, you tend to use a lot of source-local
     variables.   This is  disturbing to  some programmers, who reckon that a program
     must consist  of lots  of internested  modules that  hide data  from each other.
     Sure, this  is one  way of  managing complexity.   Still, modules in a Liberated
     program aren't  nested; they  all sit  at the same level below the dialog.  They
     all share (mostly) a common set of data objects.  In real programs this seems to
     work nicely, so if you have problems with it, just close your eyes the first few
     times.


     Working With COBOL


       Summary Of The COBOL Schema

       Schema            lrschema.cob

       Program model     Main program without linkage or called program with linkage

       Recommended for   COBOL batch programs and subroutines.

       Files used/made   Own work in MYPROG.cob; generates a copy book MYDIALOG.cbl.

       Module functions  MODULE-FUNCTION-NAME.
     Printed 15 February, 1996                                               Page 57





     Libero User's Guide                                                 Version 2.11
       Private functions PRIVATE-FUNCTION-NAME.

       Naming style      Schema sets -style=cobol automatically.

       Limits            999 states,  events,  modules.    (Libero  allows  1000  of
                         anything.)   All  tables  are  defined  statically.    Some
                         compilers restrict any one 01-level item to 32K bytes.

       Development cycle Run lr  after you  change the  dialog.    Edit  the  source
                         program, then recompile and link.

       Notes             The dialog  file cannot  have same  name  as  program;  the
                         schema gives  an error message in this case.  I suggest you
                         use the -plusd option in your dialog.

                         Since there  is no way to distinguish the dialog paragraphs
                         ('modules') from  private paragraphs,  the schema turns-off
                         idle module checking.

                         With some  compilers (typically on IBM systems) you need to
                         add a  QUOTES option  to compile  the generated  code.  The
                         generated code  uses quotes, not apostrophes - this is more
                         portable.

                         There is  no FEEDBACK variable or RAISE-EXCEPTION function,
                         in contrast with most other schemas.

                         Assumes the  old-fashioned 80-column  format  with  6-digit
                         sequence number and 8-character comment at right-hand side.
                         Generates upper-case text.


       The schema supports these specific options:


       Specific options: Explanation:

       -opt:ext=xxx      'xxx' is  extension for  copybook.  Default value is 'cbl'.
                         Recommended values  are: 'cob' for MS-DOS Realia, 'cbl' for
                         UNIX, 'lib' for VAX/VMS.

       -opt:model=main   The generated  code does  not define  any linkage  section.
                         This is the default model.

       -opt:model=called The generated  code defines a linkage section that contains
                         a single  01-level data  item.   You must  detail this data
                         item in  a copybook  called MYPROGR.    The  copybook  must
                         follow this  general format, with a 01-level header, then a
                         comment line  containing the  text  '*CONTENTS',  then  the
                         details of the linkage section.  For example:









     Printed 15 February, 1996                                               Page 58





     Libero User's Guide                                                 Version 2.11
       000100 01  CALCPK-CONTROL.
       000200*CONTENTS
       000300     02  CALCPK-OPERATION        PIC X.
       000400     02  CALCPK-FEEDBACK         PIC X.
       000500     02  CALCPK-POINT-CHAR       PIC X.
       000600     02  CALCPK-ERROR-RETURN.
       000700         03  CALCPK-ERROR-CODE   PIC X(2).
       000800         03  CALCPK-ERROR-MESG   PIC X(30).
       000900     02  CALCPK-ERROR-POSN       PIC 9(2).
       001000     02  CALCPK-EXPRESSION.
       001100         03  EXPR-CHAR           PIC X          OCCURS 80 TIMES.
       001200     02  CALCPK-RESULT           PIC S9(9)V9(9).
       001300     02  CALCPK-VARIABLE         PIC S9(9)V9(9) OCCURS 5 TIMES.

       -opt:level=ansi74 Generate ANSI 74 COBOL.  Some COBOL compilers don't support
                         ANSI 85 COBOL.  This is the default level.

       -opt:level=ansi85 Generate ANSI  85 COBOL.   The  ANSI 85  code runs a little
                         faster, since  it uses  an  EVALUATE  statement  against  a
                         series of IF statements in the ANSI 74 code.

       -opt:console=name Display  trace  output  and  error  messages  on  specified
                         device.   By default  blank.   Some  systems  do  not  like
                         DISPLAY by  itself, and require an output device name.  For
                         example, to  generate statements  DISPLAY ... UPON CONSOLE,
                         use 'opt:console="UPON CONSOLE"'.  Note that you must place
                         quotes around  the value  for two  reasons: it  contains  a
                         space, and you want to keep it in uppercase.


       Example of code:


           *****************   MODULE FUNCTION NAME   *****************

            MODULE-FUNCTION-NAME.
                EXIT                         Empty module needs 'EXIT'
                .


            PRIVATE-FUNCTION-NAME.
                MOVE OK-EVENT TO THE-NEXT-EVENT

                MOVE ERROR-EVENT TO THE-EXCEPTION-EVENT
                MOVE    "YES"    TO EXCEPTION-RAISED
                .


       COBOL has  a reputation  for encouraging  large unwieldy  programs.   This  is
     justified to  the extent that the language is verbose.  I think it's more due to
     the fact  that COBOL programs tend to be written and maintained under particular
     pressures: get  it working,  now, and who cares if it is a little unwieldy.  You
     don't often  see COBOL  code competing  on the  open market  for software  where
     program size and speed are important.

       People working in COBOL expect monsters, so often get them.  Now, I've spent a
     lot of  my life  writing COBOL  - perhaps half a million lines or so, and I know
     that this  unnecessary suffering.   Of  course it  is possible  to write  clean,

     Printed 15 February, 1996                                               Page 59





     Libero User's Guide                                                 Version 2.11
     organised, commented code without Libero.  It is just a lot more effort, and I'm
     lazy.

       This schema  is for  batch programs and subroutines.  Batch programs are often
     the largest  and most  complex COBOL  programs, and often benefit from a dialog.
     I've not seen a lot of subroutines that really needed a a dialog; the expression
     calculator is  one example.   Also,  if you  split a  large batch  program  into
     smaller subroutines,  these can  be complex  enough to  warrant a  dialog.  Very
     roughly, I  would reckon  that a  COBOL program of more than 1000 lines is worth
     building around a dialog.


     Working With 80x86 Assembler


       Summary Of The 80x86 Assembler Schema

       Schema            lrschema.asm

       Program model     .EXE file, .COM file, or large-model C subroutine.

       Recommended for   Anything complex in assembler.

       Files used/made   Own  work   in  myprog.asm;   generates  an   include  file
                         mydialog.d.

       Module functions  MODULE module_function_name   
                         ...
                         ENDMODULE

       Private functions private_function_name PROC NEAR 
                         ...
                         ENDP

       Naming style      Schema sets -style=plain automatically.

       Limits            255 states,  254 modules, 253 events.  The schema checks at
                         generate-time that the dialog does not exceed these limits.
                         All tables are defined statically, at assembly time.

       Notes             Supports MASM 5.x syntax.


       The schema supports these specific options:


       Specific options: Explanation:

       -opt:model=com    Generate code  for a  .COM program.   This  is the  default
                         model.

       -opt:model=exe    Generate code for an .EXE program.

       -opt:stack_size=nnnn                  Size of stack for .EXE program; default
                         is 1024.

       -opt:model=lsub   Generate  code  for  a  large-model  subroutine  using  the
                         Microsoft/Borland C calling convention.

     Printed 15 February, 1996                                               Page 60





     Libero User's Guide                                                 Version 2.11
       The schema  provides these  data items,  macros, and  functions (including the
     standard ones provided by all schemas):


       Predefined names: Explanation:

       msg_helptext      Example of help message; change to suit (COM, EXE only).

       arg_text          db 128  dup(0):  Command  line  arguments,  null-terminated
                         (COM, EXE only).

       arg_size          db 0: Size of arguments (0 = none) (COM, EXE only).

       arg_help          db 0:  1 if  /? was specified on command line, else 0 (COM,
                         EXE only).

       newline           db '\n',0: newline as null-terminated string.

       the_next_event    dw 0: next event from module.

       the_exception_event                   dw 0: exception event from module.

       exception_raised  db 0: 1 if exception raised.

       feedback          db 0: return code to system.

       xxxx_event        Macro: defined  for each  event in the dialog, where 'xxxx'
                         is the name used in the dialog.

       terminate_event   Macro: when  you move  this to  the_next_event,  the  state
                         machine halts.

       raise_exception   Macro: raises  an exception and sets the_exception_event to
                         the event specified.

       pushr             Macro: push one or more registers onto stack.

       popr              Macro: pop one or more registers from stack.

       jmps              Macro: short jump.

       echo              Function: prints  null-terminated message  at DS:SI.    The
                         sequence \n  is treated as newline.  All registers are safe
                         except flags.

       echoch            Function: prints  character in  AL using BIOS tty function.
                         Does not change any registers except the flags.

       echonum           Function: displays  the value  in AX  as a  signed  decimal
                         number with one leading space, and optional sign.  Does not
                         change any  registers except the flags.  Number is in range
                         -32768..32767

       pause             Function: waits  for a  keystroke; if  [Esc] pressed, exits
                         program.  Does not change any registers except the flags.




     Printed 15 February, 1996                                               Page 61





     Libero User's Guide                                                 Version 2.11
       Example of code:


           ;****************   MODULE FUNCTION NAME   *****************

           MODULE module_function_name
                  ret                        All modules end in 'ret'
           ENDMODULE

           private_function_name proc near
               mov the_next_event,ok_event
               raise_exception error_event
           endp



       Programming with the COM model:

        + Assemble and link as a .COM file:


            masm $source;
            link $source;
            exe2bin $source.exe $source.com
            del $source.exe


        + Code, data,  and stack  are in same segment: CS, DS, ES, and SS point to
          the one segment, and never change.

       Programming with the EXE model:

        + Assemble and link as an .EXE file:


            masm $source;
            link $source;


        + Code, data, and stack each have their own segment.  DS and ES both point
          to the  data segment.   Default  stack size  is 1024;  you can ask for a
          larger stack using '-opt:stack_size=nnnn'.

       Programming with the LSUB model:

        + Assemble and link with a large-model calling program:


            masm $source;
            link caller+$source;


        + Code, data, and stack each have their own segment.  DS and ES both point
          to the data segment.  Stack is provided by calling program.

        + The FUNCTION_OPEN  macro defines the interface between your function and
          calling programs.   The  default is for C programming.  In the generated
          skeleton program,  change the  definition of 'function' to suit the name
          of your  function.   Note that it must start with '_' for C programming.
     Printed 15 February, 1996                                               Page 62





     Libero User's Guide                                                 Version 2.11
          Define  any   parameters  following  the  example  param1  shown.    The
          parameters to  a function  are passed  on the stack starting at <6[bp]>.
          Do not  make these  changes to  the skeleton,  but to  the program  that
          Libero generates for you the first time.

       Programming with all models:

        + Do not  rely on  registers being  safe between modules.  The dialog code
          uses these freely without saving them.

        + You can freely use any of the working registers (AX, BX, CX, DX, ES, DS,
          DI, SI) in a module function.

        + In a LSUB model program, do not change BP.

        + In an EXE or LSUB model program, ES is initialised to be equal to DS.


     Working With The GNU Borne-Again Shell


       Summary Of The GNU Borne-Again Shell Schema

       Schema            lrschema.bsh

       Program model     Executable UNIX script.

       Recommended for   Complex scripts; portable to GNU systems.

       Files used/made   Own work in myprog.mod; generates script called myprog.

       Module functions  function module_function_name 
                         {

       Private functions function private_function_name {

       Naming style      Any except -style=cobol.

       Limits            254 modules, 254 events, 1000 states.  The schema checks at
                         generate-time that the dialog does not exceed these limits.
                         All tables are defined dynamically, at runtime.

       Development cycle Run lr  after you change the dialog or .mod file.  When you
                         add a new module, run lr, then edit the .mod file, then run
                         lr again.   Don't  change the  generated script  except for
                         tests - you'll lose your changes.













     Printed 15 February, 1996                                               Page 63





     Libero User's Guide                                                 Version 2.11
       Example of code:


           #################   MODULE FUNCTION NAME   #################

           function module_function_name
           {
               return                        Empty module needs 'return'
           }

           function private_function_name {
               the_next_event=$ok_event
               raise_exception $error_event
           }


       Programming with the UNIX Shell schemas:

        + You must  remember to  assign events  and other  variables  as  follows:
          'the_next_event=$some_event'.    If  you  make  the  common  mistake  of
          forgetting the  '$', the  results are  interesting but  not useful.  The
          schema checks  against this error, at a slight cost in runtime.  You can
          skip these  checks by using the -nocheck option.  The BASH language lets
          you declare  numeric variables explicitly, so this check is not required
          in the lrschema.bsh schema.

        + Your .mod  file is  not copied  entirely, but  in sections.   The script
          schemas extract  three sections marked with the keywords <help>...<end>,
          <data>...<end>, and  <code>...<end>.   You will see :include commands in
          the schemas  that do  this.   The final  <end> is optional, and probably
          best to ignore.

        + The <help>  section is copied to the header of the script.  Each line in
          this section  should start  with '#'.   Some  of my  scripts  are  auto-
          anotating: if run with '-h' as argument, they do something like this:

          expand $0 | egrep "^# |^#$" | cut -c 4-80 | more

        + The module  Initialise_the_program gets  the command-line arguments; ie.
          it can refer to $1, $2, in the normal way.

        + The script_name  variable contains  the command-line  variable $0.   You
          could put something like this in initialise_the_program:

          if test "$1" = "-h"; then
              expand $script_name | egrep "^# |^#$" | \
              cut -c 4-80 | more
              exit
          fi

       Also note that:

        + It is  sometimes useful  to start  a script using the '.' operator.  For
          instance, to  trace a  script you  could use  these commands: 'set -x; .
          scriptname'.   If such a script ends with 'exit' (and the generated ones
          do), you  exit the  current shell.   If  it's your  main shell,  you are
          logged-out.   To avoid  this, enclose the entire command in parentheses:
          '( set -x; . scriptname )', or run a sub-shell first.

     Printed 15 February, 1996                                               Page 64





     Libero User's Guide                                                 Version 2.11
        + The auto-annotating  function explained  above won't work if you run the
          script using the '.' operator ($0 is then the name of the shell...).

        + These shell  script schemas  are somewhat slow.  I optimised the code to
          use as many internal commands as possible in place of external commands.
          This cut the time spent in the dialog manager code by 60% over the first
          version.  The bash and ksh versions are the most efficient; bsh does not
          have a  'let' command, so I need to use the clumsy "a = `expr 1 + 1`" to
          increment a  variable.   The bash shell version is the cleanest, since I
          can use  'declare' to  define numeric  variables.  Any attempt to assign
          text to a numeric variable gives an explict shell error message.

        + I use  a function  LR_idx to  access arrays  of numbers  by shifting and
          returning a numeric value.  This is the fastest method I could find, and
          it works  in all  three shell  languages.   As a consequence, there is a
          limit of 254 events (255 is the terminate_event).

        + If you are doing heavy shell-type programming, consider using Perl.


     Working With Microsoft Setup Basic


       Summary Of The Microsoft Setup Basic Schema

       Schema            lrschema.mst

       Program model     Main .mst program, run using _mssetup.exe driver.

       Recommended for   MS-Windows  setup   programs,  as  alternative  to  writing
                         complex logic directly into program code.

       Files used/made   Own   work    in   myprog.mst;   generates   include   file
                         mydialog.inc.

       Module functions  Static Sub module_function_name ()

       Private functions Sub private_function_name Static (...)

       Naming style      Any except -style=cobol.

       Limits            Standard Libero limits.  All tables are defined dynamically
                         at runtime.

       Notes             Still in  beta state.   I  have not used this schema in any
                         real program.













     Printed 15 February, 1996                                               Page 65





     Libero User's Guide                                                 Version 2.11
       Example of code:


           '****************   MODULE FUNCTION NAME   *****************

           Static Sub module_function_name ()

           End Sub

           Sub private_function_name Static (argument,...)
               the_next_event = ok_event
               raise_exception (error_event)
           }


       When I started writing a setup program for 'Libero for Windows', I got hold of
     the Microsoft  Setup Toolkit, and discovered the joys of writing a setup script.
     The language  is the  cut-down Basic  that was used in the MS Test product: Test
     Basic version  1.0.   I call  this almost-language MST.  At least, unlike Visual
     Basic, MST supports an include statement.  So, the MST schema puts the generated
     code into an .inc file.

       The setup  toolkit documentation  suggests that  you draw  a flowchart  of the
     various stages  of your  install procedure,  then code this into an MST program.
     Hmm.  :-(  I hate flowcharts, for one thing.  For another, I have a much simpler
     and useful  technique up  my sleeve,  so  some  quick  work  on  a  schema,  and
     'wallop!'.  MST meets Turning.

       As it happens, I then decided that I did not want to use an MST setup program,
     did not  want to start designing dialog boxes and resources.  Now the Libero for
     Windows installation  package is  a .zip file that you expand into the directory
     of your choice, full stop.  Still, the MST schema is there and it works, barring
     the odd lazy bug.


     Working With Perl


       Summary Of The Perl Schema

       Schema            lrschema.pl

       Program model     Perl program.

       Recommended for   Complex Perl programs.

       Files used/made   Own  work   in  MYPROG.pl;   generates  an   include   file
                         MYDIALOG.d.

       Module functions  sub module_function_name      
                         {

       Private functions sub private_function_name {

       Naming style      Any except -style=cobol.

       Limits            Normal Libero  limits.  All tables are defined dynamically,
                         at runtime.

     Printed 15 February, 1996                                               Page 66





     Libero User's Guide                                                 Version 2.11
       Example of code:


           #################   MODULE FUNCTION NAME   #################

           sub module_function_name
           {

           }

           function private_function_name {
               $the_next_event = $ok_event;
               &raise_exception ($error_event);
           }


       If you have used Perl, you will appreciate the way it combines the best of all
     the UNIX  text processing  and programming  tools.  For example, you need only a
     few lines of Perl to read and parse a parameter file ('ini file') like this:


           #============================================================
           #  Parameters for program
           #============================================================

           [General]
               OutBox=outbox             # Subdirectory for sent faxes

           [Connect]
               HostName=Badoit           # For Telnet
               UserName=autofax
               Password=autofax

           [FaxDriver]
               PauseChar="~"             # Substitute for commas

           [Station]
               Id=Station1               # Name of this local system



           open (INI, "autofax.ini") || die "Can't open autofax.ini: $!\n";
           while (<INI>) {
               chop;                           #   Remove trailing newline

               #   [SectionName] followed by optional comment
               if (/^\s*\[(\w+)\]\W*(#.*)?$/) {
                   ($section = $1) =~ tr/A-Z/a-z/;
               }
               #   Keyword=Value followed by optional comment
               if (/^\W*(\w+)=("[^"*]"|\w+)\W*(#.*)?$/) {
                   ($keyword = $1) =~ tr/A-Z/a-z/;
                   ($value = $2) =~ s/"//g;    #   Remove any quotes
                   $initial {$section, $keyword} = $value;
               }
           }
           close (INI);


     Printed 15 February, 1996                                               Page 67





     Libero User's Guide                                                 Version 2.11
       Similar code  in 'C'  is several pages.  This applies to many aspects of Perl,
     so that a complex program may be only a few hundred lines long.

       Perl is  also fast,  and works well with Libero.  The 'require' statement lets
     me hide  the generated  code in  a separate file, so that your program ends like
     this:

       ...

       ##########################   TERMINATE THE PROGRAM
       #########################

       sub terminate_the_program
       {
           $the_next_event = $terminate_event;
       }

       #%END
       require 'autofax.d';                    #   Include dialog interpreter

       The development  cycle is  simple: when you change your dialog, re-run Libero.
     When you  change the Perl program, re-run it.  As a tool, I give Perl five stars
     out of  five.   One last  tip: get your hands on the 'Programming Perl' Nutshell
     Handbook.


     Working With The UNIX Bourne Shell


       Summary Of The UNIX Bourne Shell Schema

       Schema            lrschema.sh

       Program model     Executable UNIX script.

       Recommended for   Complex scripts.

       Files used/made   Own work in myprog.mod; generates script called myprog.

       Module functions  module_function_name ()

       Private functions private_function_name ()

       Naming style      Any except -style=cobol.

       Limits            254 modules, 254 events, 1000 states.  The schema checks at
                         generate-time that the dialog does not exceed these limits.
                         All tables are defined dynamically, at runtime.

       Development cycle Run lr  after you change the dialog or .mod file.  When you
                         add a new module, run lr, then edit the .mod file, then run
                         lr again.   Don't  change the  generated script  except for
                         tests - you'll lose your changes.

       Notes             See page 64 for more information.




     Printed 15 February, 1996                                               Page 68





     Libero User's Guide                                                 Version 2.11
                         Since there  is no way to distinguish module functions from
                         private  functions,   the  schema   turns-off  idle  module
                         checking.


       Example of code:


           #################   MODULE FUNCTION NAME   #################

           module_function_name ()
           {
               return                        Empty module needs 'return'
           }

           private_function_name ()
           {
               the_next_event=$ok_event
               raise_exception $error_event
           }



     Working With The UNIX C Shell


       Summary Of The UNIX C Shell Schema

       Schema            lrschema.c

       Program model     Executable UNIX script.

       Recommended for   Complex scripts.

       Files used/made   Own work in myprog.mod; generates script called myprog.

       Module functions  module_function_name: #

       Private functions private_function_name:

       Naming style      Any except -style=cobol.

       Limits            254 modules, 254 events, 1000 states.  The schema checks at
                         generate-time that the dialog does not exceed these limits.
                         All tables are defined dynamically, at runtime.

       Development cycle Run lr  after you change the dialog or .mod file.  When you
                         add a new module, run lr, then edit the .mod file, then run
                         lr again.   Don't  change the  generated script  except for
                         tests - you'll lose your changes.

       Notes             See page 64 for more information.







     Printed 15 February, 1996                                               Page 69





     Libero User's Guide                                                 Version 2.11
       Example of code:


           #################   MODULE FUNCTION NAME   #################

           module_function_name: #
               return                        All modules end in 'return'

           private_function_name:            Actually, not possible
               set the_next_event=$ok_event
               raise_exception $error_event



       The C  shell has  no functions  (unless I missed something), so I use labelled
     blocks of  code.   Each such  block must  end with 'return'.  The schema defines
     this alias  to do  a goto  back to  the dialog  engine code.   Frankly, I cannot
     understand who  would write  or use this shell.  Get Perl, and use that instead.
     Nuff sed.


     Working With The UNIX Korn Shell


       Summary Of The UNIX Korn Shell Schema

       Schema            lrschema.ksh

       Program model     Executable script.

       Recommended for   Complex scripts.

       Files used/made   Own work in myprog.mod; generates script called myprog.

       Module functions  function module_function_name 
                         {

       Private functions function private_function_name {

       Naming style      Any except -style=cobol.

       Limits            254 modules, 254 events, 1000 states.  The schema checks at
                         generate-time that the dialog does not exceed these limits.
                         All tables are defined dynamically, at runtime.

       Development cycle Run lr  after you change the dialog or .mod file.  When you
                         add a new module, run lr, then edit the .mod file, then run
                         lr again.   Don't  change the  generated script  except for
                         tests - you'll lose your changes.

       Notes             See page 64 for more information.








     Printed 15 February, 1996                                               Page 70





     Libero User's Guide                                                 Version 2.11
       Example of code:


           #################   MODULE FUNCTION NAME   #################

           function module_function_name
           {
               return                        Empty module needs 'return'
           }

           function private_function_name {
               the_next_event=$ok_event
               raise_exception $error_event
           }



     Working With Visual Basic


       Summary Of The Visual Basic Schema

       Schema            lrschema.vb

       Program model     Subroutine with arbitrary name and arguments.

       Recommended for   Complex VB subroutines; batch programs.

       Files used/made   Own  work   in  myprog.bas;   generates  a  program  called
                         myprog.int.

       Module functions  Private Sub module_function_name ()

       Private functions Private Sub private_function_name ()

       Naming style      Any except -style=cobol.

       Limits            999 states,  events,  modules.    (Libero  allows  1000  of
                         anything.)  All tables are defined dynamically, at runtime.

       Notes             Since there  is no way to distinguish module functions from
                         private  functions,   the  schema   turns-off  idle  module
                         checking.


       The schema supports these specific options:


       Specific options: Explanation:

       -opt:slice=shared The program  cooperates with  Windows multitasking.  If the
                         program runs for a long time, this option lets you do other
                         things at the same time.

       -opt:slice=exclusive                  The program  does  not  cooperate  with
                         Windows multitasking.  This is the default option.



     Printed 15 February, 1996                                               Page 71





     Libero User's Guide                                                 Version 2.11
       Example of code:


           '
           '****************   MODULE FUNCTION NAME   *****************
           '
           Private Sub module_function_name ()

           End Sub

           Private Sub private_function_name (argument,...)
               the_next_event = ok_event
               exception_raised = True
               the_exception_event = error_event
           }


       Note that:

        + The .int  code file is the dialog interpreter.  You have to include both
          the .bas  and .int  files in  your project.   I  make the split into two
          files so  that you  are not  faced with the generated code when you edit
          the .bas source file.

        + The .int  interpreter calls  the  .bas  source  file  via  a  dispatcher
          function.   This function (which is generated) calls a particular module
          and returns event information.  This is not particularly fast, but works
          okay.

        + All functions are private; this allows several Liberated programs in the
          same VB application.

        + VB sorts  functions in  a source  file into alphabetical order; I called
          the dispatcher  'ZzDis_...' to ensure that it comes at the end.  This is
          just for  cosmetic reasons.   If for some reason the dispatcher function
          comes somewhere  in the middle of the source, everything will still work
          okay.   (I have  at least  one source  file where VB did not arrange the
          functions correctly.)

        + When you  change the  .bas source  file, you  can run the VB application
          right away.

        + When you change the dialog, you must regenerate the .int and .bas files,
          and either  stop and  restart VB,  or remove and re-insert the two files
          from your  project.   With VB version 4.0, I should be able to make this
          automatic.













     Printed 15 February, 1996                                               Page 72





     Libero User's Guide                                                 Version 2.11

                                    Reference Section




     Libero Schema Language


       You will  want to  read this section if you want to change a Libero schema, or
     write your own schema for another programming language or purpose.


     A First Look

       The schema  is a  type of program or script.  It tells the code generator what
     to do, when, and how.  Libero executes the schema from start to end.

       The code  generator has  a few  ideas about  what it  has to generate, but the
     schema usually has to tell it more.  For example, the schema can say 'generate a
     number like this: 001'.

       The schema  decides what files to generate, under what conditions.  It decides
     what they are called, and what they contain.

       The basic structure of Libero's code generator is this:

        + Read the schema line by line; ignore comment lines.

        + If the line contains a schema command, execute the command.

        + If the  line does  not contain a command, write it to the current output
          file, if any.  Otherwise discard it.

       This is a 'hello world' program:

       :echo "Hello, World!"

       Let's look at an example of some realistic schema code:

       !
       !  Example Libero schema code
       !
















     Printed 15 February, 1996                                               Page 73





     Libero User's Guide                                                 Version 2.11
       :if not exist $source.c
       :echo "lr I: creating skeleton program $source.c..."
       :output $source.c
       /*===========================================================================*
        *                                                                           *
        *  $source.c   description...                                               *
        *                                                                           *
        *  Written:    $date       $author                                          *
        *  Revised:    $date                                                        *
        *                                                                           *
        *  Skeleton generated by LIBERO $version on $fulldate, $time.               *

       *===========================================================================*/

       #include "$dialog.d"                    /*  Include dialog data
       */

       /*************************   INITIALISE THE PROGRAM
       ************************/

       MODULE $"initialise_the_program" (void)
       {
           $"the_next_event" = $"ok_event";
       }


       :close
       :endif

       How does this schema work?

        + Any lines  that starts  with '!'  is as  a comment.   The code generator
          discards all such lines.

        + Libero looks  for names  starting with  '$', and  replaces these  by the
          value of  that variable.   Libero  supplies a  set of standard variables
          like '$date' and '$source'.  You can also define your own variables.

        + When a  line starts  with ':xxxx',  this is  read by  Libero as a schema
          command.   Typical commands  are ':if', ':echo'. ':open'.  Command lines
          can include variables.

        + Any other line is copied to the currently-open output.

       When Libero  replaces variables,  it keeps  the text as aligned as possible by
     treating white-space  (blanks or  tabs) as  elastic.  For instance, here is some
     'C' code  before and  after replacement.  Notice how the right-hand comment does
     not move:

       /*  Source generated on $date   - Libero $version              */
       /*  Source generated on 96/03/12 - Libero 2.11                 */

       A variable name ends with the first non-name character (A-Z, a-z, 0-9, _).  To
     mark the  end of  a variable name that is 'pasted' to some text, use a '\'.  For
     instance, this is a line before and after inserting the $source variable:

           :output $source\d.d
       ==> :output myprogd.d

     Printed 15 February, 1996                                               Page 74





     Libero User's Guide                                                 Version 2.11
       If you  capitalise (at  least) the  first letter  of a  variable name,  Libero
     inserts the whole value in uppercase.  For example:

           :output $Source\d.d
       ==> :output MYPROGd.d

       To output  a name  that matches  the current  -style setting,  do this (e.g. -
     style=caps):

           $"the_next_event" = $"ok_event";
       ==> TheNextEvent = OkEvent;

       To output a '$', use two '$'s together:

           $"the_next_event" = $$$"ok_event";
       ==> TheNextEvent = $OkEvent;


     Read-Only Variables

       Libero supplies these read-only variables:


       Variable:         Effect:

       $author           The value of the -author option.

       $date             The current  date in  a shortened form: 'yy/mm/dd'.  Libero
                         always uses this date format for short dates.

       $time             The current time in a shortened form: 'hh:mm'.

       $fulldate         The current date in a long form: 'dd Mmm, yyyy'.  The month
                         is abbreviated to 3 letters.

       $fulltime         The current time including seconds: 'hh:mm:ss'.

       $out_count        The number  of lines  output so  far, including the current
                         line.  This starts at 1.

       $dialog           The name  of  the  dialog  file  being  processed,  without
                         extension.

       $schema           The name  of the  schema being  read.  This is the value of
                         the -schema option.

       $source           The  name  of  the  source  file  for  dialog,  without  an
                         extension.   This name  is derived as follows: normally, it
                         is the  same as  the dialog  file  name.    If  -plusd  was
                         specified, it  is formed  by adding  'D' to the dialog file
                         name.   If -source=xxx  was used, this explicitly tells the
                         source name to use.

       $style            The value of the -style option.

       $defaults         The number  of the  defaults state,  or zero  if  none  was
                         specified.


     Printed 15 February, 1996                                               Page 75





     Libero User's Guide                                                 Version 2.11
       $events           The number  of events  in the  dialog.   This  is  used  to
                         dimension various tables.

       $maxaction        The maximum  action number  (largest vector).  This is used
                         to dimension various tables.

       $modules          The number  of modules  in the  dialog.   This is  used  to
                         dimension various tables.

       $states           The number  of states  in the  dialog.   This  is  used  to
                         dimension various tables.

       $vectors          The number of action vectors in the dialog.

       $version          The current  Libero version number as 4 characters: 'n.nn';
                         e.g. '2.11'.


       Additionally, $comma, $name, $number, $offset, $tally, $row, and $overflow are
     available within a :do block.  These variables are explained later.

       You cannot  define your  own variables  with the  name of  a  standard  Libero
     variable.


     Schema Commands

       You can use the following commands in a schema:


       Command:          Effect:

       :output file      Sends output to filename.  Any existing data in the file is
                         lost.

       :extend filename  Appends output to filename.

       :close            Closes an  output file  opened by  a  previous  :output  or
                         :extend.  This command is never required, since Libero does
                         an implicit  :close before  any :output  or :extend, and at
                         the end  of the  schema.  If you use :close when no file is
                         open you'll get a warning message.

       :copy fromfile tofile                 Copies one file to another.  The tofile
                         is silently overwritten if it already existed.

       :rename fromfile tofile               Renames  one  file  to  another.    The
                         tofile may not already exist.

       :delete filename  Deletes filename  and silently  ignores the  command if the
                         file does not exist.








     Printed 15 February, 1996                                               Page 76





     Libero User's Guide                                                 Version 2.11
       :include [optional] filename [from [to]]        
                         Includes filename  in the  generated output  code.   If you
                         specify  from,   Libero  searches   the  file  for  a  line
                         containing this  text by  itself, and  starts copying  from
                         that point on.  If you specify to, Libero ends copying when
                         it finds  a line  containing just  this text.   You can put
                         quotes around from and to if these contain embedded spaces.
                         If  you  use  the  optional  keyword,  Libero  ignores  the
                         :include command  if it can't find the specified file.  The
                         included file can be anywhere on the -path setting.

       :echo text        Echoes text  to the standard output, followed by a newline.
                         If the  text is  enclosed in quotes, leading spaces are not
                         discarded.

       :declare [int | string] [$]name [=expression]   
                         Defines a variable for later use in the schema.  Except for
                         those that Libero supplies as standard, you have to declare
                         any variables  that you  want to  use.  You can specify the
                         variable name with or without a '$' in the name.

                         Variables are either integers, strings, or variants (either
                         type depending  on mood).    You  cannot  assign  a  string
                         expression to  an integer.    Otherwise  Libero  is  pretty
                         relaxed about how you mix variable types.

                         The expression  (see page  79) provides  a default  initial
                         value for  the variable.   If you do not provide an initial
                         value, strings  are empty  and numbers  are zero.   You can
                         override any  initial  value  using  an  '-option'  on  the
                         command-line or in the dialog.  Use: '-opt:var="string"' or
                         '-opt:var=expression'.

                         The name  of  a  variable  cannot  be  literally  'int'  or
                         'string'.     Variable  names   are  case-independent  (i.e
                         ':declare $drink'  and ':declare  $DRINK' refer to the same
                         variable).

                         If you  declare an  existing variable,  you'll get an error
                         message.

       :set [$]name = expression             
                         Assigns a new value to the variable specified.  You can use
                         a '$'  before the variable name if you want to.  You cannot
                         set the read-only variables listed on page 75.

       :push [$]variable [=expression]       
                         Create a  new instance  of the  variable.   If you  give an
                         expression the  new variable gets this value.  The variable
                         must then  be a  read-write variable.  You can push a read-
                         only variable  but not  specify an  expression.   This  may
                         sound pointless,  but can be useful: you can set some read-
                         only variables  using the  :option command,  e.g. :option -
                         style=xxxx.

       :pop [$]variable  Removes the last instance of a variable.  Use with :push to
                         change a  variable within  a block,  then reset  it to  its
                         previous value.

     Printed 15 February, 1996                                               Page 77





     Libero User's Guide                                                 Version 2.11
       :do condition     Starts a  code block that is output repeatedly depending on
                         condition.   Libero defines  a standard  set of  conditions
                         like 'event'  (see page  82).  You can also define your own
                         conditions using  'while'.    The  do  block  ends  with  a
                         matching ':enddo'.

       :do while logical-condition           
                         Repeats the code block while the logical_condition is true.
                         See page 80 for details.

       :enddo [condition]                    Ends the  closest previous  :do  block.
                         If you  specify condition,  the :do  and :enddo  conditions
                         must match;  this makes  your schemas  more robust  against
                         errors, but is not required.

       :if logical-condition                 Starts a  code block  that is output if
                         logical_condition is  true.   The  if  block  ends  with  a
                         matching ':endif'.

       :else             Outputs the  following block  of code  if the  previous :if
                         condition was false.

       :endif [all]      Ends the closest previous :if block.  If you specify 'all',
                         all open :if blocks are closed.

       :exit [level]     Aborts code  generation.   Use levels  0 for  okay,  1  for
                         errors.

       :option -name[=value]                 Enforces a Libero option (see page 38).
                         For example: ':option -style=cobol'.

       :internal module  Tells the  code-generator that  module is  required by  the
                         generated dialog  code, but  not by  the dialog.  A typical
                         case  is   'initialise_the_program'.     This  lets  Libero
                         correctly indicate unused modules in the source code.

       :substr from [size]                   Specifies  a  substring  for  the  next
                         $name or  $row insertion.  The from must be from 1 upwards.
                         If size  is not  specified, the remainder of the variable's
                         value is used.


       Notes:

        + All commands  can contain  variables anywhere  in the  line  that  makes
          sense.

        + You can  use '#'  to start  a comment  in a  command  line.    Any  text
          following the '#' is ignored.  When a '#' is inside a string, or escaped
          by '\',  it is  treated as  the '#'  character, not  a comment.  You can
          change the comment character by setting $comment_ind.

        + a line containing just ':' by itself is ignored.  This lets you separate
          blocks of  commands without  outputting extra  blank lines  in the code.
          For instance:




     Printed 15 February, 1996                                               Page 78





     Libero User's Guide                                                 Version 2.11
          :if $index > 0
          :set $counter = $counter + 1
          :endif
          :
          :echo "\ncounter is $counter\n"

        + In a :set or :declare you can give the variable name with or without the
          $.   Your preference  will depend  on the other languages you use.  When
          I've used  Perl a  while, I  want to  stick a '$' everywhere.  When I've
          programmed in  a UNIX  shell, I want the $ only on the right.  When I've
          been working  in any other language I can't understand what all the fuss
          is about,  I just  want something  that works  like I expect it to.  So,
          since the meaning is unambiguous, Libero accepts both.

        + One or  more spaces can come between the ':' and the command name.  This
          is often a nice way to indent commands to show structure.


     Syntax Of Expressions

       The :set  and :declare  commands assign  the  value  of  an  expression  to  a
     variable.  A couple of examples:

       :declare $count = 0
       ...
       :set $count = $count + 1

       Libero handles the expression depending on the type of the variable:

        + If it is an int, it looks for an arithmetic expression.

        + If it  is a  string, it treats the whole expression as a string.  Quotes
          are optional; you should use these if the string contains spaces.

        + If the variable is a variant, Libero tries to evaluate the expression as
          an arithmetic  expression.    If  this  works,  the  variable  gets  the
          resulting number as its new value.  If this fails, the variable gets the
          string as its value.  To be certain to assign a string, use quotes.

       An arithmetic  expression can  include '+',  '-', '*',  '/', parentheses.  All
     number are four-byte signed long values, i.e. fall into the range +2,147,483,647
     to -2,147,483,648.

       Things pretty  much work  as you  would expect,  I hope.  In practice I always
     declare variables as int or string and put explicit quotes around strings.














     Printed 15 February, 1996                                               Page 79





     Libero User's Guide                                                 Version 2.11
     Syntax Of Logical Conditions

       The :if  and :do  while commands  output some  code depending  on  a  logical-
     condition.  Some examples:

       :if $debug
       :  echo "version is $version"
       :endif
       :do while $counter > 0
          ...
       :enddo


       A logical condition has two possible forms:

       :if [not] [test] expr1 [logical_operator expr2]

       :if [not] [if-condition]

       In the  first case  you make  your own test by comparing two expressions.  The
     'test' keyword  is optional and I normally don't use it.  The expressions can be
     numeric or  string; if  either is  a string, Libero treats both as strings.  The
     logical operator can be one of:


       Logical operator: True if:

       =, ==             expr1 is equal to expr2.

       <>, !=            expr1 is not equal to expr2.

       <                 expr1 is less than expr2.

       <=                expr1 is less than or equal to expr2.

       >                 expr1 is greater than expr2.

       >=                expr1 is greater than or equal to expr2.


       In the  second case,  the if-condition  is one of a set of standard tests that
     Libero provides:


       If-condition:     True if:

       exist filename    The file filename exists in the current directory.

       animate           You used the -animation option.

       check             You used the -check option.

       caps              You used the -style=caps option.

       cobol             You used the -style=cobol option.

       headline          You used the -style=headline option.

       normal            You used the -style=normal option.
     Printed 15 February, 1996                                               Page 80





     Libero User's Guide                                                 Version 2.11
       plain             You used the -style=plain option.

       title             You used the -style=title option.

       defaults          The dialog defines a Defaults state.

       state name        Name is a state in the dialog.

       event name        Name is an event in the dialog.

       module name       Name is a module in the dialog.



     Control Variables

       Libero supplies  these control  variables.   A control  variable affects  some
     aspects of  code generation;  you set the control variable to tell Libero how to
     handle something  specific for  the language  you want  to  generate.    Control
     variables are usually 'write-only'.  You don't normally refer to these variables
     in the  code, though  you can  if you want to.  To change a control variable you
     use the ':set' command:


       Variable:         Controls this:

       $array_base       Specifies the  base value  for tables.   You  use this when
                         building an array of values.  By default this is 0; in some
                         languages it is more useful to start at 1.  The $array_base
                         affects the value of $number in a :do block.

       $comma_before     This value  is used  as $comma  when the current item being
                         output is not the last.  Default is ",".

       $comma_last       This value  is used  as $comma  when the current item being
                         output is the last. Default is empty.

       $comment_ind      Comment indicator in schema command lines.  Default is '#'.

       $module_line      Libero looks  for single  lines that  look like  this  when
                         creating new module stubs.  By default: "MODULE %s (void)".
                         The '%s' symbol represents the module name.

       $number_fmt       This value is used to format the $number value; numbers are
                         always signed  long ints.  It must be a valid printf format
                         string.  Default is "%ld".

       $row_first        This value  is used  to format  the first numeric item in a
                         $row value.   It  must be  a valid  printf  format  string.
                         Default is "%ld".

       $row_after        This value  is used to format numeric items in a $row value
                         after the  first one.   It  must be  a valid  printf format
                         string.  Default is ",%ld".





     Printed 15 February, 1996                                               Page 81





     Libero User's Guide                                                 Version 2.11
       $row_clean        Tells Libero  to clean-up  overflow rows.  You get overflow
                         rows when  you generate  a table  that is  wider  than  the
                         $row_width.   When $row_clean is 1, Libero removes any non-
                         numeric data  from the  start of  overflow rows.   When  0,
                         Libero leaves overflow rows as they are.  Default is 0.

       $row_null         This value is used in $row's when there is no event defined
                         in a  certain state.   This is by default 0, but can be set
                         to any numeric value by the schema.

       $row_width        Maximum space,  in characters,  for  a  $row  item  in  the
                         generated source.   Default  is the  compile-time  constant
                         LR_ROW_WIDTH, defined  as 60.   Rows  longer than  this are
                         chopped into 'overflow' pieces.

       $run_away         If a  :do loop  does more  than this  number of iterations,
                         Libero halts  it with  an error  message.   Default is  the
                         compile-time constant  LR_RUNAWAY_LIMIT, defined  as  1000.
                         This lets  you generate  at least  a table with the maximum
                         number of  states, events, or modules (up to 1000 depending
                         on the schema).

       $stub_before      Used to  generate new module stubs: if this string value is
                         not empty, it is output before each module stub header.  By
                         default it is "" (empty).

       $stub_between     Used to  generate new  module stubs:  this string  value is
                         repeated to build-up a stub header.  Default is "*".

       $stub_first       Used to  generate new  module stubs:  this string  value is
                         output at the start of a stub header line.  Default is "/".

       $stub_last        Used to  generate new  module stubs:  this string  value is
                         output at the end of a stub header line.  Default is "/".

       $stub_width       Used to generate new module stubs: defines the width of the
                         stub  line.     Default   is  the   compile-time   constant
                         LR_HEADER_WIDTH, defined as 79.


       To see  the value  that a  control variable had for code-generation, use the -
     trace option  when you generate code.  The '.lst' file produced shows the symbol
     table, including all control variables, as code generation ended.


     Standard :do Conditions

       Libero defines this set of :do conditions:


       Condition:        Outputs code:

       :do action        For each  state defined in the dialog; generates the action
                         for each event in each state.

       :do event         For each event defined in the dialog.

       :do module        For each dialog module defined in the dialog.

     Printed 15 February, 1996                                               Page 82





     Libero User's Guide                                                 Version 2.11
       :do nextst        For each  state defined  in the dialog; generates the next-
                         state for each event in each state.

       :do overflow      Until the  current table item is completely output.  Use in
                         conjunction with the $overflow variable.

       :do state         For each state defined in the dialog.

       :do stubs [filename]...               For each  dialog module  defined in the
                         dialog,  but  not  yet  present  in  the  source  file  (or
                         filename(s) if specified).

       :do vector        For each  action vector  required by the dialog.  An action
                         vector is  the list of modules to execute for an event in a
                         state.   Libero collects  these and builds a list of unique
                         action vectors.


       These :do loops cannot be nested (i.e. twice the same condition).


     Extra Variables In a :do Loop

       Within a :do loop, various extra variables are available.  These are explained
     below.


       :do while condition

       Repeats while  condition is  true.   The condition  is a  logical condition as
     described above.  The loop is executed 0..n times.


       Extra variable:   Has this value:

       $number           Loop iteration 0..n-1, added to $array_base.



       :do event

       Builds a list of events.  Outputs the block for each event in the dialog.


       Extra variable:   Has this value:

       $name             Event name,  with '_event'  appended to  end, and formatted
                         using the current -style setting.

       $number           Event number 0..n-1, added to $array_base

       $comma            $comma_before until the last iteration; then $comma_last.



       :do state



     Printed 15 February, 1996                                               Page 83





     Libero User's Guide                                                 Version 2.11
       Builds a list of states.  Outputs the block for each state in the dialog.


       Extra variable:   Has this value:

       $name             State name, formatted using the current -style setting.

       $number           State number 0..n-1, added to $array_base.

       $comma            $comma_before until the last iteration; then $comma_last.



       :do module

       Builds list of modules.  Outputs the block for each module in the dialog.


       Extra variable:   Has this value:

       $name             Module name, formatted using the current -style setting.

       $number           Module number 0..n-1, added to $array_base.

       $comma            $comma_before until the last iteration; then $comma_last.



       :do action

       Builds table  containing one  row per  state, with  one item  per row for each
     event transition.   Each  item is  the number  of an  action  vector.    Invalid
     state/event transitions are filled by the value of $row_null.


       Extra variable:   Has this value:

       $row              Value  of   row,   formatted   according   to   $row_first,
                         $row_after, and $row_null.

       $number           State number 0..n-1, added to $array_base.

       $comma            $comma_before until the last iteration; then $comma_last.

       $offset           Offset of  start of current row, added to $array_base.  The
                         offset is counted up by 1 for each item in a row.

       $tally            Number of items in $row.



       :do nextst







     Printed 15 February, 1996                                               Page 84





     Libero User's Guide                                                 Version 2.11
       Builds table  containing one  row per  state, with  one item  per row for each
     event transition.   Each  item is  the  number  of  the  next  state.    Invalid
     state/event transitions are marked by the value of $row_null.


       Extra variable:   Has this value:

       $row              Value  of   row,   formatted   according   to   $row_first,
                         $row_after, and $row_null.

       $number           State number 0..n-1, added to $array_base.

       $comma            $comma_before until the last iteration; then $comma_last.

       $offset           Offset of  start of  current row, added to array_base.  The
                         offset is counted up by 1 for each item in a row.

       $tally            Number of items in $row.



       :do vector

       Builds table  of action  vectors.   An action  vector is  a  list  of  modules
     executed in  series  for  a  state/event  transition.    Duplicate  vectors  are
     collapsed.


       Extra variable:   Has this value:

       $row              Action   vector,   formatted   according   to   $row_first,
                         $row_after, and $row_null.

       $number           Vector number 0..n-1, added to $array_base.

       $comma            $comma_before until the last iteration; then $comma_last.

       $offset           Offset of  start of current row, added to $array_base.  The
                         offset is counted up by 1 for each item in a row, including
                         an assumed terminator value (0xFFFF).

       $tally            The number  of items  in each row, including one terminator
                         value (ie. nbr items in $row + 1).



       :do overflow

       Used to build source code that has to be output over several lines.  The block
     is output until the overflow row is empty.


       Extra variable:   Has this value:

       $row              Overflow row,  ie. part  of main $row that did not fit onto
                         first line.

       $number           Iteration number 0..n-1, added to $array_base.

     Printed 15 February, 1996                                               Page 85





     Libero User's Guide                                                 Version 2.11
       $comma            $comma_before until the last iteration; then $comma_last.

       $tally            Number of items in $row.



       :do stubs [filename]...

       Builds a  set of  module stubs  at the end of the filename.  If no filename is
     specified, assumes  you mean  the $source  file.   You can  specify  a  list  of
     filenames; then Libero will scan each file in the list for existing modules, and
     build stubs for any undefined modules at the end of the first filename.  This is
     useful if you define standard modules in generated code (e.g. an include file).

       If you use the -nostubs option, Libero ignores the :stubs command.  If you use
     the -noidle  option, Libero  does not  check the  source for  idle (ie.  unused)
     modules.


     General Rules for Code Generation

        + A string may be delimited by a single or double quote character.

        + Inside a  string, the  sequence '\n'  is treated as a newline character.
          The sequence  '\t' is  treated as  a tab character.  Any other character
          prefixed by '\' is treated as itself.

        + Libero issues  a warning message if a non-blank line has to be discarded
          because there is no output open.

        + If you  have trouble  generating what  you want,  use the -trace option:
          this shows each schema line, before and after any variable expansion.


     Generating Module Stubs

       Take a hypothetical language where a module stub looks like this:


       //###################  SOME FUNCTION   ##################//

       MODULE some_function () {

       }

       To generate stubs like this we would add these commands to the schema file:

       :internal initialise_the_program
       :internal get_external_event
       :set $module_line  = "MODULE %s () {"
       :set $stub_first   = "//"
       :set $stub_between = "#"







     Printed 15 February, 1996                                               Page 86





     Libero User's Guide                                                 Version 2.11
       :set $stub_last    = "//"
       :do stubs

       MODULE $name () {

       }

       :enddo stubs

       This is how it works:

        + The :internal  commands tell  Libero to ignore these two modules when it
          looks through the source file.  Without these two commands, Libero would
          print a  message saying that the source file contained modules no longer
          used in the dialog.  We tell it that some modules are used internally by
          the generated code.

        + The $module_line  tells Libero  what to  look for when it is running its
          idle module check.  This must always match the header of the stub below.

        + Libero looks  at each file specified in the ':do stubs' line.  If you do
          not specify any files, Libero looks just at the source file.

        + When it  builds a  new module  stub, Libero  outputs a  line  containing
          $stub_before before each stub.  Usually this is a blank line.

        + Libero uses  $stub_first, $stub_between,  and $stub_last to build-up the
          header line.

        + The text between the :do and :enddo is repeated, with a header, for each
          missing module.

       The ':do  stubs' command  can come at any point in the schema.  It does not do
     any output to the current output file.  However, in many cases it is a good idea
     to list  generated files  in the  ':do stubs' line, which means that this should
     come at the end of the schema, when everything has been generated.


     Generating COBOL Code

       Libero has some built-in knowledge about the COBOL source format that makes it
     a little  easier to  generate COBOL  code.   The COBOL format is 80-column text,
     where the  first six  columns are  a numeric  sequence number.   The  last eight
     columns are a comment.

        + If the  schema looks like COBOL, Libero generates COBOL as a result.  It
          ignores anything in the first 6 or last 8 columns of the schema.

        + When the  -style option  is -style=cobol,  Libero checks that data names
          are not  longer than  30 characters,  which is the standard ANSI maximum
          for data names.

        + You can  set $cob_comment to control what Libero places in columns 73-80
          of the output source.  Normally this is the date, 'YY/MM/DD'.





     Printed 15 February, 1996                                               Page 87





     Libero User's Guide                                                 Version 2.11
     The State Machine Algorithm


       This is  the dialog  manager logic  as pseudo-code.   If  you need  to write a
     schema for a new language, this section should be your main specifications.

       I've simplified  this code  a little; in practice some of it is generated only
     under certain conditions, i.e. if there is a Defaults state.  Also, I've ignored
     the animation code which is in most schemas:

           LR_state = 0
           call initialise_the_program
           while the_next_event <> terminate_event
               LR_event = the_next_event
               if LR_event >= $events OR LR_event < 0
                   abort: Bad event LR_event in state LR_state
               endif

               LR_index  = LR_action [LR_state, LR_event]
               LR_savest = LR_state
               if LR_index = 0
                   LR_state = LR_defaults_state
                   LR_index = LR_action [LR_state, LR_event]
               endif

               if LR_index = 0
                   abort: Bad event LR_event in state LR_state
               endif

               the_next_event       = LR_NULL_EVENT
               the_exception_event  = LR_NULL_EVENT
               exception_raised     = FALSE

               for ever
                   if LR_vector [LR_index] = LR_STOP_ACTION
                   OR exception_raised
                       break 'for' loop
                   endif
                   call LR_module [LR_vector [LR_index]]
                   increment LR_index
               endfor

               if exception_raised
                   if the_exception_event <> LR_NULL_EVENT
                       LR_event = the_exception_event
                   the_next_event = LR_event
               else
                   LR_state = LR_nextst [LR_state][LR_event]
               endif










     Printed 15 February, 1996                                               Page 88





     Libero User's Guide                                                 Version 2.11
               if LR_state = LR_defaults_state
                   LR_state = LR_savest
               endif
               if the_next_event = LR_NULL_EVENT
                   abort: No event after LR_event in state LR_state
               endif
           endwhile

           return feedback


     Compiled-In Limitations


       A number  of more-or-less  arbitrary limits  are defined  in the  header  file
     LRPRIV.H.   If you  need to,  you can  increase these, then recompile all Libero
     programs:


       Definition:       Purpose:

       LR_SYMBOLMAX      The size  of Libero's  symbol table.  This table is used to
                         hold all state, event, and module names.  Defined as 32000;
                         maximum value is 32767.

       LR_STATEMAX       The maximum  number of  states in  the dialog.   Defined as
                         1000.   Maximum value  is 16383, assuming schema can handle
                         it.

       LR_EVENTMAX       The maximum  number of  different  events  in  the  dialog.
                         Defined as  1000.   Maximum value is 16383, assuming schema
                         can handle it.

       LR_MODULEMAX      The maximum  number of  different modules  in  the  dialog.
                         Defined as  1000.   Maximum value is 16383, assuming schema
                         can handle it.

       LR_VECTORMAX      The maximum  number of  different vectors  in  the  dialog.
                         Defined  as  1000.    The  value  of  LR_VECTORMAX  *  2  *
                         $maxaction should not be larger than 32k.

       LR_FILENAMEMAX    The maximum  size of  a filename  with extension,  but  not
                         path.  Defined as 128 characters.

       LR_HEADER_WIDTH   The default  width of a header line.  For various reasons I
                         like this  to be  79.   You can  change this in a schema by
                         setting $stub_width.

       LR_RUNAWAY_LIMIT  The number  of times  you can  go through a :do loop before
                         Libero says  thinks you  are in  trouble.  Defined as 1000.
                         Maximum value is 32767.

       LR_ROW_WIDTH      The default  width of  one line  of a  $row.   For  various
                         reasons I  like this  to be  60.   You can change this in a
                         schema by setting $row_width.


       The header  file prelude.h  also defines  a constant  LINE_MAX, with the value
     255, which  is used  to allocate  buffers for  input  and  full  filenames  (ie.
     Printed 15 February, 1996                                               Page 89





     Libero User's Guide                                                 Version 2.11
     including path).   You should not write dialogs wider than a normal page (ie. 80
     columns).

       Libero allocates  memory dynamically  to store  its dialog  definition, so the
     maximum size  of a dialog actually depends on available memory.  You should only
     change the  constants in  LRPRIV.H if  you get  a message that specifically says
     that you have reached such a limit.

       The code  that the  standard C  schema generates  assumes that  events can  be
     stored in  a signed  16-bit word; while state, module, and action numbers can be
     stored in  an unsigned  16-bit word.   A  more compact  version could be made by
     using 8-bit values.

       If you  change Libero,  or suspect  bugs, compile  with   DEBUG defined.  This
     switches on  the assertions that are sprinkled through the code.  The executable
     will be  a  little  larger,  but  if  a  bug  corrupts  Libero's  internal  data
     structures, you  will (usually)  get a  nice message instead of an unpredictable
     crash.


     Supported Platforms


       I have compiled and used Libero without problems on these systems:

        + Borland Turbo  C++ 1.0:  compile switches:  -c -f  -O -Z  -w  -C  -ml  -
          Id:\tc\include\.

        + Microsoft  C/C++   8.0:  compile  switches:  /c  /Ox  /W4  /Za  /Gs  /AL
          /Id:\msvc\lib.

        + Linux using gcc: compile switches: -pedantic -O2 -Wall -c.

        + Digital VAX/VMS, Vax C: default compiler options.

        + Digital Alpha/OpenVMS, Dec C: default compiler options.

        + HP/UX: compile switches: -Aa.

        + SunOS using SunC: compile switches: -O -vc -Xa.

        + AIX 3.2.5: default compiler switches.

       I have reports of success on these systems (and no reports of failures):

        + IRIX 5.2: default compiler switches.

        + Solaris using gcc.


     Release History


       14 July, 1993     V1.60 -  first complete  version released  into the  public
                         domain.

       26 August, 1993   V1.70 -  minor improvements  and corrections to product and
                         documentation.

     Printed 15 February, 1996                                               Page 90





     Libero User's Guide                                                 Version 2.11
       10 March, 1995    V2.0 -  added support  for 8086 assembler and UNIX scripts.
                         First release onto the Net.

       21 October, 1995  V2.10 -  big changes  to code  generation, support for many
                         more  languages;   new  documentation;  Windows  front-end.
                         Second release onto the Net.

       11 February 1996  V2.11 - maintenance release.


     Compatibility With Earlier Versions


       All dialogs  are backwards  compatible with  the first versions an on.  If you
     wrote your  own schemas, you will need to make changes.  The best way to do this
     is to  start again  with the  version 2.10 schemas.  If you are stuck, drop me a
     line.










































     Printed 15 February, 1996                                               Page 91





     Libero User's Guide                                                 Version 2.11

                                         Examples



       To install  the examples, unzip the examples.zip file.  This zip file contains
     a directory tree, so use the correct unzip option (usually '-d') to recreate the
     directory tree.   Each  subdirectory holds  a package of files, and a readme.txt
     file that explains the package.


     Libero 'install' Script for UNIX


       The source files for this package are in examples/install.

       This is  a nice  example of  a UNIX script that is complex enough to warrant a
     dialog.  The script shows a small menu, and does various things depending on the
     choice:


        Libero installation script                       Version 2.10
        -------------------------------------------------------------
        This script installs or de-installs Libero on your Unix system.
        If you are going to install into a system binary directory you
        will need write-access to the system directory.  You can also
        run Libero from the current directory.

        UNIX system="aix", compiler="cc", options="-O2"
        -------------------------------------------------------------

        Choose an action:
          (b)uild Libero and optionally install
          (d)e-install Libero
          (c)lean-up current directory
          (q)uit

        Choice:


       -schema=lrschema.ksh

       After-Init:
           (--) Ok                                 -> Have-Package
                 + What-System-Are-We-On
                 + What-Package-Do-We-Have

       Have-Package:
           (--) Source                             -> Before-Action
                 + Get-Source-Install-Action
           (--) Binary                             -> Before-Action
                 + Get-Binary-Install-Action







     Printed 15 February, 1996                                               Page 92





     Libero User's Guide                                                 Version 2.11
       Before-Action:
           (--) Build                              -> Have-Install-Directory
                 + Check-All-Files-Exist
                 + Compile-All-Subroutines
                 + Link-Main-Programs
                 + Get-Directory-Name
           (--) Install                            -> Have-Install-Directory
                 + Get-Directory-Name
           (--) Delete                             -> Have-Delete-Directory
                 + Get-Directory-Name
           (--) Cleanup                            -> Have-Package
                 + Clean-Up-Directory
                 + What-Package-Do-We-Have
           (--) Error                              -> Have-Package
                 + What-Package-Do-We-Have

       Have-Install-Directory:
           (--) Ok                                 -> Have-Package
                 + Check-Directory-Writable
                 + Install-Product-Files
                 + What-Package-Do-We-Have
           (--) Current                            -> Have-Package
                 + What-Package-Do-We-Have
           (--) Error                              -> Have-Install-Directory
                 + Get-Directory-Name

       Have-Delete-Directory:
           (--) Ok                                 -> Have-Package
                 + Check-Directory-Writable
                 + Delete-Product-Files
                 + What-Package-Do-We-Have
           (--) Error                              -> Have-Delete-Directory
                 + Get-Directory-Name

       Defaults:
           (--) Error                              ->
                 + Return-Error-Feedback
                 + Terminate-The-Program
           (--) Quit                               ->
                 + Terminate-The-Program

       The script  reads install.cat  to tell it which files to handle.  For example,
     this is the module Compile-All-Subroutines:

       #########################   COMPILE ALL SUBROUTINES
       #########################

       function compile_all_subroutines
       {
           test -f *.o && rm *.o
           for FILE in `awk '/^&.*@c/ {print $2}' $CATALOG`; do
               echo "Compiling $FILE..."
               $CCNAME -c $CCOPTS $FILE
           done
       }




     Printed 15 February, 1996                                               Page 93





     Libero User's Guide                                                 Version 2.11
     COBOL Picture Parser


       The source files for this package are in examples/picture.

       One of  my still-unfinished  projects is  a portable  COBOL compiler.   I  was
     writing a blindingly fast parser when I got sidetracked with Libero at the start
     of 1995.   Anyhow, I found that lex was not really good at some of the syntactic
     warble that  COBOL allows,  so I  finally wrote  a specific analyser.  The COBOL
     picture is one of the hairier aspects of the language.  I wrote a function, with
     a dialog, that was robust and fast.

       The function  takes a  picture string  and returns its size, type, and various
     other bits of info.  If the picture is not correct it returns an error message.

       It took  just over  a week,  part-time, to  write and test this program, so it
     can't have  been too  hard.   I wrote  a test program that shoves a load of test
     pictures through  the function  and prints  the results.  If you are running MS-
     DOS, you can try the testpict program.  It outputs stuff like this:

       9(3)                        :                      size=3    numeric
       9(3)V                       :                      size=3    numeric
       V9(3)                       :                      size=3    numeric  3 decs
       9(3)V9(3)9(3)9(3)9(3)9(3)   :                      size=18   numeric  15 decs

       9(01                        :                      size=0    undefined
          ^
       ')' missing after repeat specifier.

       ZZZZZ.ZZ9                   : ZZZZZ.....ZZ         size=12   undefined 2 decs
               ^
       decimals cannot be partly zero-suppressed

       9999,(2).(2)                : 9999,,..             size=8    undefined
                ^
       (...) must follow one of: B X Z 0 9 * / + - , $

       This package  might be  useful if  you need to analyse COBOL code.  There is a
     lot of it around (150 Gigalines at last count) so is not so far-fetched.

       There are  also some  nice functions  in the package; for instance some pretty
     fast file  i/o code, which is non-portable enough to squeeze the best out of the
     C libraries on a number of systems.


     TCP/IP Server


       The source files for this package are in examples/tcpip.

       One of  the first  programs I  wrote with  Libero was a TCP/IP server program.
     This was  eventually part  of a  commercial project, so I can't include the full
     code.   However, I  include a  simple  TCP/IP  client,  a  socket  library,  and
     documentation for the library.

       This space  is hereby  reserved for  the first  person who writes a Web server
     using Libero.


     Printed 15 February, 1996                                               Page 94





     Libero User's Guide                                                 Version 2.11
     Expression Parser


       The source files for this package are in examples/expr.

       The expression  parser that  I use  as an example on page 23 is a real program
     that has  cropped-up in various places, including in Libero.  Often, when I make
     a new language schema for Libero, I rewrite the expression parser as a test.

       This package  has the  same program,  more  or  less,  written  in  C,  COBOL,
     assembler, and Visual Basic.


     Configuration Management System


       The source files for this package are in examples/config.

       On one  project I  worked on,  a friend  of mine  had to write a configuration
     management tool.   This  tool had  to keep  track of  each of  several  thousand
     programs in the system we were developing.

       A program has a life-cycle with various stages: in development, in testing, in
     integration, in production, etc.  The developers can work on a program only when
     it is in a certain stage.

       After some  thought, and  lunch, we  said this: 'Basically the life-cycle or a
     program is  a state-machine.   The states are the life-cycle stages.  The events
     are the actions that the developer wants to, or does, do on the program.'

       So we  designed the  life-cycle as  a Libero  dialog.   The  events  were  the
     'sensitive' actions  which either  depended on  the life-cycle  stage, or  which
     changed it.  For example, you could only compile a program if you had previously
     reserved it  for modification.   You  could only  do  this  if  it  was  in  the
     development stage.

       We wrote  this program as a UNIX shell script.  The script takes a program and
     action as argument, and returns an exit code that is 0 (okay) or 1 (not okay).

       Whenever a  developer wants  to do a sensitive action, the script fires-up the
     dialog.  It loads the last state for the program into LR_state, and converts the
     action into  an event.   The  dialog then runs one cycle, and either accepts the
     event and perhaps moves to a new state, or rejects the event.  We save the state
     for each  program in one file.  A small utility, gate, makes sure that this file
     is never accessed by more than one process at a time.

       I can't  supply the actual code, since this belongs to the client who paid for
     the work.  However, I provide a small example, control, that should give you the
     general idea.  Note that this dialog uses a hacked version of lrschema.ksh, with
     some extra code to generate a table of state names.

       This was  a nice  example of using a dialog to describe a real problem that is
     normally beyond the scope of software.  It is also the slowest-running program I
     have ever seen; one step through the dialog can take days!





     Printed 15 February, 1996                                               Page 95





     Libero User's Guide                                                 Version 2.11
     Multithreaded Agent For VAX/ACMS


       The source files for this package are in examples/acms.

       One of  the most  complex programs  I ever  wrote was a multithreaded terminal
     handler for a reservation system running on a Digital VAX/ACMS system.

       Digital VAX/ACMS  is a  transaction processor  somewhat akin to IBM's CICS, or
     Tuxedo for  UNIX.   In the ACMS model, people work on a front-end program called
     an 'agent'.   The  application programs  run on  the main  system, the 'server'.
     This is a good way to split the client-server responsibilities.

       In our  project we were unable to use any of the standard Digital agents (e.g.
     for DecForms), since we wanted to do our own screen handling.  The only recourse
     was to write our own agent.  This is easy enough when each user can run in their
     own interactive  session.   The agent program is then a normal program which can
     handle a terminal and talk to ACMS.

       The fun  starts when you need to connect several hundred users (in our case up
     to a  thousand).   VMS,  like  any  operating  system,  cannot  handle  so  many
     interactive sessions.  The only valid approach is to handle all the terminals in
     a single  process.  This means writing a multithreaded program where each thread
     manages one terminal.

       Perceived wisdom has it that this type of work is deadly difficult, and we had
     something of  a fight  to convince  the client that it would actually work.  The
     schedule was  tight, and there was no time (nor will, on my part) to develop the
     multithreaded code using conventional techniques.

       So, I  took the  standard Libero  C schema  and changed  it around  so that it
     generated multithreaded  code.   The multithreaded  schema actually  generates a
     tiny kernel  that handles the multithreading aspects.  The code you write has to
     be careful,  as always,  but is  only a  little more complex than normal single-
     threaded code.

       We beat  the schedule,  and made the client happy.  The multithreaded agent is
     about 3500  lines of  code, and  a hairy  program.   Still, it  has run  without
     trouble for several years, efficiently, and survived several meaty changes.




















     Printed 15 February, 1996                                               Page 96





     Libero User's Guide                                                 Version 2.11

                           Copyright and Licensing Information



       In this  appendix I  reprint the  GNU General  Public License  (the GPL) under
     which Libero is licensed.  Libero is copyrighted; however, you may distribute it
     under the terms of the GPL.


     GNU GENERAL PUBLIC LICENSE Version 2, June 1991


       Copyright (C)  1989, 1991  Free Software  Foundation,  Inc.    675  Mass  Ave,
     Cambridge, MA  02139, USA  Everyone is permitted to copy and distribute verbatim
     copies of this license document, but changing it is not allowed.


     Preamble

       The licenses for most software are designed to take away your freedom to share
     and change  it.   By contrast,  the GNU  General Public  License is  intended to
     guarantee your  freedom to  share and  change free  software--to make  sure  the
     software is free for all its users.  This General Public License applies to most
     of the  Free Software  Foundation's software  and to  any  other  program  whose
     authors commit  to using  it.   (Some other Free Software Foundation software is
     covered by  the GNU Library General Public License instead.) You can apply it to
     your programs, too.

       When we  speak of  free software, we are referring to freedom, not price.  Our
     General Public  Licenses are  designed to make sure that you have the freedom to
     distribute copies  of free  software (and  charge for this service if you wish),
     that you  receive source  code or can get it if you want it, that you can change
     the software or use pieces of it in new free programs; and that you know you can
     do these things.

       To protect  your rights,  we need  to make  restrictions that forbid anyone to
     deny you these rights or to ask you to surrender the rights.  These restrictions
     translate to  certain responsibilities  for you  if you distribute copies of the
     software, or if you modify it.

       For example, if you distribute copies of such a program, whether gratis or for
     a fee, you must give the recipients all the rights that you have.  You must make
     sure that they, too, receive or can get the source code.  And you must show them
     these terms so they know their rights.

       We protect  your rights  with two  steps: (1)  copyright the software, and (2)
     offer you  this license  which gives  you legal  permission to  copy, distribute
     and/or modify the software.

       Also, for  each author's  protection and  ours, we  want to  make certain that
     everyone understands  that there  is no warranty for this free software.  If the
     software is  modified by  someone else  and passed on, we want its recipients to
     know that what they have is not the original, so that any problems introduced by
     others will not reflect on the original authors' reputations.

       Finally, any  free program  is threatened  constantly by software patents.  We
     wish to avoid the danger that redistributors of a free program will individually
     obtain patent  licenses, in  effect making  the program proprietary.  To prevent
     Printed 15 February, 1996                                               Page 97





     Libero User's Guide                                                 Version 2.11
     this, we have made it clear that any patent must be licensed for everyone's free
     use or not licensed at all.

       The precise  terms and  conditions for  copying, distribution and modification
     follow.


     Terms And Conditions For Copying, Distribution, And Modification

       0. This License  applies to  any program  or other  work which  contains  a
          notice placed by the copyright holder saying it may be distributed under
          the terms  of this General Public License.  The "Program", below, refers
          to any  such program  or work,  and a  "work based on the Program" means
          either the  Program or  any derivative work under copyright law: that is
          to say,  a work  containing the  Program or  a  portion  of  it,  either
          verbatim or  with modifications and/or translated into another language.
          (Hereinafter, translation  is included  without limitation  in the  term
          "modification".) Each licensee is addressed as "you".

          Activities other  than copying,  distribution and  modification are  not
          covered by this License; they are outside its scope.  The act of running
          the Program  is not  restricted, and  the output  from  the  Program  is
          covered only  if its  contents constitute  a work  based on  the Program
          (independent of  having been made by running the Program).  Whether that
          is true depends on what the Program does.

       1. You may copy and distribute verbatim copies of the Program's source code
          as you  receive it,  in any  medium, provided that you conspicuously and
          appropriately publish  on each  copy an appropriate copyright notice and
          disclaimer of  warranty; keep  intact all the notices that refer to this
          License and  to  the  absence  of  any  warranty;  and  give  any  other
          recipients of the Program a copy of this License along with the Program.

          You may  charge a  fee for  the physical act of transferring a copy, and
          you may at your option offer warranty protection in exchange for a fee.

       2. You may  modify your copy or copies of the Program or any portion of it,
          thus forming  a work  based on the Program, and copy and distribute such
          modifications or  work under the terms of Section 1 above, provided that
          you also meet all of these conditions:

          a) You  must cause the modified files to carry prominent notices stating
          that you changed the files and the date of any change.

          b) You must cause any work that you distribute or publish, that in whole
          or in  part contains or is derived from the Program or any part thereof,
          to be  licensed as  a whole  at no charge to all third parties under the
          terms of this License.

          c) If  the modified  program normally  reads commands interactively when
          run, you must cause it, when started running for such interactive use in
          the most  ordinary way, to print or display an announcement including an
          appropriate copyright  notice and a notice that there is no warranty (or
          else,  saying   that  you   provide  a  warranty)  and  that  users  may
          redistribute the  program under  these conditions,  and telling the user
          how to  view a  copy of this License.  (Exception: if the Program itself
          is interactive  but does  not normally  print such an announcement, your
          work based on the Program is not required to print an announcement.)

     Printed 15 February, 1996                                               Page 98





     Libero User's Guide                                                 Version 2.11
          These  requirements  apply  to  the  modified  work  as  a  whole.    If
          identifiable sections of that work are not derived from the Program, and
          can  be   reasonably  considered   independent  and  separate  works  in
          themselves, then  this License,  and its  terms, do  not apply  to those
          sections when  you distribute  them as  separate works.   But  when  you
          distribute the same sections as part of a whole which is a work based on
          the Program,  the distribution of the whole must be on the terms of this
          License, whose  permissions for  other licensees  extend to  the  entire
          whole, and thus to each and every part regardless of who wrote it.

          Thus, it  is not  the intent  of this section to claim rights or contest
          your rights  to work  written entirely  by you; rather, the intent is to
          exercise  the  right  to  control  the  distribution  of  derivative  or
          collective works based on the Program.

          In addition,  mere aggregation  of another work not based on the Program
          with the  Program (or with a work based on the Program) on a volume of a
          storage or  distribution medium  does not bring the other work under the
          scope of this License.

       3. You may  copy and  distribute the  Program (or a work based on it, under
          Section 2) in object code or executable form under the terms of Sections
          1 and 2 above provided that you also do one of the following:

          a) Accompany  it with the complete corresponding machine-readable source
          code, which  must be  distributed under  the terms  of Sections  1 and 2
          above on a medium customarily used for software interchange; or,

          b) Accompany it with a written offer, valid for at least three years, to
          give any  third party, for a charge no more than your cost of physically
          performing source  distribution, a complete machine-readable copy of the
          corresponding source code, to be distributed under the terms of Sections
          1 and 2 above on a medium customarily used for software interchange; or,

          c) Accompany  it with  the information  you received  as to the offer to
          distribute corresponding source code.  (This alternative is allowed only
          for noncommercial  distribution and  only if you received the program in
          object code  or executable  form with  such an  offer,  in  accord  with
          Subsection b above.)

          The source  code for  a work  means the  preferred form  of the work for
          making modifications  to it.   For  an executable  work, complete source
          code means  all the  source code  for all  modules it contains, plus any
          associated interface  definition files, plus the scripts used to control
          compilation and  installation of  the executable.  However, as a special
          exception, the source code distributed need not include anything that is
          normally distributed  (in either  source or  binary form) with the major
          components (compiler,  kernel, and  so on)  of the  operating system  on
          which the  executable runs, unless that component itself accompanies the
          executable.

          If distribution  of executable or object code is made by offering access
          to copy from a designated place, then offering equivalent access to copy
          the source code from the same place counts as distribution of the source
          code, even  though third  parties are  not compelled  to copy the source
          along with the object code.

       4. You may  not copy,  modify, sublicense, or distribute the Program except
          as expressly  provided under  this License.   Any  attempt otherwise  to
     Printed 15 February, 1996                                               Page 99





     Libero User's Guide                                                 Version 2.11
          copy, modify,  sublicense or  distribute the  Program is  void, and will
          automatically terminate  your  rights  under  this  License.    However,
          parties who have received copies, or rights, from you under this License
          will not  have their  licenses terminated so long as such parties remain
          in full compliance.

       5. You are  not required  to accept this License, since you have not signed
          it.  However, nothing else grants you permission to modify or distribute
          the Program  or its  derivative works.   These actions are prohibited by
          law if  you do  not accept  this License.   Therefore,  by modifying  or
          distributing the  Program (or  any  work  based  on  the  Program),  you
          indicate your acceptance of this License to do so, and all its terms and
          conditions for  copying, distributing  or modifying the Program or works
          based on it.

       6. Each time  you redistribute  the Program  (or  any  work  based  on  the
          Program), the  recipient  automatically  receives  a  license  from  the
          original licensor  to copy,  distribute or modify the Program subject to
          these terms and conditions.  You may not impose any further restrictions
          on the  recipients' exercise  of the rights granted herein.  You are not
          responsible for enforcing compliance by third parties to this License.

       7. If, as  a consequence  of a  court  judgment  or  allegation  of  patent
          infringement or  for any  other reason  (not limited  to patent issues),
          conditions are  imposed on  you (whether  by court  order, agreement  or
          otherwise) that  contradict the  conditions of this License, they do not
          excuse you  from  the  conditions  of  this  License.    If  you  cannot
          distribute so  as to  satisfy simultaneously your obligations under this
          License and  any other  pertinent obligations, then as a consequence you
          may not distribute the Program at all.  For example, if a patent license
          would not permit royalty-free redistribution of the Program by all those
          who receive copies directly or indirectly through you, then the only way
          you could  satisfy both it and this License would be to refrain entirely
          from distribution of the Program.

          If any  portion of  this section  is held invalid or unenforceable under
          any particular  circumstance, the  balance of the section is intended to
          apply and  the section  as  a  whole  is  intended  to  apply  in  other
          circumstances.

          It is  not the  purpose of  this section  to induce  you to infringe any
          patents or  other property  right claims  or to  contest validity of any
          such claims;  this section  has  the  sole  purpose  of  protecting  the
          integrity of the free software distribution system, which is implemented
          by  public   license  practices.     Many   people  have  made  generous
          contributions to  the wide  range of  software distributed  through that
          system in reliance on consistent application of that system; it is up to
          the author/donor  to decide  if he  or  she  is  willing  to  distribute
          software through  any other  system and  a licensee  cannot impose  that
          choice.

          This section is intended to make thoroughly clear what is believed to be
          a consequence of the rest of this License.

       8. If the  distribution and/or  use of the Program is restricted in certain
          countries either  by patents  or by copyrighted interfaces, the original
          copyright holder  who places  the Program  under this License may add an
          explicit geographical distribution limitation excluding those countries,
          so that  distribution is  permitted only  in or among countries not thus
     Printed 15 February, 1996                                              Page 100





     Libero User's Guide                                                 Version 2.11
          excluded.   In such case, this License incorporates the limitation as if
          written in the body of this License.

       9. The Free  Software Foundation may publish revised and/or new versions of
          the General Public License from time to time.  Such new versions will be
          similar in  spirit to  the present  version, but may differ in detail to
          address new problems or concerns.

          Each version  is given  a distinguishing version number.  If the Program
          specifies a  version number of this License which applies to it and "any
          later  version",  you  have  the  option  of  following  the  terms  and
          conditions either  of that  version or of any later version published by
          the Free Software Foundation.  If the Program does not specify a version
          number of this License, you may choose any version ever published by the
          Free Software Foundation.

       10.  If you  wish to  incorporate parts  of the  Program  into  other  free
          programs whose  distribution conditions  are  different,  write  to  the
          author to  ask for permission.  For software which is copyrighted by the
          Free Software  Foundation, write  to the  Free Software  Foundation;  we
          sometimes make  exceptions for this.  Our decision will be guided by the
          two goals  of preserving  the free status of all derivatives of our free
          software and of promoting the sharing and reuse of software generally.

       11.  NO WARRANTY

          BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
          THE PROGRAM,  TO THE  EXTENT PERMITTED  BY APPLICABLE  LAW.  EXCEPT WHEN
          OTHERWISE STATED  IN WRITING  THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
          PROVIDE THE  PROGRAM "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND,  EITHER
          EXPRESSED OR  IMPLIED,  INCLUDING,  BUT  NOT  LIMITED  TO,  THE  IMPLIED
          WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
          ENTIRE RISK  AS TO  THE QUALITY  AND PERFORMANCE  OF THE PROGRAM IS WITH
          YOU.   SHOULD THE  PROGRAM PROVE  DEFECTIVE, YOU  ASSUME THE COST OF ALL
          NECESSARY SERVICING, REPAIR OR CORRECTION.

       12.  IN NO  EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
          WILL ANY  COPYRIGHT HOLDER,  OR ANY  OTHER PARTY  WHO MAY  MODIFY AND/OR
          REDISTRIBUTE THE  PROGRAM AS  PERMITTED ABOVE,  BE  LIABLE  TO  YOU  FOR
          DAMAGES, INCLUDING  ANY GENERAL,  SPECIAL, INCIDENTAL  OR  CONSEQUENTIAL
          DAMAGES ARISING  OUT  OF  THE  USE  OR  INABILITY  TO  USE  THE  PROGRAM
          (INCLUDING BUT  NOT LIMITED  TO LOSS  OF DATA  OR  DATA  BEING  RENDERED
          INACCURATE OR  LOSSES SUSTAINED  BY YOU OR THIRD PARTIES OR A FAILURE OF
          THE PROGRAM  TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
          OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

          END OF TERMS AND CONDITIONS


     How to Apply These Terms to Your New Programs

       If you  develop a  new program, and you want it to be of the greatest possible
     use to  the public,  the best  way to  achieve this  is to make it free software
     which everyone can redistribute and change under these terms.

       To do so, attach the following notices to the program.  It is safest to attach
     them to  the start  of each source file to most effectively convey the exclusion
     of warranty;  and each  file should  have at  least the  "copyright" line  and a
     pointer to where the full notice is found.
     Printed 15 February, 1996                                              Page 101





     Libero User's Guide                                                 Version 2.11
       <one line to give the program's name and a brief idea of what it does.>
       Copyright (C) 19yy <name of author>

       This program is free software; you can redistribute it and/or modify it under
       the terms of the GNU General Public License as published by the Free Software
       Foundation; either version 2 of the License, or (at your option) any later
       version.

       This program is distributed in the hope that it will be useful, but WITHOUT
       ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
       FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
       details.

       You should have received a copy of the GNU General Public License along with
       this program; if not, write to the Free Software Foundation, Inc., 675 Mass
       Ave, Cambridge, MA 02139, USA.

       Also add information on how to contact you by electronic and paper mail.

       If the program is interactive, make it output a short notice like this when it
     starts in an interactive mode:

       Gnomovision version 69, Copyright (C) 19yy name of author
       Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
       This is free software, and you are welcome to redistribute it
       under certain conditions; type `show c' for details.

       The hypothetical  commands `show  w' and  `show c' should show the appropriate
     parts of  the General  Public License.   Of  course, the commands you use may be
     called something  other than  `show w'  and `show  c'; they could even be mouse-
     clicks or menu items--whatever suits your program.

       You should  also get  your employer  (if you  work as  a programmer)  or  your
     school, if  any, to sign a "copyright disclaimer" for the program, if necessary.
     Here is a sample; alter the names:

          Yoyodyne, Inc.,  hereby disclaims  all copyright interest in the program
          `Gnomovision' (which makes passes at compilers) written by James Hacker.

          <signature of Ty Coon>, 1 April 1989 Ty Coon, President of Vice

       This General  Public License  does not  permit incorporating your program into
     proprietary programs.  If your program is a subroutine library, you may consider
     it more  useful to permit linking proprietary applications with the library.  If
     this is  what you want to do, use the GNU Library General Public License instead
     of this License.













     Printed 15 February, 1996                                              Page 102


