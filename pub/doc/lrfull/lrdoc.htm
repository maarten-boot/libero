
<!DOCTYPE HTML PUBLIC "-//SQ//DTD Libero//EN">
<HTML><HEAD><!--Built: 99/08/07 Pieter Hintjens-->
<TITLE>Libero Documentation</TITLE></HEAD>
<BODY BACKGROUND="newstone.gif">
<P><IMG SRC="lr_tiny.gif" ALT="Libero"> Libero 2.32</P>
<HR>
<H1>Libero Documentation</H1>
<P>
<MENU>
<LI><A HREF="#TOC1">Introduction to Libero</A></LI>
<MENU>
<LI><A HREF="#TOC2">Summary</A></LI>
<LI><A HREF="#TOC3">Terms and Disclaimer</A></LI>
<LI><A HREF="#TOC4">Introduction</A></LI>
<MENU>
<LI><A HREF="#TOC5">How It All Started</A></LI>
<LI><A HREF="#TOC6">Learning To Use Libero</A></LI>
</MENU>
<LI><A HREF="#TOC7">The Coke Machine Example</A></LI>
<LI><A HREF="#TOC8">Example of Using a Telephone</A></LI>
<MENU>
<LI><A HREF="#TOC9">Serious Stuff: Events and Names</A></LI>
</MENU>
<LI><A HREF="#TOC10">Example of Controlling a Telephone</A></LI>
<LI><A HREF="#TOC11">Source Code For Phone.c</A></LI>
<LI><A HREF="#TOC12">Example of a C/C++ Comment Stripper</A></LI>
<LI><A HREF="#TOC13">Example of Parsing An Arithmetic Expression</A></LI>
<LI><A HREF="#TOC14">Dialogs For Dummies</A></LI>
<MENU>
<LI><A HREF="#TOC15">Explain It Like I'm 5 Years Old</A></LI>
<LI><A HREF="#TOC16">A Bit Of Animation</A></LI>
</MENU>
<LI><A HREF="#TOC17">Frequently Asked Questions</A></LI>
</MENU>
<LI><A HREF="#TOC18">Installing Libero</A></LI>
<MENU>
<LI><A HREF="#TOC19">Getting Your Hands On Libero</A></LI>
<MENU>
<LI><A HREF="#TOC20">Availability and Distribution</A></LI>
<LI><A HREF="#TOC21">Documentation</A></LI>
<LI><A HREF="#TOC22">Deinstalling Libero</A></LI>
</MENU>
<LI><A HREF="#TOC23">What You Will Need</A></LI>
<LI><A HREF="#TOC24">Installing Libero for UNIX</A></LI>
<LI><A HREF="#TOC25">Installing the MS Windows Kit</A></LI>
<LI><A HREF="#TOC26">Installing the MS-DOS Kit</A></LI>
<LI><A HREF="#TOC27">Installing the 32-bit MS-DOS Kit</A></LI>
<LI><A HREF="#TOC28">Installing the OS/2 Kit</A></LI>
<LI><A HREF="#TOC29">Installing the VAX/VMS Kit</A></LI>
<LI><A HREF="#TOC30">Installing the Examples</A></LI>
<LI><A HREF="#TOC31">Configuring and Testing Libero</A></LI>
</MENU>
<LI><A HREF="#TOC32">Using Libero</A></LI>
<MENU>
<LI><A HREF="#TOC33">Running The lr Program</A></LI>
<LI><A HREF="#TOC34">The Dialog File Syntax</A></LI>
<LI><A HREF="#TOC35">Libero Options</A></LI>
<LI><A HREF="#TOC36">Using Exceptions</A></LI>
<LI><A HREF="#TOC37">Using The Defaults State</A></LI>
<LI><A HREF="#TOC38">Using Sub-Dialogs</A></LI>
<LI><A HREF="#TOC39">Using Super-States</A></LI>
<LI><A HREF="#TOC40">Using Templates</A></LI>
<LI><A HREF="#TOC41">Using Get-External-Event</A></LI>
<LI><A HREF="#TOC42">Efficiency</A></LI>
<MENU>
<LI><A HREF="#TOC43">Efficiency of The Generated Code</A></LI>
<LI><A HREF="#TOC44">Efficiency of The Dialog</A></LI>
</MENU>
<LI><A HREF="#TOC45">Care and Feeding of Dialogs</A></LI>
<MENU>
<LI><A HREF="#TOC46">Style - Good, Bad, and Ugly</A></LI>
<LI><A HREF="#TOC47">Choosing Names</A></LI>
</MENU>
<LI><A HREF="#TOC48">When To Use Libero</A></LI>
</MENU>
<LI><A HREF="#TOC49">Libero Examples</A></LI>
<MENU>
<LI><A HREF="#TOC50">Libero 'install' Script for UNIX</A></LI>
<LI><A HREF="#TOC51">COBOL Picture Parser</A></LI>
<LI><A HREF="#TOC52">Expression Parser</A></LI>
<LI><A HREF="#TOC53">Configuration Management System</A></LI>
<LI><A HREF="#TOC54">Multithreaded Agent For VAX/ACMS</A></LI>
<LI><A HREF="#TOC55">E-mail Robot - ERBOT</A></LI>
<LI><A HREF="#TOC56">HTML Preprocessor</A></LI>
<LI><A HREF="#TOC57">Complete Examples Archive</A></LI>
</MENU>
<LI><A HREF="#TOC58">Libero's Languages</A></LI>
<MENU>
<LI><A HREF="#TOC59">Choosing A Language</A></LI>
<LI><A HREF="#TOC60">Standard Public Names</A></LI>
<LI><A HREF="#TOC61">Contributed Schemas</A></LI>
<LI><A HREF="#TOC62">The Awk Language</A></LI>
<LI><A HREF="#TOC63">The C Language</A></LI>
<LI><A HREF="#TOC64">The C++ Language</A></LI>
<LI><A HREF="#TOC65">The COBOL Language</A></LI>
<LI><A HREF="#TOC66">The GNU Borne-Again Shell Language</A></LI>
<LI><A HREF="#TOC67">The Java Language</A></LI>
<LI><A HREF="#TOC68">The Microsoft Setup Basic Language</A></LI>
<LI><A HREF="#TOC69">The MS Visual Basic Language</A></LI>
<LI><A HREF="#TOC70">The Perl Language</A></LI>
<LI><A HREF="#TOC71">The Rexx Language</A></LI>
<LI><A HREF="#TOC72">The UNIX C Shell Language</A></LI>
<LI><A HREF="#TOC73">The UNIX Bourne Shell Language</A></LI>
<LI><A HREF="#TOC74">The UNIX Korn Shell Language</A></LI>
<LI><A HREF="#TOC75">The 80x86 Assembler Language</A></LI>
</MENU>
<LI><A HREF="#TOC76">Libero Technical Reference</A></LI>
<MENU>
<LI><A HREF="#TOC77">A First Look At Code Generation</A></LI>
<MENU>
<LI><A HREF="#TOC78">The Schema</A></LI>
</MENU>
<LI><A HREF="#TOC79">Read-Only Variables</A></LI>
<LI><A HREF="#TOC80">Schema Commands</A></LI>
<MENU>
<LI><A HREF="#TOC81">Notes</A></LI>
</MENU>
<LI><A HREF="#TOC82">Syntax Of Expressions</A></LI>
<LI><A HREF="#TOC83">Syntax Of Logical Conditions</A></LI>
<MENU>
<LI><A HREF="#TOC84">Logical Operators</A></LI>
<LI><A HREF="#TOC85">Standard Tests</A></LI>
</MENU>
<LI><A HREF="#TOC86">Control Variables</A></LI>
<LI><A HREF="#TOC87">Standard :do Conditions</A></LI>
<LI><A HREF="#TOC88">Extra Variables In A :do Loop</A></LI>
<MENU>
<LI><A HREF="#TOC89"><TT>:do while</TT> <I>condition</I></A></LI>
<LI><A HREF="#TOC90"><TT>:do event</TT></A></LI>
<LI><A HREF="#TOC91"><TT>:do event local</TT></A></LI>
<LI><A HREF="#TOC92"><TT>:do state</TT></A></LI>
<LI><A HREF="#TOC93"><TT>:do module</TT></A></LI>
<LI><A HREF="#TOC94"><TT>:do action</TT></A></LI>
<LI><A HREF="#TOC95"><TT>:do nextst</TT></A></LI>
<LI><A HREF="#TOC96"><TT>:do vector</TT></A></LI>
<LI><A HREF="#TOC97"><TT>:do overflow</TT></A></LI>
<LI><A HREF="#TOC98"><TT>:do stubs</TT> [<I>filename</I>]...</A></LI>
</MENU>
<LI><A HREF="#TOC99">General Rules for Code Generation</A></LI>
<LI><A HREF="#TOC100">Generating Module Stubs</A></LI>
<LI><A HREF="#TOC101">Generating COBOL Code</A></LI>
<LI><A HREF="#TOC102">The State Machine Algorithm</A></LI>
<LI><A HREF="#TOC103">Compiled-In Limitations</A></LI>
<LI><A HREF="#TOC104">Quick Reference - Libero Schema Language</A></LI>
<MENU>
<LI><A HREF="#TOC105">General</A></LI>
<LI><A HREF="#TOC106">Read-Only Variables</A></LI>
<LI><A HREF="#TOC107">Schema Commands</A></LI>
<LI><A HREF="#TOC108">Expressions</A></LI>
<LI><A HREF="#TOC109">Logical Conditions</A></LI>
<LI><A HREF="#TOC110">Control Variables</A></LI>
<LI><A HREF="#TOC111">Standard :do Conditions</A></LI>
</MENU>
</MENU>
</MENU>
</P>
<HR>

<H1><A NAME="TOC1">Introduction to Libero</A></H1>


<H2><A NAME="TOC2">Summary</A></H2>

<UL>
<LI>Libero is a Programmer's Tool and Code Generator.  You
define the high-level logic of a problem as a diagram: Libero
generates the code to implement this logic.  Your applications
are easier to write, more robust, easier to understand. Libero
uses a finite-state machine as the underlying model.</LI>
<LI>Libero generates code in these languages: C, C++, Java,
Perl, Awk, 80x86 assembler, COBOL, MS Visual Basic, MS Test
Basic, UNIX C Shell, UNIX Korn Shell, UNIX Bourne Shell, GNU
Bash Shell, Rexx, PL/SQL, and PHP.  You can extend Libero support
to other languages via external <EM>schema</EM> files.</LI>
<LI>Libero runs on: UNIX (tested on Linux, HP/UX, SunOS, Irix,
AIX, Solaris), MS-DOS, MS-Windows, Digital Open-VMS, OS/2.  It
is in theory portable to any ANSI C compiler; the Libero sources
are part of the package.</LI>
</UL>

<H2><A NAME="TOC3">Terms and Disclaimer</A></H2>

<P>This program is free software; you can redistribute it and/or modify it
under the terms of the <A href="/html/gnugpl.htm">GNU General Public License</A> as published by
the Free Software Foundation; either version 2 of the License, or (at your
option) any later version. This program is distributed in the hope that it
will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</P>

<H2><A NAME="TOC4">Introduction</A></H2>

<BLOCKQUOTE><P>&quot;Laziness</P>

<P>The quality that makes you go to great effort to reduce
overall energy expenditure.  It makes you write labour-saving
programs that other people will find useful, and document what
you wrote so you don't have to answer so many questions about
it.  Hence the first great virtue of a programmer.&quot;</P>

<P>Larry Wall [Programming Perl, Larry Wall and Randal. L.
Schwartz, 1992 O'Reilly &amp; Associates, Inc., page
426.]</P></BLOCKQUOTE>

<H3><A NAME="TOC5">How It All Started</A></H3>

<P>In 1982, as a student, I got into games programming as a way
of making some money.  I skipped the build-it-yourself-from-an-
old-TV-screen-and-a-hex-keypad phase of people computers, and
jumped straight into the world of ready-to-go colour and sound.
My first PC had 5K of RAM, and 25x22 colour video.  It could
beep in three-part harmony.  My first published work was an
article that explained how to tweak the video output to 30x33
(hi-resolution!).  Soon I was writing sprite painters, assembly
libraries for sound and graphics, even languages to replace the
built-in Basic.  Anything to let me write my games faster and
better.  Before I knew what had hit me, I was hooked into the
cycle of writing tools to improve the world I lived in.</P>

<P>I haven't written a game for a long time, but I've continued
writing tools. Libero is one of the best - it's simple, clean,
portable, and has hit the mark so often that I feel it's unfair
to keep it for myself.</P>

<P>The ideas behind Libero evolved in Brussels, Belgium during
the 1980's and 90's.  I worked with <A href="mailto:leif@ibm.net">Leif Svalgaard</A>, on
what we would now call a CASE tool - <A href="http://www.toscintl.com">ETK</A> - that let
COBOL programmers produce clean, portable code instead of the
mess we generally saw.  One of the key techniques we used was a
programming method based on finite state machines. Historically,
the first real programs that used finite state machines were
compilers.  In 1967, Peter Naur describes a new way of using
FSMs (which he refers to as a Turing machine approach) in a
compiler, and shows how they simplify error checking.  He goes
on to say:</P>

<BLOCKQUOTE>
<P>&quot;The above description has stressed the checking aspect
of the Turing machine approach.  However, an equally important
aspect is the ease with which arbitrary actions may be
specified.  By using this approach it is usually possible to
avoid tests in individual actions to a surprisingly high degree.
This in our experience is a very effective way of reducing the
bulk and execution time of the translator algorithm.&quot; </P>
<P>[Annual Review in Automatic Programming, &quot;Design Of The
Gier Algol Compiler&quot;, Ed. Richard Goodman; 1964 Pergamon
Press, page 77.]</P>
</BLOCKQUOTE>

<P>ETK provides an interactive editor that you use to describe
the logic of the program as a FSM.  This approach encourages you
to think about the complete problem.  You describe everything
that can happen, and how the program should react.  The end-
result looks a little like a flow-chart, but has more arrows,
and fewer different kinds of boxes.  The value of this approach
is that you can abstract a complex problem using the restricted
semantics of a FSM.  In the same way that a <B>While</B>
statement is less powerful but more useful than a <B>Goto</B>, a
FSM is less powerful but more useful than a structured
programming approach for describing complex problems.  Leif
Svalgaard once said: &quot;the issue is not one of power, but
coping with the human difficulty in understanding complex
structures&quot;.
</P>

<P>Now, in a conventional state machine, these boxes are given
numbers, and the programmer builds some tables that encode the
arrows.  To make such a table by hand - or, just as bad, encode
the table directly in the logic of the program, using GOTOs - is
a Bad Thing, since the result is near to impossible to maintain.
The neat part of our solution was that we took the textual
description (called a 'dialog'), and generated the mystical
tables directly as COBOL code.  This is a Good Thing, since the
original dialog is easy to change, and suddenly becomes
excellent (and always accurate) documentation.  In 1992 I began
working as a consultant, and found that I wanted to use these
techniques in my work.  I was writing in C, so I threw together
a code generator that could output C code using the same dialog
methodology I was used to.  I called this tool 'Libero' after
the guy who runs around the sidelines at the football/soccer
pitch doing all the dirty work.  My first serious job was a
bunch of TCP/IP clients and servers.  It was nice to come back
to the place three years later and find that the guy maintaining
my work had only found one bug, and was happy to go into the
programs.  He said that the dialogs made them easy to understand
and modify.</P>

<P>This kind of experience convinced me that there was real
value in this tool. I've written lots of cute programs that are
useful for my own needs, but that just don't hack it in the real
world.  Libero is different.</P>

<P>The first public release of Libero (1.7) generated C code
using an external model, a kind of script called a 'schema'.  I
had a couple of schemas; one for ANSI C code, and one for
multithreaded DEC/VMS code.  I released version 2.0 onto the Net
after adding schemas for UNIX scripts. This release gave me a
lot of feedback, and I rewrote the code-generator again to make
it much more generic.  The current version 2.11 has a lot more
language schemas and a lot fewer bugs, plus a front-end for MS-
Windows.</P>

<P>I hope to continue in both these directions.  Libero has
become a tool that lets you switch between languages at ease.
The first step is to accept the state-machine as a valid method
for program development.  This takes a little effort, but I hope
that the examples which follow will help convince you.  The
second step is to see that this method is language-independent.
You can write a program in C, then recode it in Perl without
changing its design.</P>

<P>A hypothetical development team might write mainframe
business applications in COBOL, tools in Perl, servers in C,
batch scripts in Korn shell, Web clients in Java.  Yet instead
of a team fragmented into  specialists in each domain, you would
have a team that enjoys a common design  technique and who can
quickly take on each other's work.  In practice, you also get a
certain communality of programming style, which disturbs
language  purists.  However, I like it when - say - a COBOL
programmer that knows only  Libero take a C program written with
Libero and says: &quot;But it looks like  COBOL!&quot;.  Of
course neither the Libero+C nor Libero+COBOL programs look
anything like 'COBOL'.</P>

<H3><A NAME="TOC6">Learning To Use Libero</A></H3>

<P>I've not found a quick way to convey the true nature of state
machine programming.  In my experience, it invariably takes a
few days of practice. After three or four days' exposure to the
idea there is a near-audible 'click!' and something in the brain
connects all the pieces together and you go 'Oh, it's like
THAT!'.  Maybe people cultured on event-driven programming will
get it faster.</P>


<H2><A NAME="TOC7">The Coke Machine Example</A></H2>

<P>The coke machine (once awake and gently humming) sits against the wall,
waiting.  There is a theory about this humming business, notably that coke
machines have terrible memories, and can't remember the words.  A second
school of thought says that the coke machines are humming because they're
thinking about all the terrible things they're going to do to humans with
crow bars.  A third school of thought reckons that the coke machines have
already done something, and are humming because they thought it was really
funny.  Like all coke machines, it's very good at waiting, due to Natural
Selection.  All the impatient proto-coke machines ran off screaming 'I can't
take it anymore' and were crunched underfoot by brontosaurii back in the
mists of prehistory.</P>

<P>A punter arrives with a handful of loose change.  The coke-machine
(covered by the modern and tasteful metal grid that serves both as a
defensive covering and as an attraction for coke machines of the opposite
sex) moves into 'attention' mode.  When it hears the clink of tasty cash,
rather that the ominous clunk of a heavy crow-bar, it relaxes into 'ready
mode'.  The machine is now ready to handle any eventuality, so long as it
includes coinage.</P>

<P>As the last coin falls and the punter presses the button labelled
'healthie waye sparkling spring water', the machine considers the
possibilities.  Should it play dead, and just take the punter's money?
Or maybe it can substitute a can of 30% sucrose 'sweeto-sap'?  Finally
it rumbles once, then again for added effect, then excretes a can of water.
It munches the coins, then settles back against the wall, quietly humming
again.</P>

<P>Just to prove that you can describe <I>any</I> sequence of events, however
improbable, with a state machine, here goes.  (The observant reader will have
skipped to the next section by now, realising that this one is not worth the
paper it's printed on.  If you're reading this on-line, then this section is
not worth the phosphor it's been digitised, rasterised, and sprayed by an
electronic beam gun onto.)  Act 1, scene 1 has our protagonist against the
wall, trying to remember the words of the song.  Our coke-machine hero is
normally OK; if something went terribly wrong with the rehearsals (e.g. a
dinosaur got sucked through a five-dimensional space-time vortex stretched
between the middle terrasic to five minutes into rehersals; the dinosaur a
little off balance after the trip puts down its left foot, and 'crunch'...),
it might be Dead, in which case we have to call the whole thing off.  We'll
call this scene 'Should Be Gently Humming'...</P>

<PRE>
Should-Be-Gently-Humming:
    (--) Ok                         -&gt; Something-Happened
          + Wait-For-A-Punter
    (--) Dead                       -&gt;
          + Stop-The-Programme
</PRE>

<P>The coke machine has been waiting, perhaps for days, for a punter to come
along.  When the footprints fade in from the distance (a coke machine's ears
are always against the ground, which explains why you rarely find coke
machines on wet or dirty surfaces), the machine hears either a cashy 'clink'
or a more sinister 'clunk':</P>

<PRE>
Something-Happened:
    (--) Clink                      -&gt; Before-Cooperating
          + Accept-Punter's-Cash
          + Wait-For-Punter's-Choice
          + Shall-We-Cooperate?
    (--) Clunk                      -&gt;
          + Exit-Stage-Left-Running
          + Stop-The-Programme
</PRE>

<P>The advent of a 'Clunk' tells the machine to beat it, smartly.  If a
'Clink' happened, the machine goes on to think about a game plan for the
coming few minutes.  It accepts whatever spare change the punter has to
spare, then pounces, metaphorically:</P>

<PRE>
Before-Cooperating:
    (--) Ok                         -&gt; Cooperate
          + Consider-Punter's-Choice
    (--) Nasty                      -&gt; Let's-Be-Nasty
          + Consider-Punter's-Choice
    (--) Play-Dead                  -&gt; Something-Happened
          + Switch-Off-All-Lights
          + Wait-Until-Punter-Has-Left
          + Switch-On-The-Lights
          + Wait-For-A-Punter
</PRE>

<P>If it's in a good mood, the machine ejects more or less the drink that the
punter chose:</P>

<PRE>
Cooperate:
    (--) Coke                       -&gt; Something-Happened
          + Eject-Can-Of-Coke
          + Wait-For-A-Punter
    (--) Spring-Water               -&gt; Something-Happened
          + Eject-Can-Of-Spring-Water
          + Wait-For-A-Punter
    (--) Juice                      -&gt; Something-Happened
          + Eject-Can-Of-Juice
          + Wait-For-A-Punter
    (--) Sweeto-Sap                 -&gt; Something-Happened
          + Eject-Can-Of-Sweeto-Sap
          + Wait-For-A-Punter
    (--) Empty                      -&gt;
          + Switch-Off-All-Lights
          + Stop-The-Programme
</PRE>

<P>If the coke machine's pretty weak internal moral system failed, it
supplies the opposite of whatever the punter wanted:</P>

<PRE>
Let's-Be-Nasty:
    (--) Coke                       -&gt; Something-Happened
          + Eject-Can-Of-Juice
          + Wait-For-A-Punter
    (--) Spring-Water               -&gt; Something-Happened
          + Eject-Can-Of-Sweeto-Sap
          + Wait-For-A-Punter
    (--) Juice                      -&gt; Something-Happened
          + Eject-Can-Of-Coke
          + Wait-For-A-Punter
    (--) Sweeto-Sap                 -&gt; Something-Happened
          + Eject-Can-Of-Spring-Water
          + Wait-For-A-Punter
    (--) Empty                      -&gt;
          + Switch-Off-All-Lights
          + Stop-The-Programme
</PRE>

<P>This diagram is a little complex for a first example.  Remember however,
that we are modelling a rich behaviour pattern that took several hundreds of
millions of years to evolve.  Real software is usually developed much faster,
and should therefore be much simpler, only it isn't.</P>


<H2><A NAME="TOC8">Example of Using a Telephone</A></H2>

<P>In a more technical example, we'll model the steps we take in using making
a telephone call.  By convention, the first state is <TT>After-Init</TT>.
Another convention is to use <TT>Terminate-The-Program</TT> to halt the
dialog.</P>

<P>After initialisation (I would recommend a good coffee or a decent beer,
depending on the time of day), we pick-up the handset, and listen to the
dialing tone.</P>

<PRE>
After-Init:
    (--) Ok                          -&gt; Want-Dialing-Tone
          + Pick-Up-Telephone-Handset
          + Listen-For-Dialing-Tone
    (--) Error                       -&gt;
          + Terminate-The-Program
</PRE>

<P>This leads us to the state <TT>Want-Dialing-Tone</TT>.  Here we handle
each of the possible events produced by <TT>Listen-For-Dialing-Tone</TT>.
Let's look at these in detail:
<UL>
<LI><B>Ok</B> We have a dialing tone, so we can dial the number.  This
is the normal, expected event.</LI>
<LI><B>Silent, no tone</B> The telephone exchange is having a hard day, or
someone unplugged the phone.  Or maybe a ninja attack team has cut the phone
cables and is at this moment sneaking up the stairs and AAAARGH...  In this
simple example we loop forever; in a real program we would allow a limited
number of attempts.</LI>
<LI><B>Voices on the line</B> Some other member of the household is making
the phone company richer.  We apologise and forget it.</LI>
<LI><B>Modem noise</B> - the young bro' is downloading some more bootleg
GIF's.</LI>
</UL></P>

<P>We give each of these events a short snappy name and list them in a
reasonable order.  Like a 'case' statement, the actual order makes no
difference to the machine, but helps the person reading the dialog.
Typically we put the most frequent or expected events first, with the more
bizarre ones at the end.  Each event provokes one or more <I>actions</I> that
correspond to <I>modules</I> of code.  A module can be a <I>function</I>,
<I>procedure</I>, <I>subroutine</I>, <I>paragraph</I>, etc., depending on the
programming language.  A module is where you do the real work.</P>

<PRE>
Want-Dialing-Tone:
    (--) Ok                          -&gt; Want-Ringing-Tone
          + Dial-Required-Number
          + Listen-For-Ringing-Tone
    (--) Silent                      -&gt; Want-Dialing-Tone
          + Put-Down-Telephone-Handset
          + Pick-Up-Telephone-Handset
          + Listen-For-Dialing-Tone
    (--) Voices                      -&gt;
          + Apologise-Telephone-Busy
          + Put-Down-Telephone-Handset
          + Terminate-The-Program
    (--) Modem                       -&gt;
          + Put-Down-Telephone-Handset
          + Apologise-Cutting-Modem
          + Terminate-The-Program
</PRE>

<P>Here we are waiting for a ringing tone.  We can reuse some of the event
names - <TT>Ok</TT>, <TT>Silence</TT>, <TT>Voices</TT> - from the previous
state.  This makes the generated code smaller, and is nice for the reader,
since there are fewer names to remember:</P>

<PRE>
Want-Ringing-Tone:
    (--) Ok                          -&gt; Want-Answer
          + Listen-For-Answer
    (--) Silence                     -&gt; Want-Dialing-Tone
          + Put-Down-Telephone-Handset
          + Pick-Up-Telephone-Handset
          + Listen-For-Dialing-Tone
    (--) Engaged                     -&gt; After-Engaged
          + Put-Down-Telephone-Handset
          + Consider-Trying-Again
    (--) Voices                      -&gt; Want-Dialing-Tone
          + Complain-Crossed-Connection
          + Put-Down-Telephone-Handset
          + Pick-Up-Telephone-Handset
          + Listen-For-Dialing-Tone
</PRE>

<P>You get the picture.  The remaining states map out the rest of the
conversation.  The next state has an event, <TT>Doorbell</TT>, that is not
produced by any previous module, but that can happen at any time.  We call
this an <I>exception event</I>, and we add the handling for it in the state
where it can happen:</P>

<PRE>
Want-Answer:
    (--) Ok                          -&gt;
          + Have-Conversation
          + Put-Down-Telephone-Handset
          + Terminate-The-Program
    (--) Wrong-Number                -&gt;
          + Apologise-Wrong-Number
          + Put-Down-Telephone-Handset
          + Terminate-The-Program
    (--) Impatient                   -&gt;
          + Put-Down-Telephone-Handset
          + Terminate-The-Program
    (--) Answering-Machine           -&gt; Have-Answering-Machine
          + Consider-Leaving-Message
    (--) Modem-Or-Fax
          + Put-Down-Telephone-Handset
          + Terminate-The-Program
    (--) Doorbell                    -&gt;
          + End-Conversation-Quickly
          + Put-Down-Telephone-Handset
          + Terminate-The-Program

After-Engaged:
    (--) Ok                          -&gt; Want-Ringing-Tone
          + Dial-Required-Number
          + Listen-For-Ringing-Tone
    (--) Impatient                   -&gt;
          + Put-Down-Telephone-Handset
          + Terminate-The-Program

Have-Answering-Machine:
    (--) Message                     -&gt;
          + Leave-The-Message
          + Put-Down-Telephone-Handset
          + Terminate-The-Program
    (--) Impatient                   -&gt;
          + Put-Down-Telephone-Handset
          + Terminate-The-Program
</PRE>

<P>The <TT>Defaults</TT> state is special; we never come here explicitly.
Rather, the state holds events that are implicitly valid in any other state.
Here we say that whenever the <TT>Doorbell</TT> event strikes, we put the
phone down and beat it doorwards.  Note that the <TT>Doorbell</TT> event is
handled explicitly in <TT>Want-Answer</TT> - the action in that state is a
little different from the other states.</P>

<PRE>
Defaults:
    (--) Doorbell                    -&gt;
          + Put-Down-Telephone-Handset
          + Terminate-The-Program
</PRE>

<H3><A NAME="TOC9">Serious Stuff: Events and Names</A></H3>

<P>Now I want to show how an action module 'produces' an event.  Libero
provides a standard variable called <TT>The-Next-Event</TT>.  An event like
'Ok' is actually called <TT>Ok-Event</TT> in the program (Libero tacks-on
'-Event' for you).  This is how you would set <TT>The-Next-Event</TT> in
various languages:
<UL>
<LI>C/C++: <TT>the_next_event = ok_event;</TT></LI>
<LI>80x86 assembler: <TT>mov the_next_event,ok_event</TT></LI>
<LI>UNIX Korn Shell: <TT>the_next_event=$ok_event</TT></LI>
<LI>Perl: <TT>the_next_event = $ok_event;</TT></LI>
<LI>COBOL: <TT>MOVE OK-EVENT TO THE-NEXT-EVENT</TT></LI>
<LI>Visual Basic: <TT>the_next_event = ok_event</TT></LI>
</UL></P>

<P>Libero applies this rule: <I>at least </I>one of the action modules for an
event must supply a value for <TT>The-Next-Event</TT>.  If no value for
<TT>The-Next-Event</TT> is supplied, the dialog halts with some kind of error
message.</P>

<P>The names of events and action modules can take various forms, depending
on the language and your preferences.  For example, the C/C++ code could take
any of these forms:
<UL>
<LI>Plain style: <TT>the_next_event = ok_event;</TT></LI>
<LI>Caps style: <TT>TheNextEvent = OkEvent;</TT></LI>
<LI>Headline style: <TT>The_Next_Event = Ok_Event;</TT></LI>
<LI>Title style: <TT>The_next_event = Ok_event;</TT></LI>
</UL></P>

<P>Personally I prefer the first style, which is why it's the default.</P>


<A NAME="rover">&nbsp;</A>
<H2><A NAME="TOC10">Example of Controlling a Telephone</A></H2>

<P>This next example is one that a correspondent at a telephone company
proposed. It's a design for a simple but dedicated subprogram (we'll call it
'Rover') that hangs-around on the corner of our telephone central.  Rover
springs into action (presumably woofing and waggling a shaggy tail) when we
pick-up the handset, or when a call comes in for us.  The dialog loops around
and around, each time driven by an 'incoming message'.  This message is one
of these events:
<UL>
<LI><B>Offhook</B> - we picked-up the handset.  Presumably this affects the
current on the line, which the central can detect.</LI>
<LI><B>Onhook</B> - we put the phone down.</LI>
<LI><B>Request</B> - another person is calling us from a 'remote' phone.</LI>
<LI><B>Digit</B> - we pressed a digit on the touchpad.</LI>
<LI><B>Whole Number</B> - we pressed enough digits to form a recognised
number.</LI>
<LI><B>Accept</B> - the remote phone accepted the call - ie. the remote Rover
gets a Request event of its own.</LI>
<LI><B>Busy</B> - the remote phone was busy.</LI>
<LI><B>Reject</B> - the remote phone number was rejected - we made a mistake
with the number, or (if dialing into Britain) the British changed their
dialing prefixes again.</LI>
<LI><B>Answer</B> - finally, contact.  I hope it was worth it.</LI>
<LI><B>Release</B> - the remote phone cut the Talking.  At our end we hear
a tone that signals this.  (This is how my telephone central works.)</LI>
</UL></P>

<P>Here is the dialog.  Rover waits for anything to happen, then leaps:</P>

<PRE>
After-Init:
    (--) Ok                           -&gt; Idle
          + Wait-For-Incoming-Message
    (--) Error                        -&gt;
          + Terminate-The-Program
</PRE>

<P>The two possible events at this stage are <TT>Offhook</TT> (coming from
the local phone), and <TT>Request</TT> (from a remote phone).  We call this
state 'Idle'.  Some people get confused at this point, and point out that
Rover is exactly <I>not</I> idle, so why the name.  Why not call the very
first state 'Idle'?  I answer so: the name of a state reflects the state we
were in when the event happened.  Thus, when Rover was idle, the only two
events that could happen were <TT>Offhook</TT> and <TT>Request</TT>.</P>

<PRE>
Idle:
    (--) Offhook                      -&gt; Dialing-First
          + Start-Dial-Tone
          + Reset-Dialed-Number
          + Wait-For-Incoming-Message
    (--) Request                      -&gt; Ringing
          + Start-Ringing-Local
          + Wait-For-Incoming-Message
</PRE>

<P>The next two states show what happens when we dial the first digit. Rover
stops with the dial tone, and slurps up the digits we press, one by one. I
distinguish <TT>Dialing-First</TT> from <TT>Dialing-Next</TT> to ensure that
Rover does a <TT>Stop-Local-Tones</TT> the first time only:</P>

<PRE>
Dialing-First:
    (--) Digit                        -&gt; Dialing-Next
          + Stop-Local-Tones
          + Have-Dialed-Digit
          + Wait-For-Incoming-Message
    (--) Whole-Number                 -&gt; Seizing
          + Stop-Local-Tones
          + Send-Outgoing-Request
          + Wait-For-Incoming-Message
    (--) Onhook                       -&gt; Idle
          + Stop-Local-Tones
          + Wait-For-Incoming-Message
</PRE>

<P>Rover doesn't bother handling the <TT>Onhook</TT> event here, since the
<TT>Defaults</TT> state handles it just fine:</P>

<PRE>
Dialing-Next:
    (--) Digit                        -&gt; Dialing-Next
          + Have-Dialed-Digit
          + Wait-For-Incoming-Message
    (--) Whole-Number                 -&gt; Seizing
          + Stop-Local-Tones
          + Send-Outgoing-Request
          + Wait-For-Incoming-Message
</PRE>

<P>Okay, we just tried to 'seize' the remote phone.  This is either accepted
(and the remote phone starts ringing) or rejected for various reasons:</P>

<PRE>
Seizing:
    (--) Accept                       -&gt; Ringing
          + Start-Ringing-Remote
          + Wait-For-Incoming-Message
    (--) Busy                         -&gt; Seize-Failed
          + Start-Busy-Tone
          + Wait-For-Incoming-Message
    (--) Reject                       -&gt; Seize-Failed
          + Start-Reject-Tone
          + Wait-For-Incoming-Message

Seize-Failed:
    (--) Onhook                       -&gt; Idle
          + Stop-Local-Tones
          + Wait-For-Incoming-Message
</PRE>

<P>The next three states show how Rover handles a ringing phone (at either
end) and the eventual Talking, if any.  I combined the handling for the local
and remote phones into two states; I could also write this more clearly but
verbosely as four states (<TT>Ringing-Local</TT>, <TT>Ringing-Remote</TT>,
<TT>Talking-Local</TT>, <TT>Talking-Remote</TT>).</P>

<PRE>
Ringing:
    !  Events from local phone
    (--) Offhook                      -&gt; Talking
          + Stop-Ringing-Local
          + Wait-For-Incoming-Message
    (--) Onhook                       -&gt; Idle
          + Stop-Ringing-Remote
          + Wait-For-Incoming-Message
    !  Event from remote phone
    (--) Answer                       -&gt; Talking
          + Stop-Ringing-Remote
          + Wait-For-Incoming-Message

Talking:
    !  Event from local phone
    (--) Onhook                       -&gt; Idle
          + Send-Outgoing-Release
          + Wait-For-Incoming-Message
    !  Event from remote phone
    (--) Release                      -&gt; Released
          + Start-Released-Tone
          + Wait-For-Incoming-Message

Released:
    (--) Onhook                       -&gt; Idle
          + Stop-Local-Tones
          + Wait-For-Incoming-Message
</PRE>

<P>The <TT>Defaults</TT> state handles the <TT>Onhook</TT> event in those
states where there is no local tone.  In those states (like
<TT>Released</TT>), Rover silences the local phone, then loops back to the
<TT>Idle</TT> state:</P>

<PRE>
Defaults:
    (--) Onhook                       -&gt; Idle
          + Wait-For-Incoming-Message
</PRE>


<H2><A NAME="TOC11">Source Code For Phone.c</A></H2>

<P>When I take the above dialog (called phone.l), and give it to
Libero, this is what happens:</P>

<PRE>
 C:\CTOOLS\LIBERO&gt;<B>lr phone</B>
 LIBERO v2.11 (c) 1991-96 by Pieter A. Hintjens
 lr I: processing 'phone.l'...
 lr I: creating skeleton program phone.c...
 lr I: building phone.d...
 lr I: building phone.i...
 lr I: Building stub for have dialed digit
 lr I: Building stub for reset dialed number
 lr I: Building stub for send outgoing release
 lr I: Building stub for send outgoing request
 lr I: Building stub for start busy tone
 lr I: Building stub for start dial tone
 lr I: Building stub for start released tone
 lr I: Building stub for start ringing local
 lr I: Building stub for start ringing remote
 lr I: Building stub for stop local tones
 lr I: Building stub for stop ringing local
 lr I: Building stub for stop ringing remote
 lr I: Building stub for wait for incoming message
 C:\CTOOLS\LIBERO&gt;
</PRE>

<P>Libero assumes that I want to make a program called phone.c.  Since this
file does not exist, it creates a skeleton program for me.  This only happens
the first time.  Once the program is created, Libero will add missing pieces
to it, at the end, but will never change it again otherwise.</P>

<P>I get two other files as well, phone.d and phone.i.  These are the data
and interpreter for my dialog.  I need these files to compile phone.c.  Each
time I run Libero, it recreates these two files.  If I was working in another
language, I would get different files, with different extensions.  The
default language is C.  Here is the skeleton program that Libero gave me,
more or less:</P>

<PRE>
/*=========================================================================*
 *                                                                         *
 *  phone.c     description...                                             *
 *                                                                         *
 *  Written:    95/07/29    Your Name                                      *
 *  Revised:    95/07/29                                                   *
 *                                                                         *
 *  Skeleton generated by LIBERO 2.10 on 29 Jul, 1995, 11:50.              *
 *                                                                         *
 *=========================================================================*/

#include "prelude.h"                    /*  Public definitions             */
#include "phone.d"                      /*  Include dialog data            */

/*- Function prototypes ---------------------------------------------------*/

/*- Global variables used in this source file only ------------------------*/

static int
    feedback;                           /*  Feedback for calling program   */

static char
    *some_param;                        /*  Example of parameter           */

/********************************   M A I N   ******************************/

int my_funct (char *p_some_param)
{
    feedback = 0;                       /*  No errors so far               */
    some_param = p_some_param;          /*  Local copy of parameters       */

#   include "phone.i"                   /*  Include dialog interpreter     */
}

/************************   INITIALISE THE PROGRAM   ***********************/

MODULE initialise_the_program (void)
{
    the_next_event = ok_event;
}

/**************************   GET EXTERNAL EVENT   *************************/

MODULE get_external_event (void)
{
}

/************************   TERMINATE THE PROGRAM   ***********************/

MODULE terminate_the_program (void)
{
    the_next_event = terminate_event;
}

/**************************   HAVE DIALED DIGIT   **************************/

MODULE have_dialed_digit (void)
{
}

/************************   RESET DIALED NUMBER   ************************/

MODULE reset_dialed_number (void)
{
}
 ... etc.
</PRE>

<P>I discuss the details of Libero+C programming elsewhere.  Some rules
apply whatever language you use:
<UL>
<LI>Libero creates a program that is ready to compile and run. The dialog
will halt with an error message since we don't supply any events beyond the
initial Ok.</LI>
<LI>There are some standard modules: a main entry point of some kind,
Initialise-The-Program, Get-external-event, and Terminate-The-Program.</LI>
<LI>Libero adds a module stub for each action that you use in your
dialog.</LI>
<LI>The program relies heavily on source-local variables.  I.e. variables
that are global to all functions in the source file, but not visible to other
source files.  This can be disturbing to some people, but is a natural
consequence of the way Libero restructures your program.  It actually works
quite well, as we'll see later.</LI>
</UL></P>

<P>The basic C program consists of a number of standard pieces:
<UL>
<LI><TT>Main</TT> - passes control to the Libero generated code.  In some
languages, such as the C program above, it must also copy any arguments into
variables that can be accessed by other modules.</LI>
<LI><TT>Initialise-The-Program</TT> - initial sanity checks, then usually
passes an Ok event to the dialog.  We do this with the line:<BR>
<PRE>the_next_event = ok_event;</PRE></LI>

<LI><TT>Terminate-The-Program</TT> - halts the dialog by passing it a
Terminate event.  Generally this is the last action that the dialog executes,
so it is also a convenient place to shut log files, etc.</LI>
<LI><TT>Get-External-Event</TT> - the dialog calls this implicitly if it
didn't get an event from any of the modules it executed.</LI>
</UL></P>


<H2><A NAME="TOC12">Example of a C/C++ Comment Stripper</A></H2>

<P>One of the classic uses for state machines is in scanning and parsing text
- e.g. source programs.  People usually do this with tools like lex and yacc,
or using languages like Awk and Perl that are good at pattern matching.  When
I explain that Libero uses a state-machine model, some people think that I am
asking them to use Libero in place of the honoured tools I just mentioned.
The next example shows why this is not the case.</P>

<P>Here I present a C/C++ comment stripper based on an example by Robert
Martin (who makes a finite-state machine code generator for C++).  In C and
C++, comments are either enclosed between '/*' and '*/', or begin with '//'
until the end of the line.  This program removes all comments from a C or C++
source program, with some checking for errors like an unmatched '/*':</P>

<PRE>
!
!   C/C++ comment stripper dialog
!
!   Written:    95/03/30  Pieter Hintjens &lt;ph@imatix.com&gt;
!   Revised:    96/05/15  Frans Janssens &lt;frans@sebb.bel.alcatel.be&gt;
!
-source=stripper.c
-schema=lrschema.c

After-Init:
    (--) Ok                         -&gt; Outside-Comment
          + Get-Char-From-Input
    (--) Error                      -&gt;
          + Terminate-The-Program

Outside-Comment:
    (--) Quote                      -&gt; Skip-Quote
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) Slash                      -&gt; After-Slash
          + Get-Char-From-Input
    (--) Star                       -&gt; Outside-Comment
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) NewLine                    -&gt; Outside-Comment
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) Other                      -&gt; Outside-Comment
          + Put-Char-To-Output
          + Get-Char-From-Input

Skip-Quote:
    (--) Quote                      -&gt; Outside-Comment
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) Slash                      -&gt; Skip-Quote
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) Star                       -&gt; Skip-Quote
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) NewLine                    -&gt; Skip-Quote
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) Other                      -&gt; Skip-Quote
          + Put-Char-To-Output
          + Get-Char-From-Input

After-Slash:
    (--) Quote                      -&gt; Outside-Comment
          + Put-Slash-To-Output
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) Slash                      -&gt; Skip-Eoln
          + Get-Char-From-Input
    (--) Star                       -&gt; Skip-Comment
          + Start-New-Comment
          + Get-Char-From-Input
    (--) NewLine                    -&gt; Outside-Comment
          + Put-Slash-To-Output
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) Other                      -&gt; Outside-Comment
          + Put-Slash-To-Output
          + Put-Char-To-Output
          + Get-Char-From-Input

Skip-Eoln:
    (--) Quote                      -&gt; Skip-Eoln
          + Get-Char-From-Input
    (--) Slash                      -&gt; Skip-Eoln
          + Get-Char-From-Input
    (--) Star                       -&gt; Skip-Eoln
          + Get-Char-From-Input
    (--) NewLine                    -&gt; Outside-Comment
          + Put-Char-To-Output
          + Get-Char-From-Input
    (--) Other                      -&gt; Skip-Eoln
          + Get-Char-From-Input

Skip-Comment:
    (--) Quote                      -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) Slash                      -&gt; After-Comment-Slash
          + Get-Char-From-Input
    (--) Star                       -&gt; After-Comment-Star
          + Get-Char-From-Input
    (--) NewLine                    -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) Other                      -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) End-Of-File                -&gt;
          + Signal-Unterminated-Comment
          + Terminate-The-Program

After-Comment-Star:
    (--) Quote                      -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) Slash                      -&gt; Outside-Comment
          + Other-If-Nested-Comment
          + Get-Char-From-Input
    (--) Star                       -&gt; After-Comment-Star
          + Get-Char-From-Input
    (--) NewLine                    -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) Other                      -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) End-Of-File                -&gt;
          + Signal-Unterminated-Comment
          + Terminate-The-Program

After-Comment-Slash:
    (--) Quote                      -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) Slash                      -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) Star                       -&gt; Skip-Comment
          + Start-New-Comment
          + Get-Char-From-Input
    (--) NewLine                    -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) Other                      -&gt; Skip-Comment
          + Get-Char-From-Input
    (--) End-Of-File                -&gt;
          + Signal-Unterminated-Comment
          + Terminate-The-Program

Defaults:
    (--) Exception                  -&gt;
          + Terminate-The-Program
    (--) End-Of-File                -&gt;
          + Terminate-The-Program
</PRE>

<P>This is what Libero generates when I compile the dialog:</P>
<PRE>
/*===========================================================================*
 *                                                                           *
 *  stripper.c  description...                                               *
 *                                                                           *
 *  Written:    96/12/31    Pieter Hintjens <ph@imatix.com>                  *
 *  Revised:    96/12/31                                                     *
 *                                                                           *
 *  Skeleton generated by LIBERO 2.20 on 31 Dec, 1996, 14:00.                *
 *===========================================================================*/

#include "prelude.h"                    /*  Universal include file           */
#include "stripper.d"                   /*  Include dialog data              */

/*- Function prototypes -----------------------------------------------------*/

/*- Global variables used in this source file only --------------------------*/

static int
    feedback;                           /*  Feedback for calling program     */

static char
    *some_param;                        /*  Example of parameter             */

/********************************   M A I N   ********************************/

int my_funct (char *p_some_param)
{
    feedback = 0;                       /*  No errors so far                 */
    some_param = p_some_param;          /*  Local copy of parameters         */

#   include "stripper.i"                /*  Include dialog interpreter       */
}

/*************************   INITIALISE THE PROGRAM   ************************/

MODULE initialise_the_program (void)
{
    the_next_event = ok_event;
}

/***************************   GET EXTERNAL EVENT   **************************/

MODULE get_external_event (void)
{
}

/*************************   TERMINATE THE PROGRAM    ************************/

MODULE terminate_the_program (void)
{
    the_next_event = terminate_event;
}

/**************************   GET CHAR FROM INPUT   **************************/

MODULE get_char_from_input (void)
{
}

/***************************   PUT CHAR TO OUTPUT   **************************/

MODULE put_char_to_output (void)
{
}

/**************************   PUT SLASH TO OUTPUT   **************************/

MODULE put_slash_to_output (void)
{
}

/***************************   START NEW COMMENT   ***************************/

MODULE start_new_comment (void)
{
}

/**********************   SIGNAL UNTERMINATED COMMENT   **********************/

MODULE signal_unterminated_comment (void)
{
}

/************************   OTHER IF NESTED COMMENT   ************************/

MODULE other_if_nested_comment (void)
{
}
</PRE>

<P>This is the completed comment-stripper program:</P>
<PRE>
/*=========================================================================*
 *                                                                         *
 *  stripper.c  C/C++ comment stripper                                     *
 *                                                                         *
 *  Written:    96/12/31    Pieter Hintjens <ph@imatix.com>                  *
 *  Revised:    96/12/31                                                   *
 *                                                                         *
 *=========================================================================*/

#include "prelude.h"                    /*  Standard include file          */
#include "stripper.d"                   /*  Include dialog data            */


/*- Global variables used in this source file only ------------------------*/

static int
    thisch,                             /*  Current character              */
    comment_level,                      /*  Comment nesting level          */
    feedback;                           /*  Feedback for calling program   */

int main (void)
{
    feedback = 0;                       /*  No errors so far               */
#   include "stripper.i"                /*  Include dialog interpreter     */
}

/************************   INITIALISE THE PROGRAM   ***********************/

MODULE initialise_the_program (void)
{
    the_next_event = ok_event;
}

/*************************   GET CHAR FROM INPUT   *************************/

MODULE get_char_from_input (void)
{
    thisch = getchar ();
    switch (thisch)
      {
        case '"':   the_next_event = quote_event;         break;
        case '/':   the_next_event = slash_event;         break;
        case '*':   the_next_event = star_event;          break;
        case '\n':  the_next_event = newline_event;       break;
        case EOF:   the_next_event = end_of_file_event;   break;
        default:    the_next_event = other_event;
      }
}

/**************************   PUT CHAR TO OUTPUT   *************************/

MODULE put_char_to_output (void)
{
    putchar (thisch);
}

/*************************   PUT SLASH TO OUTPUT   *************************/

MODULE put_slash_to_output (void)
{
    putchar ('/');
}

/**************************   START NEW COMMENT   **************************/

MODULE start_new_comment (void)
{
    comment_level++;                    /*  We have a new comment          */
}

/***********************   OTHER IF NESTED COMMENT   ***********************/

MODULE other_if_nested_comment (void)
{
    comment_level--;                    /*  We've finished a comment       */
    if (comment_level &gt; 0)              /*    but maybe it was nested...   */
        raise_exception (other_event);
}

/*********************   SIGNAL UNTERMINATED COMMENT   *********************/

MODULE signal_unterminated_comment (void)
{
    fprintf (stderr, "stripper: unterminated comment\n");
    feedback = 1;                       /*  Return code for main program   */
}

/***************************   GET EXTERNAL EVENT   ************************/

MODULE get_external_event (void)
{
}

/************************   TERMINATE THE PROGRAM   ************************/

MODULE terminate_the_program (void)
{
    the_next_event = terminate_event;
}
</PRE>

<P>The program works and is easily understood.  However, because the dialog
is really too low-level, it makes the problem seem more complex than it
actually is.  In fact, this is a good example of the kind of problem that I
would never use Libero for.  I would write this as a straight C program.</P>

<P>Moral: Libero is not worth the overhead on trivial problems.  By contrast,
when you are wrestling with a really complex problem, Libero lets you break
it down into smaller, simpler pieces, and keep the central logic in a single
place.</P>

<P>Second moral: simplicity can be deceptive.  It often happens that the
first stab at a problem produces a simple solution, as here.  However, when
the solution meets reality, reality often gets its own way and imposes all
kind of nasty complexities that mess-up the clean solution.  A dialog is very
good at handling such things.  So, it can be better to start-out on the right
footing and use a dialog from the start.</P>


<H2><A NAME="TOC13">Example of Parsing An Arithmetic Expression</A></H2>

<P>The next example is for an arithmetic expression evaluator that was
originally proposed by <A href="mailto:leif@ibm.net">Leif Svalgaard</A>.  The program works out the
value of a string like '2-SQR(2)*1.414'.  The program translates easily into
most of the languages I've worked with so far, from assembler to Basic to C
and COBOL.</P>

<P>Here I describe the program <TT>lrcalc.c</TT>, which is a subroutine that
I use in Libero.  You can find the source for this program along with the
other sources for Libero in the <A href="/pub/libero/src/lrsrc232.zip">lrsrc.zip</A> archive.  There are also
versions of this program in various languages in the
<A href="/pub/libero/example/expr.zip">examples archive</A>.</P>

<P>Lrcalc chops the expression into tokens, each representing an operand
(numbers) or operator.  The operators are classified as:
<UL>
<LI>term operator: '+' and '-'</LI>
<LI>factor operator: '*' and '/'</LI>
<LI>left-parenthesis: '('</LI>
<LI>right-parenthesis: ')'</LI>
<LI>end-mark: indicates the end of the expression.</LI>
</UL></P>

<P>There are various ways of parsing an expression like this; <TT>lrcalc</TT>
combines two basic techniques: push-down stacks for the operands and
operators, and states to indicate how tokens are handled.  Each state accepts
specific tokens and rejects others. For instance, at the start of the
expression, an operator like '*' is not valid.  When a state accepts an
operand or operator, it adds it to the appropriate stack.  When a state
stacks an operator, it evaluates any previous operators that have the same,
or higher priority.  '*' and '/' have a higher priority than '+' and '-'.</P>

<P>Operators like '(' and ')' are placeholders that group parts of the
expression together with a higher priority.  Operators like '*', '/', '+',
and '-' are binary operators that take two values off the operand stack, do
their work, and place the result back on the stack.</P>

<P>The program basically takes tokens one by one, stacks and evaluates them
according to the priority rules, until it reaches the end of the expression.
To make this clean, the program places a special end-mark token at the end of
the expression when it starts.  When it reaches the end-mark, it evaluates
any remaining operators, which leaves the result of the expression sitting on
the stack.</P>

<PRE>
After-Init:
    (--) Ok                         -&gt; Expecting-Initial
          + Get-Next-Token
    (--) Error                      -&gt;
          + Terminate-The-Program
</PRE>

<P>The two states Expecting-Initial and Expecting-Operand are similar, except
that the first allows End-Mark while the latter does not.  I.e. we accept an
empty expression (End-Mark in Expecting-Initial), but don't accept an
expression that ends when we expect an operand:</P>

<PRE>
Expecting-Initial:
    (--) Term-Op                    -&gt;
          + Allow-Signed-Number
          + Signal-Invalid-Token
          + Terminate-The-Program
    (--) Number                     -&gt; Expecting-Operator
          + Stack-The-Number
          + Get-Next-Token
    (--) Left-Par                   -&gt; Expecting-Operand
          + Stack-The-Operator
          + Get-Next-Token
    (--) End-Mark                   -&gt;
          + Terminate-The-Program
</PRE>

<P>These two states handle signed numbers (e.g.. -12, +100) by accepting
Term-Op tokens (ie. '+' or '-') so long as these are stuck to a following
number.  The module Allow-Signed-Number gets the next token, and if this is a
number, it kicks the dialog into accepting a number in the same state.  It
does this using an exception event called Number:</P>

<PRE>
Expecting-Operand:
    (--) Term-Op                    -&gt;
          + Allow-Signed-Number
          + Signal-Invalid-Token
          + Terminate-The-Program
    (--) Number                     -&gt; Expecting-Operator
          + Stack-The-Number
          + Get-Next-Token
    (--) Left-Par                   -&gt; Expecting-Operand
          + Stack-The-Operator
          + Get-Next-Token
</PRE>

<P>After stacking an operand, the dialog expects an operator:</P>

<PRE>
Expecting-Operator:
    (--) Term-Op                    -&gt; Expecting-Operand
          + Unstack-Ge-Operators
          + Stack-The-Operator
          + Get-Next-Token
    (--) Factor-Op                  -&gt; Expecting-Operand
          + Unstack-Ge-Operators
          + Stack-The-Operator
          + Get-Next-Token
    (--) End-Mark                   -&gt;
          + Unstack-All-Operators
          + Unstack-If-End-Mark
          + Terminate-The-Program
   (--) Right-Par                  -&gt; Expecting-Operator
          + Unstack-All-Operators
          + Unstack-If-Left-Par
          + Get-Next-Token
</PRE>

<P>The Defaults state lists all tokens.  If a state does not explicitly
accept some token, the Defaults state handles it: it issues an error message
and terminates the program:</P>

<PRE>
Defaults:
    (--) Number                     -&gt;
          + Signal-Invalid-Token
          + Terminate-The-Program
    (--) Term-Op                    -&gt;
          + Signal-Invalid-Token
          + Terminate-The-Program
    (--) Factor-Op                  -&gt;
          + Signal-Invalid-Token
          + Terminate-The-Program
    (--) End-Mark                   -&gt;
          + Signal-Token-Missing
          + Terminate-The-Program
    (--) Left-Par                   -&gt;
          + Signal-Invalid-Token
          + Terminate-The-Program
    (--) Right-Par                  -&gt;
          + Signal-Invalid-Token
          + Terminate-The-Program
    (--) Exception                  -&gt;
          + Terminate-The-Program
</PRE>

<P>The expression parsing technique shown here is easy to elaborate to
support variables, functions, other operators, strings, etc.  It is true that
some languages have easier ways of evaluating expressions, but this technique
is easily applied to languages like assembler and COBOL that do not have
support from tools like lex and yacc.</P>


<H2><A NAME="TOC14">Dialogs For Dummies</A></H2>

<H3><A NAME="TOC15">Explain It Like I'm 5 Years Old</A></H3>

<P>You've gone through all the examples and still you can't
quite get your mind around the concepts?  Don't worry, this is
normal.  It's like anything new -- it takes a while for your
brain to change shape.</P>

<P>So far, we have seen fairly realistic examples - depending on
how much booze was consumed for lunch, admittedly.  Sometimes it
helps to look at the entire issue from other angles.  So, here
is a small piece extracted from our Liberzine
<EM><A href="index2.htm#liberetto">Liberetto I/3</A></EM>.  Our correspondent, Big
Al, writes...</P>

<BLOCKQUOTE>
<P>iMatix asked me to write a small piece on how I learnt to use
Libero. After a short discussion about fees and expenses, I
quickly learnt to use Libero, applying the principle 'imagine I
am a child of 5'.  "No, don't try to interest me in plastic
bunnies.  Explain Libero to me." "Right, kids, get into two
groups.  You lot sit there, and you lot sit there.  Now, we'll
play a game..."</P>

<P>The first group of kids sit around a large playing board,
marked with a large 'START' square, and paths that twist around.
Some end in the Snake Pit, others die horrible deaths in the
Bathtime Room.  Just one path leads through all the dangers to
the Cookie Room.  The aim of the game is to get to the Cookie
Room, of course.  Let's look at the START square.  You are in a
small room.  Twisty passages lead left, right, north, and south.
You are holding a candle.  There is a small breeze coming from
the west.  The floor is blue.  Blue?  Yeah.</P>

<P>The second group of kids have three or four funny dice.  Each
die is a different colour, with size sides.  The blue die says
'Left', 'Right', 'Forwards', 'Backwards', 'Roll Again', and
'Bathtime'.  The red die says 'Fight', 'Run', 'Get Eaten', 'Eat
it', 'Order a taxi', and 'Bathtime'.  (You gotta know how to
*really* scare a five-year old.)</P>

<P>The rules are simple.  The first group of kids just shout a
colour. The second group of kids roll the matching die and -
after puzzling over the letters a while - shout out what the die
says.  Each time the die rolls, the first group move their piece
along the board to a new square.</P>  <P>You start to see the
balance of the game.  Neither group of children controls the
game, it moves step-by-step until the piece wins or loses. The
two groups only communicate by exchanging colours and results.
Well, this is Libero.  Colours are actions, results are events.
And that was the easiest lunch I ever earned.</P>
</BLOCKQUOTE>

<H3><A NAME="TOC16">A Bit Of Animation</A></H3>

<P>Sometimes it's hard to mentally connect the dialog to the
running program.  On the one hand you have the dry, pedantic
dialog with its events and states; on the other hand you have a
real live program that is actually <EM>doing</EM> something.  A
good way to join these two concepts is the <TT>-animate</TT>
option.  Use this when you generate code, and you get a display
of the dialog steps a program runs through.</P>

<P>The examples archive has a set of programs that work out the
value of arithmetic expressions.  This is what one of these
looks like as it works out the value of '1 + 1':</P>

<PRE>
After-Init:
    (--) Ok-Event                       We just started
          + Get-Next-Token                so we collect the next token

Expecting-Operand:
    (--) Number-Event                   We got the first '1'
          + Stack-The-Number            Stick it on the operand stack
          + Get-Next-Token                and get the next token

Expecting-Operator:
    (--) Term-Op-Event                  We got the '+'
          + Unstack-Ge-Operators        Do any higher-priority operators
          + Stack-The-Operator            then stick the '+' on the stack
          + Get-Next-Token                and get the next token

Expecting-Operand:
    (--) Number-Event                   We got the second '1'
          + Stack-The-Number            Stick it on the operand stack
          + Get-Next-Token                and get the next token

Expecting-Operator:
    (--) End-Mark-Event                 We hit the end of the expression
          + Unstack-All-Operators       Do all operators on the stack
          + Unstack-If-End-Mark         The operand stack holds the result
2                                       This is displayed by the program
          + Terminate-The-Program       End and return to the caller
</PRE>


<H2><A NAME="TOC17">Frequently Asked Questions</A></H2>

<P><EM>Why is the documentation in HTML format?</EM></P>

<P>We originally wrote the documentation using Microsoft Word
5.0 for MS-DOS, a fine word-processor that satisfied our
minimalist preferences for a long time.  Our target was
PostScript on paper.  Since those old days, we have changed our
minds a little about the best way of moving information from our
brains to yours.  We like the idea of keeping the help 'on-line'
in the literal sense.  Effectively, this means using HTML.  Now,
our approach is two-fold.  Firstly, we use HTML as the basic
language.  It's excellent for the job.  Secondly, we have
structured the documentation to suit.  This means that the
Libero documentation is less of a traditional paper book, and
more of a hyper-linked text database. Our guiding principle is
that you can take the entire HTML kit and put it on a local hard
disk, then browse, print, and copy that.  There are HTML
browsers available for all of our target platforms, and the
market is competitive and generally free.</P>

<P><EM>Why do you not supply binary kits for UNIX (any
longer)?</EM></P>

<P>We used to do this...  It just does not work very well, and
takes a lot of work.  It is generally not a good idea to use an
executable built under one version of an operating system on an
other.  Sometimes, but not always, you can go from an earlier
version of <EM>Brandix</EM> to a later version, but never
contrarywise.  With some exceptions (see next question) it's a
snap to install Libero by compiling the source kit.  At iMatix
we tend to do this for all our products today.</P>

<P><EM>I get compile errors on Sun Sparc</EM></P>

<P>For some bizarre reason, possibly related to the struggle of
commercialism over utility, this system does not come with an
ANSI C compiler as standard.  People often install GNU C, which
works well, but there can be conflicts between the Sun header
files and GNU runtime library. In theory we fixed these in
version 2.11 (by changing prelude.h).  If you still get compile
errors, send us a listing and we will see what is wrong.  On
some Sparc systems, the ANSI C compiler is called acc.</P>

<P><EM>I get compile and link errors and then <TT>lr</TT>
dies</EM></P>

<P>If you get compile errors (not warnings), or link errors,
don't try to run the resulting executable.  Or if you do, don't
expect reasonable behaviour, unless one can describe a dump as
'reasonable'.</P>

<P><EM>Does Libero support language </EM>X<EM>?</EM></P>

<P>If it is not on the list, the answer is 'not yet'.  There are
several possible reasons why we have not yet built a schema for
a particular languages:
<UL>
<LI>We hate the language and would not touch it with a 10 ft
pole.</LI>
<LI>We don't have a compiler or interpreter for that language;
</LI>
<LI>We don't consider the language to be worth it;</LI>
<LI>We don't see a good way to implement dialogs in the
language;</LI>
<LI>We have not had time yet.</LI>
</UL>
<P>So far no language has fallen into the first category, while
many have fallen into the last.</P>

<P><EM>How do I add support for language </EM>X<EM>?</EM></P>

<P>If it is a language that we can easily get hold of, we'll add
support more or less on demand.  For instance, if anyone
actually comes and asks for an Ada implementation, we could
install GNU Ada and get an Ada schema up and running in a few
days.  The bizarre thing is we don't even ask for money for the
whole business.  Whatever.</P>

<P>If the language is one that we cannot get freely -- and we're
not in the habit of buying expensive compilers just for fun --
then we can try to build a schema 'by remote control'.  In this
scenario, you provide us with the specifications of the
language, sample programs, etc.  We'll do the schema and send
you programs to test.  Eventually we get a solid version.  This
can work surprisingly well.</P>

<P>Finally, you can bite the bullet (more like a 10mm shell) and
learn how Libero's schema language works.  You can then write
the schema yourself.  Honestly, if you need to write a schema
from scratch, this is probably the hard way.</P>

<P><EM>I want to customise a schema</EM></P>

<P>Firstly, be sure that you can't get what you need by adding
code to the template file.  Then, drop us a line to tell us what
you want so we can try to figure-out a way of supporting it in
the standard schemas. As a last resort, copy the schema and
change it.  If your changes are cosmetic, we'd try to convince
you to accept our cosmetics.  Some projects have such unusual
needs that a new schema is the only practical answer.  Be
warned, however: if you make your own version of a schema, you
lose the benefits of any future improvements or fixes to the
schema.</P>

<P><EM>I don't understand Libero</EM></P>

<P>This is quite normal.  Anyone who understands Libero the
first time is either lying, has a serious mental problem, or is
not a real programmer. The concept is simple, and easy to
explain to a lay-person.  But if you have spent long enough
coercing computers to do your bidding, you get a certain
world-view of how things work.  Libero does things differently.
Keep trying, and after a week or so you will suddenly see it.
</P>

<P><EM>How do I print-out the documentation?</EM></P>

<P>Probably the best approach is to download the
<A href="/pub/libero/doc/lrfull.zip">big file</A> that contains the entire documentation
kit.  Load this into your favourite browser and press 'Print'.
Alternatively you can try to convert the HTML file into a word
processor format, load it up and print it like that.  This is a
field that is changing rapidly, for the better.</P>

<P><EM>Why is there no UNIX Makefile?</EM></P>

<P>There are several reasons for this: Libero is a portable
product, and makefiles are specific to UNIX; we don't really
like makefiles; we prefer to try a more 'intelligent' approach
when possible; we don't have the time to make and maintain
makefiles for all the possible UNIX platforms.  Ok, none of
these reasons is enough by itself, but you get the idea.  Libero
is simple to build and install, so the lack of a makefile is not
a serious handicap.</P>

<P><EM>Libero for Windows crashes</EM></P>

<P>There was a bug in previous releases of Libero for Windows.
It was caused by a missing Windows font.  Install the latest
version.</P>

<P><EM>Why can't I get the files by ftp?</EM></P>

<P>Our site does not provide anonymous ftp for reasons of speed
and of security.  If you do not have http access, send us an
e-mail telling us what system you work with, or which files you
want, and we'll send them by e-mail back to you.</P>

<P><EM>Is there a mirror site?</EM></P>

<P>Not to our knowledge, though we have seen a few older
versions of Libero floating around.</P>

<P><EM>How do I build a mirror site?</EM></P>

<P>Our website does not (currently) support anonymous ftp, nor
other protocols for automatic mirror-site replication.  If you
want to set-up a mirror site for Libero, <A href="mailto:info@imatix.com">contact us</A> and
we'll work-out the principles.</P>

<P><EM>I want to repackage Libero for a CD-ROM</EM></P>

<P>You do not need our permission, but you must respect our
license terms. If your CD-ROM is for a specific platform, e.g.
Linux, we suggest that you include the binary kit for that
platform, the source kit, and the HTML kit. If you have space on
the CD-ROM, supply the HTML tree uncompressed: then people can
follow the links through their Internet connection to pick-up
other files such as examples.</P>

<P>If your CD-ROM is a source collection, you may want to
provide the Windows version of Libero, the source kit, and the
HTML kit.</P>

<P><EM>Why is </EM>Liberetto<EM> so silly?</EM></P>

<P>Everything is relative.  When the first issue of
<EM>Libermanga</EM> comes out, you'll see what we mean.
Seriously, though, we try to maintain a harmonious balance
between education, entertainment, humour, and subtle irony.
When that fails, we just go for silly.</P>

<P><EM>Is there a 'pretty printer' for my dialogs?</EM></P>

<P>Yes, since version 2.20 - use the -pretty option.</P>

<P><EM>How is a Libero FSM different from a 'classic'
FSM?</EM></P>
<UL>
<LI>Libero lets you specify several actions in a transition; a
classic FSM usually only lets you specify one action.</LI>
<LI>Some FSMs allow an 'entry action', a 'transition action',
and an 'exit action'.  These are all equivalent, as far as we
can see, and since Libero allows multiple actions, you can do
the same in Libero.</LI>
<LI>You describe your FSM as a textual diagram, not as a
numbered graph, as is usually the case.</LI>
<LI>Libero stores the FSM in a table and interprets this.  This
is one of several approaches; some classic FSMs use goto's;
others use a large switch statement.  The table + interpreter
approach is a reasonable compromise between space and speed and
simplicity.</LI>
<LI>Libero has the concept of an <EM>exception event</EM>.</LI>
<LI>Libero has the concepts of <EM>super-states</EM> and
<EM>default</EM> states</EM>.</LI>
</UL>

<P><EM>I want my FSM to handle an event queue in realtime</EM>
</P>

<P>Use our SMT kernel; this is our solution for event-handling
in realtime programs, multi-FSM constructions, communications
servers, internet servers, etc.</P>

<P><EM>Are Libero FSMs good for writing parsers?</EM></P>

<P>Well, in principle yes, but in practice there are better
tools.  For instance, Perl is great for writing ad-hoc parsers.
If you are working with formal grammars, there are tools that
will generate parsers for such grammars.  It is usually
pointless to re-invent the wheel by hand.  There are exceptions.
For instance, sometimes the grammar cannot be formalised enough
to work with a parser generator.  Sometimes a generated parser
is too slow.  In these cases, a Libero FSM may produce excellent
results.</P>

<P><EM>I downloaded a Libero .zip file to my UNIX, then ftp'd
it to my PC - now PKUNZIP won't extract it</EM></P>

<P>When you ftp a binary file like a .zip file, always set ftp
to binary mode (use the command 'bin').  Sometimes ftp is
configured like this by default, but more often it assumes you
want to transfer text files.  So, it expands tabs, converts
line-ending, and such, generally turning a .zip file into
garbage along the way.</P>

<P><EM>Is there a Libero mailing list?</EM></P>
<P>No, not yet.  Each month we send out Liberetto, our fanzine.
We include the most interesting mail we get, news about changes
to Libero, forthcoming releases, etc.  This is the closest thing
to a discussion group so far.  We intend one day to create a
usenet news group.  A public mailing list may be one step on the
way.  We welcome any suggestions.</P>

<P><EM>Libero for Windows complains 'ASSOC.VBX Not Found'</EM>
</P>

<P>To use Libero for Windows you need to download TWO .zip
files; <TT>lrmswin.zip</TT> and <TT>lrmswins.zip</TT>.  The
second contains 'system files' including various .vbx files.  To
download an update you only take the first .zip file. This saves
download time.</P>

<H1><A NAME="TOC18">Installing Libero</A></H1>


<H2><A NAME="TOC19">Getting Your Hands On Libero</A></H2>

<H3><A NAME="TOC20">Availability and Distribution</A></H3>

<P>Libero is available as a ready-to-run binary kit for various platforms.
You can also download the source kit and re-compile Libero for a specific
platform.

<P>Libero is free software, distributed according to the terms of the
<A href="/html/gnugpl.htm">GNU General Public License (GPL)</A>.  This means that
you are free to change and re-distribute Libero, even charge for it, but you
must always make the source code available under the same terms.

<P>The Windows version of Libero is also free software, but does not fall
under the GNU GPL.  You can't get the sources, mostly because it would be
embarrassing.

<P>If you have trouble accessing the iMatix site, or getting your hands on
Libero for any reason, send an e-mail to us at <A href="mailto:info@imatix.com">imatix.com</A>
and we will provide you with Libero by e-mail, or on diskette.  We have
used the portable Zip and GNU gzip+tar formats for all archives.

<H3><A NAME="TOC21">Documentation</A></H3>

<P>The Libero User's Guide consists of a set of HTML files that you can
browse on-line or download and browse locally.  You can download:
<UL>
<LI><A href="/pub/libero/doc/lrhtml.zip">A set of HTML files</A> - 190Kb.
<LI><A href="/pub/libero/doc/lrfull.zip">One big HTML file</A> - 73Kb.
</UL>

<H3><A NAME="TOC22">Deinstalling Libero</A></H3>

<P>We made Libero as simple as possible to deinstall.  It does not change
anything in system files, and keeps its own files in the single directory
where you installed it.  To de-install Libero, delete this directory.


<H2><A NAME="TOC23">What You Will Need</A></H2>

<P>To install Libero, you'll need:
<OL>
<LI>Either the binary kit for your system, or the <A href="/pub/libero/src/lrsrc232.zip">source kit</A>
which is also available as a <A href="/pub/libero/src/lrsrc232.tgz">GNU gzipped file</A>.
<LI>Infozip <A href="http://quest.jpl.nasa.gov/Info-Zip/Info-Zip.html">unzip</A> to extract the archives.  If you do not have
Infozip unzip for your UNIX or VAX system, you can unzip the files under
MS-DOS or Windows and upload them individually.  Use PKzip version 2.04g or
later or a compatible unzip program.
<LI>Alternatively, for UNIX source installation, GNU gunzip.
<LI>For UNIX or VMS installations from the source kit, an ANSI C compiler to
compile Libero.
<LI>A compiler or interpreter for the language that you want to work in. You
don't necessarily need this on the machine where you want to run Libero; it's
possible to work on one system, then transfer the results to another for
compiling and running.
<LI>The Libero documentation kit.
</OL>


<H2><A NAME="TOC24">Installing Libero for UNIX</A></H2>

<P>To install Libero for a UNIX system you must compile it.  Download one
of:

<PRE>
<a href="/pub/libero/src/lrsrc230.tgz">lrsrc230.tgz </a>   144126 97/07/14 14:20:26  gzip/tar archive
<a href="/pub/libero/src/lrsrc230.zip">lrsrc230.zip </a>   192945 97/07/14 14:20:08  zip archive
<a href="/pub/libero/src/lrsrc231.tgz">lrsrc231.tgz </a>   151603 98/11/27 10:30:10  gzip/tar archive
<a href="/pub/libero/src/lrsrc231.zip">lrsrc231.zip </a>   207869 98/11/27 10:29:10  zip archive
<a href="/pub/libero/src/lrsrc232.tgz">lrsrc232.tgz </a>   148536 99/05/13 14:46:40  gzip/tar archive
<a href="/pub/libero/src/lrsrc232.zip">lrsrc232.zip </a>   201295 99/05/13 14:46:16  zip archive
</PRE>

<P>You'll need an ANSI C compiler.  The source kit comes with build scripts
for UNIX and VMS.  To unpack the sources in portable Zip format, load
<TT>lrsrc232.zip</TT> into a working directory and extract the
contents using <TT>unzip</TT>:

<PRE>
    $ mkdir temp
    $ mv lrsrc232.zip temp
    $ cd temp
    $ unzip -a lrsrc
    $ chmod +x install
</PRE>

<P>To unpack the sources in GNU gzip format, load
<TT>lrsrc232.tgz</TT> into a working directory and extract the
contents using <TT>gunzip</TT> and <TT>tar</TT>:

<PRE>
    $ mkdir temp
    $ mv lrsrc232.tgz temp
    $ cd temp
    $ gunzip lrsrc
    $ tar -xvf lrsrc232.tar
</PRE>

<P>The <TT>install</TT> script is smart enough to detect the UNIX system and
use appropriate compile switches. It proposes various options: start with
(b)uild to compile and (maybe) install Libero.  You can run Libero as soon as
it is built; you don't need to install it into an install directory.  Run
<TT>install</TT> like this (you may need root access if you want to install
Libero into a system directory):

<PRE>
    $ su root
    $ chmod +x install
    $ ./install
</PRE>

<P>The <TT>install</TT> script uses the Korn shell, which is not available on
all UNIX systems.  You can use <TT>install.sh</TT> instead, which uses the
Bourne shell.  On some UNIX systems the Bourne shell does not support
functions; then this script will not run either.  If you have trouble running
<TT>install</TT> or <TT>install.sh</TT>, try something like this (it's what
the scripts basically try to do):

<PRE>
    $ cc <I>&lt;switches&gt;</I> lr.c lr????.c -o lr
    $ cp lr lrmesg.txt lrschema.* installdir
    $ rm *.o
</PRE>

<P>The <I>&lt;switches&gt;</I> are the compiler switches that do an ANSI C
compile.  Type <TT>man cc</TT> for details.

<P>Once you have built the <TT>lr</TT> file, and installed it and its data
files, you should check that the install directory is on the <TT>PATH</TT>
definition.  By default the install script proposes <TT>/usr/local/bin</TT>
as an install directory.

<P>If you do not like placing non-executable files into a /bin directory, you
can place <TT>lr</TT> there, and the remaining files (<TT>lrmesg.txt,
lrschema.*</TT>) into another directory.  This second directory may be on the
PATH or be defined in another, arbitrary environment variable; for example,
<TT>LRPATH</TT>.  You must then tell Libero which variable you are using with
a command-line switch like: <TT>-path=LRPATH</TT>.  You can also specify the
path literally: <TT>-path=/usr/local/tools/bin</TT>. Place such global
options in the <TT>lr.ini</TT> file.

<P>Note that on UNIX, all filenames are lower-case.  If you do not manage to
install Libero on a non-MS-DOS system, you can always run Libero on a PC,
then upload the generated code.  You can also run Libero for Windows or
MS-DOS, accessing your UNIX disk via a network.  This works pretty well for
many people.

<P>System-specific notes:
<UL>
<LI>Linux, gcc: compile switches: <TT>-pedantic -O2 -Wall -c</TT>.
<LI>HP/UX: compile switches: <TT>-Aa</TT>.
<LI>SunOS, SunC: compile switches: <TT>-O -vc -Xa</TT>.
<LI>SunOS, gcc: see Linux.
<LI>AIX 3.2.5: default compiler switches.  <TT><TT>LIBPATH</TT></TT> must be
set to<TT><TT>/usr/lib</TT></TT> when you link <TT>lr</TT>, or you'll get an
error at runtime.  This appears to be normal compiler behaviour.
</UL>


<H2><A NAME="TOC25">Installing the MS Windows Kit</A></H2>

<P>Libero for Windows is an interactive editor that provides a drool-proof
interface to the standard Libero code generation functions.  It runs under
Windows 3.1, 95, NT, and other common varieties.  The Libero for Windows kit
comes in two parts:
<OL>
<LI><A href="/pub/libero/bin/lrmswin.zip">lrmswin.zip</A> - Libero for Windows editor.  Contains the software and
associated files.
<LI><A href="/pub/libero/bin/lrmswins.zip">lrmswins.zip</A> - Libero for Windows system runtime.  You only need to
download this once.  Contains 'system' files.
</OL>

<P>Basically, <TT>lrmswin.zip</TT> contains the latest version and will
change whenever a new release is made.  <TT>Lrmswins.zip</TT> is unlikely to
change often.  The split is made to save you download time.

<P>Install as follows:
<UL>
<LI>Create a directory like <TT>C:\LRWIN</TT> and go there, or go to your
existing Libero directory.
<LI>Unzip <TT>lrmswin.zip</TT>.  This extracts a series of files, including
the main executable - <TT>LRWIN.EXE</TT>.  Note that the standard Libero
files - e.g.. schema files - are supplied in both versions of Libero
(portable and Windows), so if you have a more recent version of portable
Libero, or have customised schemas, take care when you install Libero for
Windows.
<LI>You must download and unzip <TT>lrmswins.zip</TT> at least once.  This
holds a number of <TT>.VBX</TT> and <TT>.DLL</TT> files.  You can leave these
where they are, or move them to your Windows system directory.  If you leave
them alone, it's easier to de-install Libero afterwards.
<LI>Open the file manager and drag the <TT>LRWIN.EXE</TT> program into a
program group or onto your speedbar if you use such.
<LI>Double-click on the Libero icon and load in your current dialog file.
The installation directory does not need to be on your path, so long as the
'Path' option in the <I>Options</I> screen points to this directory.
</UL>

<P>Libero for Windows is compatible with standard portable Libero; they share
the same files and general ideas about the world.  However, Libero for
Windows is not distributed under the same terms: it is free software, but you
may not modify it, and you cannot get hold of the sources.


<H2><A NAME="TOC26">Installing the MS-DOS Kit</A></H2>

<P>Download <A href="/pub/libero/bin/lrmsdos.zip">Libero for MS-DOS</A>.  This was compiled using
Borland Turbo-C.

<P>Create a new directory and extract <TT>lrmsdos.zip</TT> there.  This
creates the set of files that you need to run Libero under MS-DOS.  You must
either add this new directory to your path, or copy certain Libero files into
a directory (like <TT>C:\UTILS</TT>) which is already on your path:
<UL>
<LI><TT>LR.EXE</TT> - the executable Libero program
<LI><TT>LRMESG.TXT</TT> - the message file
<LI><TT>LRSCHEMA.*</TT> - the code-generation schemas
<LI><TT>LR.INI</TT> - default initialisation file
</UL>

<P>The<TT> LR.EXE</TT> file is not too large, and runs in a modest amount of
memory. If you are writing really enormous dialogs, you may want to rebuild
<TT>LR.EXE</TT> from the source kit using a DOS extender.  I haven't tried
this, and I have not heard of anyone running out of memory with Libero under
MS-DOS.  The 32-bit <A href="lrdoc.htm#lros2">OS/2 version</A> should run under MS-DOS.  You may
also want to try the 32-bit MS-DOS version if you run Windows NT or 95.


<H2><A NAME="TOC27">Installing the 32-bit MS-DOS Kit</A></H2>

<P>Download <A href="/pub/libero/bin/lrdos32.zip">Libero for MS-DOS</A>.  This was compiled
with Microsoft VC 4.0 as a 'console application'.

<P>Create a new directory and extract <TT>lrdos32.zip</TT> there.  This
creates the set of files that you need to run Libero under Windows 95 or
Windows NT in a DOS box.  You must either add this new directory to your
path, or copy certain Libero files into a directory (like <TT>C:\UTILS</TT>)
which is already on your path:
<UL>
<LI><TT>LR32.EXE</TT> - the executable Libero program
<LI><TT>LRMESG.TXT</TT> - the message file
<LI><TT>LRSCHEMA.*</TT> - the code-generation schemas
<LI><TT>LR.INI</TT> - default initialisation file
</UL>
<P>LR32.EXE supports long filenames and mixed-case filenames.

<A NAME="lros2">&nbsp;</A>

<H2><A NAME="TOC28">Installing the OS/2 Kit</A></H2>

<P>Download <A href="/pub/libero/bin/lros2.zip">Libero for OS/2</A> [117Kb].  This was compiled
with EMX 0.9b, using GCC.  Ewen says:

<BLOCKQUOTE>
The binary was compiled using EMX 0.9b (I think it should run fine with
EMX 0.9c, the latest version), using:

gcc -O2 -Zomf -s lr????.c -o lr.exe

As usual people will need the EMX runtime libraries to run the executable;
they're on most OS/2 ftp sites including hobbes.nmsu.edu, ftp.cdrom.com,
and ftp.leo.org.  Since quite a few programs need them, most people have
them installed already.  It should run okay with the EMX 0.9b runtime
libraries and the EMX 0.9c runtime libraries (which are the current ones).
<BR>

Oh, BTW, it'll probably run okay under DOS as well (as a 32-bit
version) with either the EMX.EXE extender (included in the runtime DLL
package mentioned above), or with RSX (I think it's called) which is a
DMPI equivilent for EMX.EXE.  Being a 32-bit version it might solve
ram-cramp issues if anyone is having problems.</BLOCKQUOTE>

<P>Create a new directory and extract <TT>lros2.zip</TT> there.  This
creates the set of files that you need to run Libero under OS/2.  You must
either add this new directory to your path, or copy certain Libero files into
a directory (like <TT>C:\UTILS</TT>) which is already on your path:
<UL>
<LI><TT>LR.EXE</TT> - the executable Libero program
<LI><TT>LRMESG.TXT</TT> - the message file
<LI><TT>LRSCHEMA.*</TT> - the code-generation schemas
<LI><TT>LR.INI</TT> - default initialisation file
</UL>


<H2><A NAME="TOC29">Installing the VAX/VMS Kit</A></H2>

<P>To install Libero for Digital OpenVMS you can either download the
<A href="/pub/libero/bin/lrvax.zip">binary kit for VAX/VMS</A> or the source kit, if you have
a C compiler (Vax C, Dec C, or GNU gcc).  Currently we do not have a
binary kit for Alpha OpenVMS - you must build from the source kit.
To rebuild from the source kit, download <A href="/pub/libero/src/lrsrc232.zip">/pub/libero/src/lrsrc232.zip</A> and place it
into a working directory.  You need the unzip tool to extract it:

<PRE>
    $ set def [.temp]
    $ create/dir []
    $ ... upload LRSRCxxx.ZIP into this directory
    $ unzip -a -o lrsrc232
    $ @buildvax.txt
</PRE>

<P>If you do not have Unzip on your VMS system, consider installing it - it
is well worth the bother.  You can also unzip the sources on a PC and upload
them from there.

<P>The file <TT>BUILDVAX.TXT</TT> is a procedure that compiles and links
Libero.  Run it (<TT>@buildvax.txt</TT>).  Then copy these files into an
installation directory which is world-readable:
<UL>
<LI><TT>LR.EXE</TT> - the executable Libero program
<LI><TT>LRMESG.TXT</TT> - the message file
<LI><TT>LRSCHEMA.*</TT> - the code-generation schemas
<LI><TT>LR.INI</TT> - default initialisation file
</UL>

<P>To run Libero your <TT>LOGIN.COM</TT> file must include these lines:

<PRE>
    $ define/nolog path "<I>directory</I>";  ! name of Libero directory
    $ lr :== $<I>$disk</I>[<I>directory</I>]lr.exe
</PRE>


<H2><A NAME="TOC30">Installing the Examples</A></H2>

<P>Each example archive is self-complete, and comes with a small
<TT>readme.txt</TT> file.

<P>This is the contents of the examples directory:
<PRE>
<A href="/pub/libero/example/acms.zip">acms.zip     </A>    49027 96/10/20 19:51:02  ZIP archive
<A href="/pub/libero/example/complete.zip">complete.zip </A>   275949 96/12/28 21:53:00  ZIP archive
<A href="/pub/libero/example/config.zip">config.zip   </A>    12030 96/10/20 19:51:20  ZIP archive
<A href="/pub/libero/example/erbot.zip">erbot.zip    </A>    20748 96/10/20 19:51:28  ZIP archive
<A href="/pub/libero/example/expr.zip">expr.zip     </A>   101786 96/12/28 21:51:56  ZIP archive
<A href="/pub/libero/example/htmlpp.zip">htmlpp.zip   </A>   128504 98/11/08 18:54:38  ZIP archive
<A href="/pub/libero/example/install.zip">install.zip  </A>    11276 96/10/20 19:51:48  ZIP archive
<A href="/pub/libero/example/picture.zip">picture.zip  </A>    37806 96/10/20 19:51:54  ZIP archive
<A href="/pub/libero/example/stripper.zip">stripper.zip </A>     6944 96/10/20 19:52:02  ZIP archive
<A href="/pub/libero/example/tcpip.zip">tcpip.zip    </A>    16960 96/10/20 19:52:08  ZIP archive
</PRE>


<H2><A NAME="TOC31">Configuring and Testing Libero</A></H2>

<P>When you have installed Libero, run the <TT><B>lr</B></TT> command without
arguments.  This should show a page of help.

<P>Try this from the installation directory, then from a different directory.
If Libero cannot find its message file, you'll get an error like this:

<PRE>
C:\CTOOLS\LIBERO&gt;lr
LIBERO v2.32 (c) 1991-97 iMatix <http://www.imatix.com>
Options file 'lr.ini' not found.
Cannot find message file lrmesg on 'PATH' path.
</PRE>

<P>Type 'path' if you're working on MS-DOS, 'echo $PATH' if you're on UNIX,
or 'show log path' if you're on VMS.  Check that the installation directory
is on the path.

<P>Next, type the command 'lr -settings' to see what settings Libero is
using:

<PRE>
C:\CTOOLS\LIBERO&gt;lr -settings
LIBERO v2.32 (c) 1991-97 iMatix <http://www.imatix.com>
  Option settings for command:
    animate  . . .: No
    author . . . .: Your Name
    check  . . . .: Yes
    compress . . .: No
    defaults . . .: defaults
    dpath  . . . .: -
    generate . . .: Yes
    help . . . . .: No
    idle . . . . .: Yes
    initial  . . .: lr.ini
    option . . . .: -
    path . . . . .: PATH
    plusd  . . . .: No
    pretty . . . .: No
    schema . . . .: lrschema.c
    settings . . .: Yes
    sort . . . . .: Yes
    source . . . .: -
    stats  . . . .: No
    stubs  . . . .: Yes
    style  . . . .: plain
    trace  . . . .: No
</PRE>

<P>You can change any of these default option settings by editing the lr.ini
file, or by placing the settings you want in your dialog file.

<H1><A NAME="TOC32">Using Libero</A></H1>


<H2><A NAME="TOC33">Running The lr Program</A></H2>

<P>To run Libero, type the 'lr' command like this:</P>

<PRE>
    $ lr [options] dialogname...
</PRE>

<P>Libero is a code generator.  It works as follows: you write a dialog
description, and Libero generates (by default) C code to execute the dialog.
This C code contains (a) various tables and definitions, and (b) the FSM
engine.  If necessary, Libero also generates (c) a skeleton C program to wrap
the whole thing together.  When you change your dialog (many times during
program development), Libero re-generates (a) and (b) and any new bits
needed in (c).</P>

<P>When you run the lr command, Libero goes through these steps:
<UL>
<LI>It displays a start-up message and checks that it can find its message
file.  If this fails, there is a problem with the PATH definition.</LI>
<LI>It reads the dialog file(s) you specified.</LI>
<LI>For each dialog file, it run the language-specific schema file.  The
schema generates code, the exact mechanics depending on the language in
question:<BR>
1. If necessary, the schema creates a skeleton program.<BR>
2. If necessary, the schema adds empty module 'stubs' to the end of the
program for each module in the dialog.  You will often want to rearrange
these in a meaningful order.<BR>
3. The schema generates the tables and code required to run your dialog
program.  These go into include files or other code modules.</LI>
</UL></P>

<P>The standard C schema is LRSCHEMA.C.  This schema creates two include
files, with the dialog's name, but extensions '.D' and '.I'.  The first of
these contains the DATA, the second the INTERPRETER.  Other schemas (for
other programming languages) have different conventions.</P>

<P>Dialogs have the extension .l, though you can be bloody-minded and use
other extensions.  On systems that support long filenames, the name can be up
to 128 characters long, including the extension.  I seriously recommend that
you stick to eight-character filenames for anything that is remotely useful.
When I were a lad, filenames were one hex digit.  To create a new dialog,
take skeleton.l and copy it.  I recommend that you give a dialog the same
name as the program it drives.  For instance, a source file myprog.c would
use a dialog  myprog.l.  Sometimes I append a 'd' to the name to make the
filename (without extension) unique.  Then, for instance, the .bak files that
my editor creates carry different names.</P>


<H2><A NAME="TOC34">The Dialog File Syntax</A></H2>

<P>This is the skeleton.l file - it is a useful starting point for new
dialogs:</P>

<PRE>
!
!   myprogd.l   Dialog description for myprog.c
!
!   Written:    yy/mm/dd  My name
!   Revised:    yy/mm/dd
!
!   Syntax:  '!' comment header
!            -option[=value]
!            [ state-name ':' [ '&lt;'Superstate-Name'&gt;' ]...
!                  [ '(' event-nbr ')' event-name [ '-&gt;' next-
state ]
!                  [ '+' module-name ]... ]... ]...
!
-source=myprog

After-Init:
    (--) Ok                         -&gt;
          +
    (--) Error                      -&gt;
          + Terminate-The-Program

Defaults:
    (--) Exception                  -&gt;
          + Terminate-The-Program
</PRE>

<P>The dialog file defines a series of <EM>states</EM>: the first state in
the dialog is the starting state, and the remaining states can come in any
order.  You cannot define the same state twice.  A state carries a name,
which is purely for your (the reader's) information.  A state allows one or
more <EM>events</EM>.  The ordering of events within a state is not
important.  Each event looks like this:
<PRE>
    (--) Event-Name                 -&gt; Next-State-Name
          + Module-To-Execute
          + Module-To-Execute
          ...
</PRE>
The module list is executed when that event occurs in the state.  The module
list can be empty.  The next state name can be
blank, meaning 'the current state'.  Otherwise the next state name refers to
another state within the dialog, excluding the initial starting state.</P>

<P>The module names correspond to functions, blocks, procedures, etc. in the
program.  Since various languages and individuals like different conventions
for naming modules, Libero always uses Names-Like-This, which may refer to
pieces of code labelled 'NamesLikeThis', 'names_like_this', 'NAMES-LIKE-
THIS', etc.</P>

<P>The program always refers to events by adding the suffix '-Event'.  Thus,
if a dialog refers to an event 'Ok', the program will refer to 'Ok-Event',
allowing for whatever name-mashing the language imposes.</P>

<P>A program never refers to state/next-state names.  These are there only to
make the dialog more readable, and useful.  You could, if you wanted to,
refer to states as 'S1', 'S2', 'S3', instead of 'Expecting-Token', 'Have-
Number', 'Have-String'.   Hahaha.  I've seen people doing this.</P>

<P>An event name '$other' is taken to mean 'all other events'.   This
is shorthand for typing all other events in the dialog: any event you
did not already handle in the state gets the '$other' handling.</P>

<P>Note that:
<UL>
<LI>You can put a comment anywhere, starting with '!' until the end of the
line.  I advise you to put comments on lines of their own; the pretty
printing function in Libero will then work better.</LI>
<LI>You can put options before the first state, several per line or one per
line.  If you put several on one line, separate them by spaces as you do on
the command line.</LI>
<LI>You need one or more spaces between words.  Libero is not fussy about the
amount of blank space or line breaks between words.  However, I recommend the
layout above as it is easy to read, and if you use Libero for Windows, it
will rewrite the dialog in this format in any case.</LI>
<LI>Use an editor that lets you cut and paste lines easily, and that works in
overwrite mode.  This is the easiest way to write dialogs.</LI>
<LI>If you intend to move dialog files between systems (MS-DOS, UNIX,
VMS,...) don't use tabs.  These don't align the same on different
systems.</LI>
<LI>It is quite okay to make a sloppy dialog; the -pretty option in Libero
will straighten things out.  However, a good programmer should need this.
</LI>
</UL></P>


<H2><A NAME="TOC35">Libero Options</A></H2>

<P>Like most command-line programs, lr accepts various options. These control
things such as the language that Libero generates, the filenames it uses,
etc.</P>

<P>You can supply an option in various ways:
<UL>
<LI>Type the option when you run lr.  This is good for options that you use
now and then.</LI>

<LI>Place the option in the dialog file itself (at the start of the file,
anywhere before the first state).  This is good for options that are specific
to that dialog file.</LI>

<LI>Place the option in a global initialisation file, usually called lr.ini,
somewhere on the path.  This is good for options that you want for all your
work.</LI>
</UL></P>

<P>It sometimes gets a little complex to remember which option is active,
especially if you put the same option in various places. For instance you
could put '-nocheck' in lr.ini, then run the <TT>lr</TT> command with the '
check' option.  Which takes precedence?  The answer is: it works like it
should.  This is a somewhat arrogant statement, so I'll explain:
<UL>
<LI>Each option has a default value, as explained below.  When Libero starts
up, this is the value.</LI>

<LI>Libero reads the <TT>lr.ini</TT> file and uses the options in that file.
These can change the default values.</LI>

<LI>Libero then looks at any options in the dialog file.</LI>

<LI>Libero looks at the lr command line and processes any options you typed
there.  Libero picks-up a -help option right away, as well as a -initial or
-path, since these affect which lr.ini file it reads.</LI>
</UL></P>

<P>If you are unsure of the options in effect for your dialog, run
<TT>lr</TT> with the -settings option.  This displays the current options.
You can specify a Libero option in various forms:<BR>

<DL>
<DT>-option</DT>
<DD>Normal usage.</DD>
<DT>-option=value</DT>
<DD>Option takes value.</DD>
<DT>-option:value</DT>
<DD>Also okay.</DD>
<DT>-option="value"</DT>
<DD>Don't convert value to lowercase.</DD>
<DT>-option:'value'</DT>
<DD>The same as above.</DD>
<DT>-nooption</DT>
<DD>switch off true/false option.</DD>
<DT>-option=no</DT>
<DT>-option=false</DT>
<DD>The same as above.</DD>
</DL>

<P>You can abbreviate an option name to 3 or more characters.
Option values are converted to lower-case unless you place them
in single or double quotes. Some options take values; others are
true/false options.  These is a summary of the options that lr
accepts:</P>

<PRE>
Option            Explanation                        Default

-animate          include animation code             -noanimate
-author=name      include animation code             ="My Name"
-check            generate full runtime checks       -check
-compress         compress generated tables          -compress
-defaults=state   name of defaults state             =defaults
-dpath=variable   path for dialog and ini files      ="PATH"
-generate         generate output code               -generate
-help             show this information              -nohelp
-idle             indicate idle modules              -noidle
-initial=file     read options from file             =lr.ini
-option=list      define generation options          none
-path=variable    path variable for schema files     ="PATH"
-plusd            enforce 'source+D' naming rule     -noplusd
-pretty           pretty-print dialog file           -nopretty
-schema=file      schema for code generation         =lrschema.c
-settings         show option settings per file      -nosettings
-sort             add module stubs alphabetically    -sort
-source=file      program for dialog                 name of dialog
-stats            show dialog statistics             -nostubs
-stubs            generate stubs for new modules     -stubs
-style=plain      naming style: some_module_name     -style=plain
-style=caps       naming style: SomeModuleName
-style=headline   naming style: Some_Module_Name
-style=title      naming style: Some_module_name
-style=normal     naming style: Some-Module-Name
-style=cobol      naming style: SOME-MODULE-NAME
-trace            trace code generation to list file
</PRE>

<P>And now in detail:
<UL>
<LI><B>-[no]animate</B> - include or exclude animation code.  If
you use this option, the schema will generate code that displays
each new state, event, and action as the dialog runs.  This is
useful for debugging.  The default is -noanimate.</LI>

<LI><B>-author</B> - Libero uses this value when it creates a
new file for you.  Put the string in quotes to include spaces:
-author='My Name'.  On the MS-DOS command line, you must type
this (two sets of quotes): "-author='My name'".  The default is
"Your Name".</LI>

<LI><B>-[no]check</B> - generate full runtime checks.  If you
use this option, the schema will generate code that checks for
invalid or missing events while the program runs.  Keep this
option unless you are sure it is slowing down a crucial dialog.
The default is -check.</LI>

<LI><B>-[no]compress</B> - compress the generated tables.
Currently, this means:removing unused states.  You can disable
this using the nocompress option.  The default is
-compress.</LI>

<LI><B>-defaults=state</B> - the name of the Defaults state.
This state serves to collect events that can happen in any other
state; you can make the dialog smaller and simpler by placing
these into the Defaults state.  The default is "Defaults".</LI>

<LI><B>-dpath=variable</B> - Libero uses this path to search for
the lr.ini file and the dialog file.  You can use the name of an
environment variable (a logical variable under VMS) or a literal
path.  If the case is important, enclose it in quotes.  For
example, under MS-DOS: -dpath='LRPATH'.  Libero always searches
the current directory first.  The default is empty, in which
case Libero uses the -path value.</LI>

<LI><B>-[no]generate</B> - generate output code.  If you want to
check the dialog but not generate any output, use -nogen.  The
default is -generate.</LI>

<LI><B>-[no]idle</B> - indicate idle modules.  Libero lists any
modules in your program that are not referenced in the dialog.
This can happen when you change a dialog.  The default is
-noidle.</LI>

<LI><B>-initial=file</B> - tells Libero to read options from
some specific file instead of lr.ini.  You can use this option
on the command line only. The default is "lr.ini".</LI>

<LI><B>-option:name=value</B> - supply a specific option value
to a schema. This allows the schema to generate code
conditionally, or fill-in specific values.  The 'name' is a
variable defined in the schema; the 'value' overrides any
default that the schema specifies.  The 'value' can be a full
expression, including references to other schema variables.</LI>

<LI><B>-path=name</B> - Libero uses this path to search for its
message file and the schema used to generate code.  You can use
the name of an environment variable (a logical variable under
VMS) or a literal path.  If the case is important, enclose it in
quotes.  For example, under MS-DOS: -path='LRPATH'.  Libero
always searches the current directory first.  The default is
"PATH" (in uppercase).  See also -dpath.</LI>

<LI><B>-[no]plusd</B> - enforce the "source+D" naming rule.  The
default is -noplusd.</LI>

<LI><B>-[no]pretty</B> - rewrite the dialog, aligning it using
the standard Libero conventions.  This can work nicely.  Your
original dialog is saved with the extension .bak.  Does not
generate any code.  The default is -nopretty.</LI>

<LI><B>-schema=file</B> - schema for code generation.  If you
override this default, be sure to specify the file extension.
The default is "lrschema.c".</LI>

<LI><B>-[no]settings</B> - show option settings for each file
processed.  The default is -nosettings.</LI>

<LI><B>-[no]sort</B> - output new module stubs in sorted order.
Depending on your preferences, you may want to keep modules in
sorted order or natural order.  The default is -nosort.</LI>

<LI><B>-source=file</B> - program that uses the dialog.  By
default the name of the dialog, unless you use -plusd option, in
which case it is the name of the dialog minus an obligatory
'D'.</LI>

<LI><B>-[no]stats</B> - report the number of states, events, and
modules in the dialog.  The default is -nostats.</LI>

<LI><B>-[no]stubs</B> - generate stubs for modules which are
referenced in the dialog but do not (yet) exist in the program.
The default value for this option is -stubs.  If you use
-nostubs, you will have to make new module stubs by hand.  So
leave -stubs on.</LI>

<LI><B>-style={plain|caps|heading|title|normal|cobol}</B> -
style for module and event names.  The default is 'plain'.  You
can use this to adapt Libero's output to your preferred
programming style; do not change halfway through a project
unless you like doing major cleanups.</LI>

<LI><B>-[no]trace</B> - create a report file that traces the
code generator's output.  This is useful if you are writing or
changing a schema, and cannot get it to work.  The trace file is
called <EM>dialog</EM>.lst.  The default is -notrace.</LI>
</UL></P>


<H2><A NAME="TOC36">Using Exceptions</A></H2>

Exceptions are basically a tool to reduce the size of a dialog.
Instead of defining an extra state to handle a decision (typically
the Ok/Error outcome of some work), you assume it's Ok, and carry on
with the next action module directly.  If it's Error, you raise an
exception, which is like a jump to that event in the same state.  Any
module in progress is completed, but any further modules are not
executed by the dialog manager.

It's often useful to put exception events into the Defaults state,
since certain kinds errors can occur in any state.  So you can raise
an exception in any code, and know that it will be handled the same
way, in the Defaults state.  Sometimes we override such central
handling by defining specific handling for an exception event in a
specific state.

Exceptions are thus used to make small control steps within a state
(error handling is just one specific example).  Such control steps
can be used for any purpose.

Overusing exceptions leads to impenetrable dialogs.

<P>Exceptions are a powerful technique that make your dialog leaner and
meaner.  In a typical dialog many actions do some work that may result in an
error condition.  For instance, an action that reads some data from a file
may discover that the file is no longer accessible due to a 'hard' error
(protection, disk crash, insufficient memory,...).  Without exceptions, the
only way to handle such possibilities is to define additional states - for
instance, 'after-reading-data', that check the outcome of each action with a
questionable outcome.</P>

<P>This quickly leads to dialogs with dozens of states that serve only to
keep track of these minority cases.  In the majority of cases, the errors
never happen.  This means that the main logic of the dialog can get diluted
by all the extraneous states.  With exceptions, you write the dialog as
though errors were incidental. When an error happens, you treat it as a
special case, as an 'exception'.  Otherwise, the dialog carries on
normally.</P>

<P>Most real dialogs use exceptions, sometimes heavily, for two reasons:
<OL>
<LI>Exceptions are a good way to handle errors.</LI>
<LI>Exceptions can make a complex dialog simpler.</LI>
</OL></P>

<P>A module raises an exception by setting the variable Exception-Raised to a
'true' value.  The module then supplies an event in The-Exception-Event.
Quite often I use an event called 'Exception' when I use an exception event
to handle fatal errors. This is how we raise an exception using an event
called Exception-Event in various languages:</P>

<P>C and C++:</P>
<PRE>
    exception_raised = TRUE;
    the_exception_event = exception_event;
</PRE>

<P>80x86 assembler:</P>
<PRE>
    mov exception_raised,1
    mov the_exception_event,exception_event
</PRE>

<P>Korn Shell:</P>
<PRE>
    exception_raised=TRUE
    the_exception_event=$exception_event
</PRE>

<P>COBOL:</P>
<PRE>
    MOVE "YES" TO EXCEPTION-RAISED
    MOVE EXCEPTION-EVENT TO THE-EXCEPTION-EVENT
</PRE>

<P>Visual Basic:</P>
<PRE>
    exception_raised = True
    the_exception_event = exception_event
</PRE>

<P>In most languages (except COBOL) Libero provides a function or macro
'Raise-Exception' that does the above.  See the later sections on using
Libero in each language for details.</P>

<P>The dialog normally executes all the action modules for an event-in-state,
one by one, then switches to the next state for the event.  An exception
interrupts this flow. The dialog handles exceptions in two steps:
<OL>
<LI>It checks Exception-Raised after executing each module.  It this variable
has become 'true', it stops and checks the value of The-Exception-Event.</LI>
<LI>It looks for The-Exception-Event in the current state (or Defaults), then
executes the action modules for that event.  These modules can in turn raise
an exception.</LI>
</OL></P>

<P>When a module raises an exception, the dialog does not care what the next
state was supposed to be.  This is no longer important, since the exception
event will determine its own next state.</P>

<P>Libero also allows a short-cut: if the exception event is the same as the
current event, you don't need to supply it.  If you just set Exception-Raised
but not the event, the dialog loops back to the same event in the same state.
Honestly, I don't use this very often.  I prefer to separate exception events
from 'normal' events.</P>

<P>Take the example of three actions which the dialog executes in series.
First, it reads some data from a file.  Then it parses and converts the data.
Lastly, it writes the data to another file.  Each of these actions has a
normal outcome, and possible exceptional outcomes (error during reading,
invalid data, error during writing, etc.).  If we write the dialog without
exceptions, we need these three states:</P>

<PRE>
Before-Reading:
    (--) Ok                         -&gt; After-Reading
          + Read-Data-From-Input
    (--) Error                      -&gt;
          + Terminate-The-Program

After-Reading:
    (--) Ok                         -&gt; After-Parsing
          + Parse-and-Convert-Data
    (--) Error                      -&gt;
          + Terminate-The-Program

After-Parsing:
    (--) Ok                         -&gt; Another-State
          + Write-Data-To-Output
          + ...
    (--) Error                      -&gt;
          + Terminate-The-Program
</PRE>

<P>In this case, Read-Data-From-Input does something like this (I use C as
the language):</P>

<PRE>
MODULE read_data_from_input (void)
{
    if (read_from_file (file, input) != NULL)
        the_next_event = ok_event;
    else
        the_next_event = error_event;
}
</PRE>

<P>By using an exception event (here, Error), we can collapse the three
states into a single state:</P>

<PRE>
Before-Reading:
    (--) Ok                         -&gt; Another-State
          + Read-Data-From-Input
          + Parse-and-Convert-Data
          + Write-Data-To-Output
          + ...
    (--) Error                      -&gt;
          + Terminate-The-Program
</PRE>

<P>Read-Data-From-Input now does this:</P>

<PRE>
MODULE read_data_from_input (void)
{
    if (read_from_file (file, input) == NULL)
        raise_exception (error_event);
}
</PRE>

<P>Some hints about using exception events:
<OL>
<LI>Don't over-use exceptions.  What you gain from a more compact dialog you
can loose in unclear logic.  Remember that exceptions should be used for
error handling and special cases, not for primary logic.</LI>
<LI>Choose good names, and use one exception event for the same purpose
everywhere.  For instance, use an exception event Fatal-Error to indicate a
fatal i/o error that causes the dialog to halt.</LI>
<LI>The Defaults state is an ideal place to handle exceptions which may occur
in many places.  However, do place specific exception handling in any state
where it is useful.</LI>
</OL></P>


<H2><A NAME="TOC37">Using The Defaults State</A></H2>

<P>You can define a single Defaults state in any dialog.  You use this state
to simplify dialogs.  Often, the same event can happen in many states, with
the same effect.  Typically, you want to handle a fatal error at any point by
displaying a message and halting the program.</P>

<P>Rather than repeating the event and its (identical) actions in every state
where the fatal error may happen, place it in Defaults.  If the event ever
happens, Libero looks in the current state first.  If it cannot find the
event there it looks in the Defaults state.  The Defaults state is ideal for
error exception events that require central handling.</P>

<P>After processing the actions for the event, the dialog sets the next state
as follows: if the specified next state is empty, it returns to the original
state.  If some next state is specified, it goes to that state.</P>

<P>When you use a Defaults state, the generated code for your dialog does not
get smaller.  It will actually get a little larger.  But your dialog source
code can usually be simplified, and this is always a good idea.</P>


<H2><A NAME="TOC38">Using Sub-Dialogs</A></H2>

<P>Libero supports a simple state call/return mechanism.  This lets you build
sub-dialogs that are called from other places in the dialog.  In the
'calling' state, use the action Dialog-Call to call the sub-dialog state:</P>

<PRE>
Calling-State:
    (--) Ok                         -&gt; Sub-State
          + Do-Some-Normal-Work
          + Dialog-Call
    (--) Return                     -&gt; Next-State
          + Continue-After-Call
</PRE>

<P>The Return event controls what happens when the sub-state returns.  The
Return event can be in the same state, or in the Defaults state.</P>

<P>The sub-dialog can consist of one or many states.  You should probably use
some kind of naming convention to indicate that these states go together.  At
some point, the sub-dialog uses the action Dialog-Return.  This ends the
sub-dialog and continues in the calling state with the Return event.</P>


<H2><A NAME="TOC39">Using Super-States</A></H2>

<P>Some dialogs have a lot of states that are similar except for small
differences, like Expecting-Initial and Expecting-Operand above.  We can
write these in a more compact way using a shorthand technique called
super-states.  We put the super-state name between '&lt;' and '&gt;' after
the state name:</P>

<PRE>
Expecting-Initial: &lt;Expecting-Operand&gt;
    (--) End-Mark                   -&gt;
          + Terminate-The-Program
</PRE>

<P>The state inherits the events in the super-state, if they are not already
defined.  In the above example we say that Expecting-Initial inherits events
from Expecting-Operand, and also handles the End-Mark event.</P>

<P>A super-state can itself be based on super-states, to any level.  My
advice is: use super-states with care to simplify large dialogs.  Don't
exaggerate.  Some more points about super-states:
<UL>
<LI>You can think of super-states as 'local defaults' states.</LI>

<LI>If a super-state is not used anywhere in the dialog, it is not included
in the generated code.</LI>

<LI>When a state inherits an event, it may change the 'next state' name.  If
this is blank, or refers to the super-state (which is semantically the same),
it is changed to be the name of the inheriting state.</LI>
</UL></P>


<H2><A NAME="TOC40">Using Templates</A></H2>

<P>The standard Libero schemas support templates.  This just means that you
can build a library of code that the generator will pull-in whenever you use
it in a dialog.</P>

<P>For example, let's say that you are working in a COBOL application where a
lot of programs need to do the same work in Initialise-The-Program:</P>

<PRE>
    MOVE LINKAGE-BLOCK TO OWN-LINKAGE-BLOCK
    PERFORM CHECK-LINKAGE-VALUES
    IF CURRENT-LANGUAGE = SPACES
        MOVE "ENGLISH" TO CURRENT-LANGUAGE
</PRE>

<P>You can either:
<UL>
<LI>Retype or copy this code into each new program you create. This is extra
effort for nothing.</LI>
<LI>Modify the standard schema.  This is also extra effort, not today, but
when the next release of Libero comes around.</LI>
<LI>Use a COPY book (an included file) for the common code.  This is okay if
the code is regularly changed, or large.  For many small pieces of code you
just get a terrible burden of managing lots of these COPY books.
<LI>Use a template.  Of course, this is the way to do it.</LI>
</UL></P>

<P>Let's say you make a file called TEMPLATE.cob.  This looks like this:</P>

<PRE>
&lt;Initialise-The-Program&gt;
    MOVE LINKAGE-BLOCK TO OWN-LINKAGE-BLOCK
    PERFORM CHECK-LINKAGE-VALUES
    IF CURRENT-LANGUAGE = SPACES
        MOVE "ENGLISH" TO CURRENT-LANGUAGE
&lt;END&gt;
</PRE>

<P>Now, when you build a new program, Libero magically includes
this code in the INITIALISE-THE-PROGRAM section.  This is how templates
work:
<UL>
<LI>Each schema looks for a template file with the same extension as the
schema.  If the template file does not exist, this is okay.</LI>

<LI>The schema 'pulls in' code at various points.  Again, if it cannot find
the code it's looking for, that is okay.</LI>

<LI>Each section in the template starts with a keyword between "&lt;" and
"&gt;" and ends in "&lt;END&gt;".  The schemas define a number of standard
section keywords: "&lt;HEADER&gt;" and "&lt;DATA&gt;", plus one section per
module.</LI>

<LI>The keywords are case-sensitive.  &gt;Get-next-token&gt; is not the same
as &gt;Get-Next-Token&gt;.  The second form is correct; the first will not
work.</LI>

<LI>The template can be in the current directory, or on the path.</LI>
</UL></P>

<P>The file template provides an example that you can use for your own
templates.</P>


<H2><A NAME="TOC41">Using Get-External-Event</A></H2>

<P>The Get-External-Event module is empty in most types of program, and very
important in other ones.  This module lets you centralise any kind of
interface to the outside world that collects events.  An example of this is
the <A href="lrdoc.htm#rover">Rover</A> subprogram we designed above.  The dialog explicitly
does a Wait-for-incoming-message before each new state. We can put this code
into Get-external-event, which makes the dialog simpler.</P>

<P>Here I also move all handling for Onhook to the Defaults state - assuming
that the Stop-Local-Tones module is safe to use at any time:</P>

<PRE>
After-Init:
    (--) Ok                         -&gt; Idle
          +
    (--) Error                      -&gt;
          + Terminate-The-Program

Idle:
    (--) Offhook                    -&gt; Dialing-First
          + Start-Dial-Tone
          + Reset-Dialed-Number
    (--) Request                    -&gt; Ringing
          + Start-Ringing-Local

Dialing-First:
    (--) Digit                      -&gt; Dialing-Next
          + Stop-Local-Tones
          + Have-Dialed-Digit
    (--) Whole-Number               -&gt; Seizing
          + Stop-Local-Tones
          + Send-Outgoing-Request

Dialing-Next:
    (--) Digit                      -&gt; Dialing-Next
          + Have-Dialed-Digit
    (--) Whole-Number               -&gt; Seizing
          + Stop-Local-Tones
          + Send-Outgoing-Request

Seizing:
    (--) Accept                     -&gt; Ringing
          + Start-Ringing-Remote
    (--) Busy                       -&gt; Seize-Failed
          + Start-Busy-Tone
    (--) Reject                     -&gt; Seize-Failed
          + Start-Reject-Tone

Seize-Failed:
    (--) Onhook                     -&gt; Idle
          + Stop-Local-Tones

Ringing:
    !  Events from local phone
    (--) Offhook                    -&gt; Talking
          + Stop-Ringing-Local
    (--) Onhook                     -&gt; Idle
          + Stop-Ringing-Remote
    !  Event from remote phone
    (--) Answer                     -&gt; Talking
          + Stop-Ringing-Remote

Talking:
    !  Event from local phone
    (--) Onhook                     -&gt; Idle
          + Send-Outgoing-Release
    !  Event from remote phone
    (--) Release                    -&gt; Idle
          + Start-Released-Tone

Defaults:
    (--) Onhook                     -&gt; Idle
          + Stop-Local-Tones
</PRE>


<H2><A NAME="TOC42">Efficiency</A></H2>

<H3><A NAME="TOC43">Efficiency of The Generated Code</A></H3>

<P>People sometimes ask of Libero: "But does it produce efficient programs?".
Bad grammar apart, this question gets a considered answer.  Usually I say:
"What do you mean by 'efficient'?", or "Does a hammer build a solid table?".
I have a practical definition of 'efficient': if a program is easy to write,
easy to maintain, does the job on time, and no-one has trouble with it, it's
efficient.  It's also unusual, but that is another soap-box.</P>

<P>When I wrote Libero, my true goal was to make programming easier and
safer, whatever the language.  This also gives me a convenient stock answer:
if you write a program using Libero, and you find that it runs too slowly,
you can rewrite it in a faster language quickly and cheaply.</P>

<H3><A NAME="TOC44">Efficiency of The Dialog</A></H3>

<P>First of all, the size of a dialog has only a slight relationship to the
speed of the program.  A very large program will load and maybe run slower
than a small one, but the program has to be a lot larger.</P>

<P>Secondly, adding a new state, event, or action module will make the
generated code larger.  If a dialog has 10 states, then a new event will add
20 words to the program size.  If a dialog has 50 states, then a new event
will add 100 words.  A dialog with 100 states and 100 events will use a
whopping 20,000 words of storage for its main tables.  It is possible to
compress large FSM tables, but I never had a problem that was so complex that
it was worth it.  It is a function that one could add to Libero in the
future. However, a program this complex is likely to be several tens of
thousands of lines long.</P>

<P>So, I generally tell people: if you make your dialog smaller, do it
because it is better design, not because it is more efficient.</P>


<H2><A NAME="TOC45">Care and Feeding of Dialogs</A></H2>

<H3><A NAME="TOC46">Style - Good, Bad, and Ugly</A></H3>

<P>Some of the worst dialogs that I have seen were written by people who were
trying to make their dialogs 'efficient'.  It is not easy to write elegant
and readable dialogs; it is a little like making pancakes: give the first one
to the dog.  I have some advice: ask a colleague to read the dialog and
explain how the program works.  If your colleague cannot understand
something, rewrite it.</P>

<P>The following extracts are from real-life dialogs that went wrong.  I
changed names and did some surgery to protect the guilty, and myself from
prosecution.  All I can say in defence of the authors was that these were
early works, and that they had too little training.</P>

<P>Example 1: the author tries to reduce the number of states by looping back
to the same state several times.  Then he (I know the lad, so I can safely
use the pronoun) compounds the sin by using event names that are specific to
the state:</P>

<PRE>
Valorisation:
    (--) Valori-Not-Ok              -&gt; Valorisation
          + Update-Valorisation
          + Get-Next-Valorisation
    (--) Valori-Ok                  -&gt; Valorisation
          + Process-Valorisation
          + Get-Next-Valorisation
    (--) Ok                         -&gt; Valorisation
          + Test-Valorisation
    (--) No-Valori                  -&gt; Valorisation
          + Get-Next-Valorisation
    (--) No-More                    -&gt; Transfer
          + Get-First-Transfer

Transfer:
    (--) Transf-Not-Ok              -&gt; Transfer
          + Update-Transfer
          + Get-Next-Transfer
    (--) Transf-Ok                  -&gt; Transfer
          + Process-Transfer
          + Get-Next-Transfer
    (--) Ok                         -&gt; Transfer
          + Test-Transfer
    (--) No-Transf                  -&gt; Transfer
          + Get-Next-Transfer
    (--) No-More                    -&gt;
          + Close-Data-Files
          + Terminate-The-Program
</PRE>

<P>This is the advice I gave:
<UL>
<LI>Don't use a single state when the design demands several states.  This
does not save space - since you have to invent more event names - it just
makes the dialog hard to understand.</LI>

<LI>Use exceptions to reduce the complexity of a dialog.</LI>

<LI>Don't use event names that are only meaningful in one state, like
'Transf-Not-Ok'.  This makes the code less reusable.  It also tightens the
binding between action modules and the state, which is makes it harder to
reuse action modules and change the dialog.</LI>

<LI>Use meaningful names for states.  The state is an important concept in
the design.</LI>

<LI>Use helpful names for the action modules.  Test-Transfer tells the reader
very little about what is happening.</LI>
</UL></P>

<P>Example 2: the author is struggling with a complex batch process.  At this
stage he has to do a whole series of actions, with one small difference
depending on the contents of a key field:</P>

<PRE>
After-Test-Key:
    (--) Key-Empty                  -&gt; Have-Order
          + Save-Current-Order-Record
          + Get-Contract-For-Order
          + Get-Company-For-Contract
          + Create-Invoice-Header
          + Update-Company
          + Save-Contract-Key
          + Call-Batch-012
          + Call-Batch-013
          + Get-Next-Order-Record
    (--) Key-Not-Empty              -&gt; Have-Order
          + Treat-For-Current
          + Save-Current-Order-Record
          + Get-Contract-For-Order
          + Get-Company-For-Contract
          + Create-Invoice-Header
          + Update-Company
          + Save-Contract-Key
          + Call-Batch-012
          + Call-Batch-013
          + Get-Next-Order-Record
</PRE>

<P>This was my advice (resisting the urge to say 'junk it!'):
<UL>
<LI>Don't be obsessed by detailed breakdowns of logic.  Perhaps the whole
series of steps above could be better bundled into two modules:
Process-Order-Record and Get-Next-Order-Record.</LI>

<LI>Don't copy large chunks of code like this; it creates a maintenance
problem.</LI>

<LI>The only difference between the two action lists is the extra action
Treat-for-Current (whatever that means).  It is quite okay to internalise
this step and have a module like Treat-for-Current-If-Key-Filled.  Don't
bring microdecisions up to the level of the dialog.</LI>
</UL></P>

<P>Example 3: the author has used some other design method to start with, and
then translated the result into a dialog.  The events have names like
'Case-1', 'Case-2', or 'Ok' and 'Not-Ok'.  I've seen this happen often, and
it never works.  If the project leader is not prepared to use a dialog as a
primary design method, there is no benefit in trying to translate another
design into a dialog.  You must in such cases rewrite the dialog cleanly.  A
dialog is primarily for a readership, and secondarily for the computer.
Ignore this at your peril: you will produce large, incomprehensible dialogs
that are error-prone and fragile.</P>

<P>This is an approach that is so common, and so wrong, that the warning
bears repeating: <EM>Do not try to mechanically convert existing designs into
dialogs.  It will not work.  You will make a fool of yourself.</EM></P>

<P>Often, this also applies to designs already expressed as state machines.
In one of the worst cases I ever saw, the culprit had mechanically converted
a set of state-machine based designs into dialogs.  The states were called
S1, S2, S3,... The events were called E1, E2, E3,...  The modules were called
M1, M2, M3,... This happened in 1986.  In January 1996 I watched someone
painfully maintain one of these programs, trying to understand what E4 in S3
actually meant.  Okay, I warned you.  Now back to the main story.</P>

<P>These are some more common problems:
<UL>
<LI>Dialog modules that explicitly set an event, like 'Set-Ok'.   We call
this a <EM>control shunt</EM>.  It usually indicates that the author has
confused the notion of <EM>state</EM> with the notion of <EM>action</EM>.  By
shunting to some specific state, the author says 'I want to be in this state
to do some specific work'.  Very rarely, this is a good way to write a
dialog.  99% of times, though, it is bad practice.  If you find yourself
doing a control shunt, change the dialog so you do the work in question
<EM>as early as possible</EM> in the dialog, thus generating an event which
you can handle neatly in the next state.</LI>
<LI>Dialogs that are broken into very many small states.  This usually means
that the designer has not figured-out how exceptions work.</LI>
<LI>Dialogs that use lots and lots of different event names.</LI>
</UL></P>

<H3><A NAME="TOC47">Choosing Names</A></H3>

<P>These are some guide-lines for names in a dialog:
<UL>
<LI>States: In-Some-State, After-Something, Before-Something,
Expecting-Something, Have-Some-Data.</LI>
<LI>Events: external actions: Help, Exit, Delete, Create,...
Internal conditions: Ok, Error, Locked, Fatal-Error, No-More;
Types: Number, String, Function,...</LI>
<LI>Modules: active statements: Delete-The-Record, Print-Current-
Invoice, Start-The-Transaction, Commit-All-Changes,...</LI>
</UL></P>

<P>A common beginner's mistake is to confuse events and modules, so that a
state has events called 'Delete-Record', 'Print-Record', and so on.  It can
help to remember that event names must be as general as possible without
losing meaning.</P>

<P>One helpful comparison is to think of events as push-buttons in a pop-up
window box.  Common events are 'Ok' and 'Cancel', 'Print', 'Delete', and
'Help'.  A push-button like 'Delete Next Record' is too specific.</P>


<H2><A NAME="TOC48">When To Use Libero</A></H2>

<P>Don't hammer screws, or vice-versa.  If a program is like a building, then
Libero is like an architectural design that automatically forms the
foundation and scaffolding.  In any programming language there are
directions and complexities where Libero is worth using.  Until you get
there, you'll be losing time.</P>

<P>As far as I can see, these are some typical cases where you will profit
from Libero:
<UL>
<LI>If you need to use some kind of pseudocode or other technique to document
the program.  Better to use a dialog - it will always be up to date.  Libero
lets you attach comments anywhere in the dialog.</LI>

<LI>If you are making designs that another programmer will implement (i.e.
you are doing 'analysis').  The programmer does not need to interpret your
design.  Libero will generate a prototype program (with empty stubs for all
modules), so you get feedback on your design right away.</LI>

<LI>If your program analyses text, and you don't have access to tools like
yacc.  It is harder to build a parser using a dialog than to use a parser
generator, but it is still a lot simpler than doing it by hand.  Libero lets
you build really large dialogs.</LI>

<LI>If your program is a communications handler with incoming and outgoing
messages.  A dialog is a perfect way of describing the handling for each
message.  We've used Libero for <EM>complex</EM>TCP/IP servers in this
way.</LI>

<LI>If your program controls a device.  A dialog is a perfect way of
describing the various states that a device can be in, with the handling for
events in each state.</LI>

<LI>If your program runs a complex task on a database; for example,
processing data from a series of tables depending on various criteria and
conditions.  A dialog shows the processing logic clearly, with a state for
each main point in the processing, and an event for each condition or type of
record.</LI>

<LI>If your program is 'just too damn complex'.  It is difficult to keep the
'main logic' separate from the details. Libero does this for you, and then
splits the detailed code into individual modules.  Your program is easy to
understand, easy to maintain, and easy to reuse.</LI>

<LI>If you have to make design a program in several languages, or if you have
people working in several languages.  Libero is language independent.</LI>

<LI>If you are working in some esoteric language that has no support from
third-party tools.  You can build a Libero schema for any language (or I'll
change Libero).</LI>
</UL></P>

<H1><A NAME="TOC49">Libero Examples</A></H1>


<H2><A NAME="TOC50">Libero 'install' Script for UNIX</A></H2>

<P>The source files for this package are in <A href="/pub/libero/example/install.zip">install.zip</A>.</P>

<P>This is a nice example of a UNIX script that is complex enough to warrant
a dialog.  The script shows a small menu, and does various things depending
on the choice:</P>

<PRE>
Libero installation script                       Version 2.20
-------------------------------------------------------------
This script installs or de-installs Libero on your Unix system.
If you are going to install into a system binary directory you
will need write-access to the system directory.  You can also
run Libero from the current directory.

UNIX system="aix", compiler="cc", options="-O2"
-------------------------------------------------------------

Choose an action:
  (b)uild Libero and optionally install
  (d)e-install Libero
  (c)lean-up current directory
  (q)uit

Choice:
</PRE>

<P>This is the dialog:</P>

<PRE>
-schema=lrschema.ksh

After-Init:
    (--) Ok                         -&gt; Have-Package
          + What-System-Are-We-On
          + What-Package-Do-We-Have

Have-Package:
    (--) Source                     -&gt; Before-Action
          + Get-Source-Install-Action
    (--) Binary                     -&gt; Before-Action
          + Get-Binary-Install-Action

Before-Action:
    (--) Build                      -&gt; Have-Install-Directory
          + Check-All-Files-Exist
          + Compile-All-Subroutines
          + Link-Main-Programs
          + Get-Directory-Name
    (--) Install                    -&gt; Have-Install-Directory
          + Get-Directory-Name
    (--) Delete                     -&gt; Have-Delete-Directory
          + Get-Directory-Name
    (--) Cleanup                    -&gt; Have-Package
          + Clean-Up-Directory
          + What-Package-Do-We-Have
    (--) Error                      -&gt; Have-Package
          + What-Package-Do-We-Have

Have-Install-Directory:
    (--) Ok                         -&gt; Have-Package
          + Check-Directory-Writable
          + Install-Product-Files
          + What-Package-Do-We-Have
    (--) Current                    -&gt; Have-Package
          + What-Package-Do-We-Have
    (--) Error                      -&gt; Have-Install-Directory
          + Get-Directory-Name

Have-Delete-Directory:
    (--) Ok                         -&gt; Have-Package
          + Check-Directory-Writable
          + Delete-Product-Files
          + What-Package-Do-We-Have
    (--) Error                      -&gt; Have-Delete-Directory
          + Get-Directory-Name

Defaults:
    (--) Error                      -&gt;
          + Return-Error-Feedback
          + Terminate-The-Program
    (--) Quit                       -&gt;
          + Terminate-The-Program
</PRE>

<P>The script reads install.cat to tell it which files to handle.
For example, this is the module Compile-All-Subroutines:</P>

<PRE>
######################   COMPILE ALL SUBROUTINES ######################

function compile_all_subroutines
{
    test -f *.o && rm *.o
    for FILE in `awk '/^&.*@c/ {print $2}' $CATALOG`; do
        echo "Compiling $FILE..."
        $CCNAME -c $CCOPTS $FILE
    done
}
</PRE>

<H2><A NAME="TOC51">COBOL Picture Parser</A></H2>

<P>The source files for this package are in <A href="/pub/libero/example/picture.zip">picture.zip</A>.</P>

<P>One of my still-unfinished projects is a portable COBOL compiler.  I was
writing a blindingly fast parser when I got sidetracked with Libero at the
start of 1995.  Anyhow, I found that lex was not really good at some of the
syntactic warble that COBOL allows, so I finally wrote a specific analyser.
The COBOL picture is one of the hairier aspects of the language.  I wrote a
function, with a dialog, that was robust and fast.</P>

<P>The function takes a picture string and returns its size, type, and
various other bits of info.  If the picture is not correct it returns an
error message.</P>

<P>It took just over a week, part-time, to write and test this program, so it
can't have been too hard.  I wrote a test program that shoves a load of test
pictures through the function and prints the results.  If you are running
MS-DOS, you can try the testpict program.  It outputs stuff like this:</P>

<PRE>
9(3)                        :                      size=3 numeric
9(3)V                       :                      size=3 numeric
V9(3)                       :                      size=3 numeric 3 decs
9(3)V9(3)9(3)9(3)9(3)9(3)   :                      size=18 numeric 15 decs
9(01                        :                      size=0 undefined
   ^
')' missing after repeat specifier.
ZZZZZ.ZZ9                   : ZZZZZ.....ZZ         size=12 undefined 2 decs
        ^
decimals cannot be partly zero-suppressed
9999,(2).(2)                : 9999,,..             size=8 undefined
         ^
(...) must follow one of: B X Z 0 9 * / + - , $
</PRE>

<P>This package might be useful if you need to analyse COBOL code. There is a
lot of it around (150 Gigalines at last count) so this is not such a
far-fetched idea.</P>

<P>There are also some nice functions in the package; for instance some
pretty fast file i/o code, which is non-portable enough to squeeze the best
out of the C libraries on a number of systems.</P>

<H2><A NAME="TOC52">Expression Parser</A></H2>

<P>The source files for this package are in <A href="/pub/libero/example/expr.zip">expr.zip</A>.</P>

<P>The expression parser that I use in the introduction as an example is a
real program that has cropped-up in various places, including in Libero.
Often, when I make a new language schema for Libero, I rewrite the expression
parser as a test.</P>

<P>This package has the same program, more or less, written in C, C++, Java,
COBOL, Rexx, 8086 assembler and Visual Basic.  The <A href="http://www.toscintl.com">ETKPAK</A> archive
at TOSC contains a more complete version of the COBOL program that supports
mathematical functions.</P>

<H2><A NAME="TOC53">Configuration Management System</A></H2>

<P>The source files for this package are in <A href="/pub/libero/example/config.zip">config.zip</A>.</P>

<P>On one project I worked on, a friend of mine, Patrick Bedert, had to write
a configuration management tool.  This tool had to keep track of each of
several thousand programs in the system we were developing.</P>

<P>A program has a life-cycle with various stages: in development, in
testing, in integration, in production, etc.  The developers can work on a
program only when it is in a certain stage.</P>

<P>After some thought, and lunch, we said this: 'Basically the life-cycle or
a program is a state-machine.  The states are the life-cycle stages.  The
events are the actions that the developer wants to, or does, do on the
program.'</P>

<P>So we designed the life-cycle as a Libero dialog.  The events were the
'sensitive' actions which either depended on the life-cycle stage, or which
changed it.  For example, you could only compile a program if you had
previously reserved it for modification.  You could only do this if it was in
the development stage.</P>

<P>We wrote this program as a UNIX shell script.  The script takes a program
and action as argument, and returns an exit code that is 0 (okay) or 1 (not
okay).</P>

<P>Whenever a developer wants to do a sensitive action, the script fires-up
the dialog.  It loads the last state for the program into LR_state, and
converts the action into an event.  The dialog then runs one cycle, and
either accepts the event and perhaps moves to a new state, or rejects the
event.  We save the state for each program in one file.  A small utility,
<TT>gate</TT>, makes sure that this file is never accessed by more than one
process at a time.</P>

<P>I can't supply the actual code, since this belongs to the client who paid
for the work.  However, I provide a small example, control, that should give
you the general idea.  Note that this dialog uses a hacked version of
lrschema.ksh, with some extra code to generate a table of state names.</P>

<P>This was a nice example of using a dialog to describe a real problem that
is normally beyond the scope of software.  It is also the slowest-running
program I have ever seen; one step through the dialog can take days!</P>

<H2><A NAME="TOC54">Multithreaded Agent For VAX/ACMS</A></H2>

<P>The source files for this package are in <A href="/pub/libero/example/acms.zip">acms.zip</A>.</P>

<P>One of the most complex programs I ever wrote was a multithreaded terminal
handler for a reservation system running on a Digital VAX/ACMS system.</P>

<P>Digital VAX/ACMS is a transaction processor somewhat akin to IBM's CICS,
or Tuxedo for UNIX.  In the ACMS model, people work on a front-end program
called an 'agent'.  The application programs run on the main system, the
'server'.  This is a good way to split the client-server
responsibilities.</P>

<P>In our project we were unable to use any of the standard Digital agents
(e.g. for DecForms), since we wanted to do our own screen handling.  The only
recourse was to write our own agent. This is easy enough when each user can
run in their own interactive session.  The agent program is then a normal
program which can handle a terminal and talk to ACMS.</P>

<P>The fun starts when you need to connect several hundred users (in our case
up to a thousand).  VMS, like any operating system, cannot handle so many
interactive sessions.  The only valid approach is to handle all the terminals
in a single process.  This means writing a multithreaded program where each
thread manages one terminal.</P>

<P>Perceived wisdom has it that this type of work is deadly difficult, and we
had something of a fight to convince the client that it would actually work.
The schedule was tight, and there was no time (nor will, on my part) to
develop the multithreaded code using conventional techniques.</P>

<P>So, I took the standard Libero C schema and changed it around so that it
generated multithreaded code.  The multithreaded schema actually generates a
tiny kernel that handles the multithreading aspects.  The code you write has
to be careful, as always, but is only a little more complex than normal
single-threaded code.</P>

<P>We beat the schedule, and made the client happy.  The multithreaded agent
is about 3500 lines of code, and a hairy program.  Still, it has run without
trouble for several years, efficiently, and survived several meaty
changes.</P>

<H2><A NAME="TOC55">E-mail Robot - ERBOT</A></H2>

<P>The source files for this package are in <A href="/pub/libero/example/erbot.zip">erbot.zip</A>.</P>

<P>A fairly complex Awk program, erbot is a kind of remote agent that you
can ask to do work via email.  For instance, you can use erbot to upload
or download files, run commands, etc. all by e-mail.  It is password
protected, and still experimental.</P>

<H2><A NAME="TOC56">HTML Preprocessor</A></H2>

<P>The source files for this package are in <A href="/pub/libero/example/htmlpp.zip">htmlpp.zip</A>.</P>

<P>Htmlpp is a preprocessor for HTML files, and is intended to simplify the
task of maintaining large sets of HTML documents.  You provide htmlpp
with a document that is a mix of HTML-tagged text and htmlpp commands.
Htmlpp generates a set of HTML files from that document.</P>

<P>During this process, htmlpp replaces symbols, reads include files, builds
tables of contents, and generally does a lot of otherwise tedious and
error-prone manual work.  To use htmlpp you should be happy writing HTML
with a simple text editor.</P>

<P>This is an old version of htmlpp, since this tool is continually
getting better.  Check-out the links on the iMatix home page for the
latest version of htmlpp.</P>

<H2><A NAME="TOC57">Complete Examples Archive</A></H2>

<P>You can download the complete examples package in <A href="/pub/libero/example/complete.zip">complete.zip</A>.
Unzip this and you get all the example archives.  For best results, unzip
each one into a separate directory.</P>

<H1><A NAME="TOC58">Libero's Languages</A></H1>


<H2><A NAME="TOC59">Choosing A Language</A></H2>

<P>Libero gives you the freedom you get to choose the language
that suits your purpose.  The way I add support for a particular
language is to write a new schema file.  This is a kind of
script that tells Libero how to generate code for that
particular language.  Inevitably, the solution I choose for a
language tends to vary.  For example, the C schema generates a
couple of include files to hold the generated code.  The UNIX
shell schemas in contrast take a source 'module' file and
generate the final script (which you don't work on directly).
</P>

<P>This section documents the special aspects of each language
(ie. schema). Some aspects that apply to all languages:
<UL>
<LI>All the schemas separate the generated code from the
hand-written code.  This means either a strict division into
hand-written files and generated files, or some sleight-of-hand
to get a similar result.  The mechanism varies from language to
language since I use the mechanisms that each language offers
(if any). You should understand which files you get when you
work in a particular language.</LI>

<LI>Most languages provide some form of function or subroutine.
I define one such for each module in the dialog, and you are
free to define your own 'private' functions in the code.  Libero
provides the facility to detect unused ('idle') modules, but for
this the syntax for the module functions must be different to
that for your private functions.  (Otherwise Libero can't tell
the difference, and issues loads of incorrect warning messages.)
In a few languages I did not find an acceptable way of making
the distinction, so the -idle options is disabled.  In the
remaining languages you must take care to follow the recommended
syntax for your private functions.</LI>

<LI>The generated code provides a number of public data items
and functions.  These have the same name in each language, as
far as possible.  Reserved names start with '_LR_' or something
similar.  Never use or refer to these names.</LI>
</UL></P>

<H2><A NAME="TOC60">Standard Public Names</A></H2>

<P>All schemas should support these names, which change syntax
according to the -style option:
<UL>
<LI><TT>xxxx_event</TT> - defined for each event in the dialog,
where 'xxxx' is the name used in the dialog.  Use these event
names whenever you need to set the value of the_next_event.</LI>
<LI><TT>the_next_event</TT> - the event for the next state.  Set
this event in one of the action modules, before entering a new
state.</LI>
<LI><TT>terminate_event</TT> - when you assign this to
the_next_event, the state machine halts.  Normally you will do
this in the terminate_the_program module.</LI>
<LI><TT>exception_raised</TT> - if you set this to TRUE, the
dialog engine stops executing the current action list, and goes
into exception handling.  Exceptions are described later.</LI>
<LI><TT>the_exception_event</TT> - before you raise an
exception, set this to the event you want to use as exception
event.  This event must be defined in the current state you are
in, or in the Defaults state.</LI>
<LI><TT>initialise_the_program</TT> - this standard module is
called when the dialog engine starts; here you can access and
check parameters, and set a suitable next event like ok_event.
</LI>
<LI><TT>get_external_event</TT> - this standard module is called
when the dialog needs an event, i.e. when none of the action
modules put anything in the_next_event.</LI>
<LI><TT>raise_exception </TT> - this standard function sets
exception_raised and places the specified event into
the_exception_event.</LI>
</UL></P>


<H2><A NAME="TOC61">Contributed Schemas</A></H2>

<P>These schemas were contributed by Libero users, and are not
documented in detail here.  You will need to read the schemas and
try them out to see how they work.

<UL>
<LI>The Oracle PL/SQL Language<BR>
<A NAME="plsql">&nbsp;</A>
    PL/SQL is a scripting language used in the Oracle database
    system.  The PL/SQL schema was written by Claude Philippo and
    Xavier Vermaut of Sema Group Belgium, and was kindly contributed
    by Sema Group Belgium.
<LI>The PHP Language<BR>
<A NAME="php">&nbsp;</A>
    PHP is an Open Source scripting language used for web development.
    system.  The PHP schema was written and kindly contributed by
    Attilio &lt;glen@ats.it&gt;.
</UL>

<A NAME="awk">&nbsp;</A>
<H2><A NAME="TOC62">The Awk Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is Awk?</DT>
<DD>Awk is a standard UNIX tool that comes in several flavours -
'old' awk (/bin/awk), new awk (/bin/nawk), GNU gawk (/bin/gawk).
It is a small interpreted language that looks a bit like C, with
a strong flavour of sed pattern matching.  Awk is mostly used to
manipulate text files, but is also fun as a general-purpose
programming language.</DD>
<DT>Portability</DT>
<DD>GNU gawk is available on many platforms. Awk scripts are
highly portable if you don't rely on (UNIX) system-dependent
commands.  GNU Gawk and new awk share most functions.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: Awk is versatile and easy to learn; GNU gawk is freely
available; Awk is an interpreted language and looks a bit like
C.  Cons: Awk is a simple language, not powerful enough for
industrial-strength work; it's interpreted - slower than C but
faster than a shell; it looks a bit like C.</DD>
<DT>How To Get It</DT>
<DD>On UNIX boxes, <TT>awk</TT> or <TT>nawk</TT>. On other
systems, get GNU gawk.</DD>
<DT>Libero Supports</DT>
<DD>Libero supports new awk and gawk, but not old awk.</DD>
</DL>

<H3>Working With Awk</H3>

<UL>
<LI><B>Schema:</B> lrschema.awk.</LI>
<LI><B>Program model:</B> shell-wrapped awk script; directly
executable.  All processing is done in the BEGIN block.</LI>
<LI><B>Good for:</B> large awk scripts that handle multiple
files.</LI>
<LI><B>Files used/made:</B> Own work in <TT>myprog.mod</TT>;
generates program called myprog.</LI>
<LI><B>Module functions:</B>
<TT>function module_function_name \</TT></LI>
<LI><B>Private functions:</B>
<TT>function private_function_name () {</TT></LI>
<LI><B>Naming style:</B> Any except -style=cobol.</LI>
<LI><B>Limits:</B> Standard Libero limits, and system memory.
All tables are defined dynamically at runtime.</LI>
<LI><B>Development cycle:</B> Run <TT>lr</TT> after you change
the dialog or <TT>.mod</TT> file.  When you add a new module,
run lr, then edit the <TT>.mod</TT> file, then run <TT>lr</TT>
again.  Don't change the generated awk script except for tests -
you'll lose your changes.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>
<PRE>
#################   MODULE FUNCTION NAME   #################

function module_function_name  ( local_var,... ) {            # Place local variables here
    return                      # Empty module needs 'return'
}
function private_function_name (argument,...) {
    the_next_event = ok_event
    raise_exception (error_event)
}
</PRE>
<P><A HREF="doc/erbot.mod">A fuller example.</A></P>

<H4>Notes</H4>
<P>My awk programs fall between two extremes.  At the one end is
a 'filter', to process text according to patterns in each line.
This is excellent for smallish problems.  As the problem grows,
I need to read other files 'on the side', and the logic of my
awk program grows until a large part of it is sitting in the
BEGIN or END blocks.  Eventually I find that I am perhaps
reading and writing several files, so I take the plunge and
rewrite the program to handle all files with explicit 'getline'
calls.  The awk program is no longer a filter, but a stand-alone
program that resembles a classic procedural program.  Of course
at this point my Libero hindbrain wakes up and starts muttering
'an' whaddabout Libero, eh?'.</P>

<P>When I wrote the awk schema, I started with the Visual Basic
schema. Bizzarely enough this language resembles awk most in
terms of structure and possibilities.  I've started thinking of
awk as a kind of 'Basic for UNIX'.</P>

<P>Awk presents some of the same difficulties as Visual Basic.
There is no 'include' statement to take an external file as part
of the program.  The UNIX shells have the same problem.</P>

<P>&lt;GRIPE&gt;Since awk is tokenised, then executed, messieurs
A, W, and K had no real excuse for omitting an 'include'
facility.&lt;/GRIPE&gt;</P>

<P>I really don't want to look at the chunk of code that Libero
generates, so I always try to find a way to separate this from
the hand-written code I am working on.  If the language provides
an 'include' statement, I place the generated code in an include
file.  This works great in serious compiled languages which all
have something like this.  You change the dialog, regenerate
the code, and recompile.  At any time you can change the
program and recompile without having to run Libero again.</P>

<P>For the awk schema I used another technique: you work in a
separate 'module' file (<TT>myprog.mod</TT>).  Libero combines
the module file with the generated program to create a final
program, which you don't change. This effectively hides the
generated code, but introduces an extra step: each time you
change the .mod file you must re-run Libero to create the final
script.  In effect, Libero acting as a preprocessor in place of
the missing 'include' statement.</P>

<P>Notice the slightly unusual format of a generated module
header:</P>

<PRE>
function module_function_name  ( local_var,... ) {
    ...
}</PRE>

<P>I break the function header over two lines so that you can
add local variables easily if you need to.  Libero recognises
the first line as a module header, and does not look at the next
line with the local variables. The unusual format also
distinguishes module functions from private functions, so
ensures that the -idle option works correctly.</P>


<A NAME="ansic">&nbsp;</A>
<H2><A NAME="TOC63">The C Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is C?</DT>
<DD>C is part of UNIX originally, now almost a universal language. It is a
very general purpose language, and typically used for systems programming.
ANSI C is a widely supported standard.</DD>
<DT>Portability</DT>
<DD>ANSI C compilers are available on (almost) all platforms. ANSI C programs
can be highly portable if you eschew compiler extensions, and don't rely on
libraries that are not portable.  Some UNIX vendors include non-ANSI
compilers but charge extra for ANSI C compilers.  Luckily the GNU gcc
compiler is excellent and ported to most UNIX systems.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: C is flexible and widely known; it is a small and clean language.
C compilers are generally well-tuned and sometimes exceptionally good.  Cons:
no easy string handling; sloppy programmers write horrendous C code.</DD>
<DT>How To Get It</DT>
<DD>How to get it On UNIX boxes, 'cc', or 'gcc'. GNU gcc is widely available
and well-regarded.  Commercial C compilers are available for almost all
platforms from mainframes to embedded systems.</DD>
<DT>Libero Supports</DT>
<DD>ANSI C, though you can freely use any extensions you need to. Libero
generates ANSI C code, so your compiler must be happy with things like
prototypes.</DD>
</DL>

<H3>Working With C</H3>

<UL>
<LI><B>Schema:</B> lrschema.c.</LI>
<LI><B>Program model:</B> function with arguments; you can change the
function name and arguments in the proposed program.</LI>
<LI><B>Good for:</B> large C programs; complex functions; batch
programs.</LI>
<LI><B>Files used/made:</B> own work in myprog.c; generates include files
<TT>mydialog.d</TT> and <TT>mydialog.i</TT>.  You also need the
<TT>prelude.h</TT> header file at compile time.</LI>
<LI><B>Module functions:</B> <TT>MODULE module_function_name (void)</TT></LI>
<LI><B>Private functions:</B> <TT>static type private_function_name
()</TT></LI>
<LI><B>Naming style:</B> any except -style=cobol.</LI>
<LI><B>Limits:</B> standard Libero limits.  All tables are defined
statically in the <TT>myprog.i</TT> file.</LI>
<LI><B>Development cycle:</B> run <TT>lr</TT> after changing the dialog.  If
you add new modules, update the <TT>.c</TT> program.  Compile, link, and run.
You need the <TT>.i</TT> and <TT>.d</TT> files at compile time.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>

<PRE>
/****************   MODULE FUNCTION NAME   *****************/

MODULE module_function_name (void)
{
                             /* Empty module needs no code */
}

static type private_function_name (argument,...) {
    the_next_event = ok_event;
    raise_exception (error_event);
}
</PRE>

<P><A HREF="doc/calcul.c">A fuller example.</A></P>

<H4>Notes</H4>

<P>I've used Libero to help me write C programs for a few years.  It would be
false to say I used Libero all the time; this is simply not the case.  For
example, I wrote Libero in C: there are 12 separate source files, and four of
these have dialogs.  I used a dialog whenever I had a single function that
got rather complex. In Libero, this happens to be in:
<OL>
<LI>the module that parses and loads a dialog (<TT>lrload</TT>);</LI>
<LI>the code generator module, which scans the schema and interprets the
simple language embedded in the schema (<TT>lrcode</TT>);</LI>
<LI>the two modules that evaluate expressions (<TT>lrcalc</TT> and
<TT>lreval</TT>).</LI>
</OL></P>

<P>It's probably no coincidence that all these modules do some kind of
parsing.  Libero is a code generator, so it's normal that the most complex
modules are parsers.  As a consultant, I've written some profoundly complex C
programs using Libero.  In at least one case I still don't see any other way
that I could have done the project.</P>

<P>When you write a C program using Libero, you tend to use a lot of
source-local variables.  This is disturbing to some programmers, who reckon
that a program must consist of lots of internested modules that hide data
from each other.  Sure, this is one way of managing complexity.  Still,
modules in a Liberated program aren't nested; they all sit at the same level
below the dialog.  They all share (mostly) a common set of data objects.  In
real programs this seems to work nicely, so if you have problems with it,
just close your eyes the first few times.</P>


<A NAME="cpp">&nbsp;</A>
<H2><A NAME="TOC64">The C++ Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is C++?</DT>
<DD>C++ is a recent mutation of C, generally known as 'assembler with
objects'.  Okay, perhaps a bit unkind.  C++ is widely used, combines
the generality of C with solid object-orientation.  It's the language
of choice for Windows GUI programming.</DD>
<DT>Portability</DT>
<DD>C++ is pretty portable.  C++ compilers are available for most
platforms, but you may find that the main reasons for using C++ -
class libraries - are not portable.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: C++ is powerful and widely known; it is object oriented.
Cons: it's a large language to learn.</DD>
<DT>How To Get It</DT>
<DD>I guess most C++ users know the answers to this.</DD>
<DT>Libero Supports</DT>
<DD>Standard C++.</DD>
</DL>

<H3>Working With C++</H3>

<UL>
<LI><B>Schema:</B> lrschema.cpp.</LI>
<LI><B>Program model:</B> Class named after the program: entry point
is a member function called 'execute'; you can change this.</LI>
<LI><B>Good for:</B> not really sure.  We'll see.</LI>
<LI><B>Files used/made:</B> own work in myprog.cpp; generates include
files <TT>mydialog.h</TT> and <TT>mydialog.i</TT>.  You also need the
<TT>prelude.h</TT> header file at compile time.</LI>
<LI><B>Module functions:</B>
<TT>MODULE Cprogram::module_function_name (void)</TT></LI>
<LI><B>Private functions:</B>
<TT>type Cprogram::private_function_name ()</TT></LI>
()</TT></LI>
<LI><B>Naming style:</B> any except -style=cobol.</LI>
<LI><B>Limits:</B> standard Libero limits.  All tables are defined
statically in the <TT>myprog.i</TT> file.</LI>
<LI><B>Development cycle:</B> run <TT>lr</TT> after changing the dialog.  If
you add new modules, update the <TT>.cpp</TT> program. Compile, link, and
run.  You need the <TT>.h</TT> and <TT>.i</TT> files at compile time.
You can freely change the <TT>.h</TT> file to add private data and
functions.  Follow the guidelines in the generated code which indicate
where you can change code.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>

<PRE>
/////////////////   MODULE FUNCTION NAME   //////////////////

MODULE Cprogram::module_function_name (void)
{
                             //  Empty module needs no code
}

Cprogram::private_function_name (argument,...) {
    the_next_event = ok_event;
    raise_exception (error_event);
}
</PRE>

<P><A HREF="doc/calcul.cpp">A fuller example.</A></P>

<H4>Specific Schema Options</H4>
<UL>
<LI><B>-opt:class='xxx'</B> <TT>xxx</TT> is class name.  Default value is <TT>C$
</UL>


<A NAME="cobol">&nbsp;</A>
<H2><A NAME="TOC65">The COBOL Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is COBOL?</DT>
<DD>COBOL is a standard language for business software, a job that it does
well.  It is heavily used in the mainframe world.  COBOL has an undeserved
reputation for inefficiency, and a deserved reputation for verbosity.  Today,
many COBOL applications are being moved from mainframes to UNIX boxes.</DD>
<DT>Portability</DT>
<DD>Deaf, dumb, blind COBOL programs can be very portable. Otherwise you can
use external libraries to achieve 100% portability (catch: you may have to
write these libraries yourself).</DD>
<DT>Pros and Cons</DT>
<DD>Pros: easy to use and teach. An excellent language for mediocre
developers, which includes me at least two days of the week.  Cons: Tends to
encourage large, monolithic programs.  Like unreadable C code, this is a
question of discipline.  COBOL provides no way to define data types directly,
and has a verbose and over-rich syntax.  COBOL compilers are often
unimpressive.  This is actually putting it mildly: on several systems that
I've worked on, a simple loop in COBOL runs from 100 to 1000 times slower
than the same loop coded in assembler.  I've seen just one COBOL compiler
(Versions 2 and 3 of Realia) that could produce truly excellent code.</DD>
<DT>How To Get It</DT>
<DD>No free implementations exist, despite various attempts -- including one
by me: if a COBOL compiler is Mt. Everest, I got as far as London Heathrow
airport.  You need to find a commercial COBOL vendor for your system.</DD>
<DT>Libero Supports</DT>
<DD>ANSI 74 COBOL and ANSI 85 COBOL.</DD>
</DL>

<H3>Working With COBOL</H3>

<UL>
<LI><B>Schema:</B> lrschema.cob.</LI>
<LI><B>Program model:</B> main program without linkage or called program with
linkage.</LI>
<LI><B>Good for:</B> COBOL batch programs and subroutines.</LI>
<LI><B>Files used/made:</B> own work in <TT>MYPROG.cob</TT>; generates a copy
book <TT>MYDIALOG.cbl</TT>.</LI>
<LI><B>Module functions:</B> <TT>MODULE-FUNCTION-NAME</TT>.</LI>
<LI><B>Private functions:</B> <TT>PRIVATE-FUNCTION-NAME</TT>.</LI>
<LI><B>Naming style:</B> schema sets -style=cobol automatically</LI>
<LI><B>Limits:</B> 999 states, events, modules.  (Libero allows 1000 of
anything.)  All tables are defined statically.  Some compilers restrict any
one 01-level item to 32K bytes.</LI>
<LI><B>Development cycle:</B> run lr after you change the dialog.  Edit
the source program, then recompile and link.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>

<PRE>
*****************   MODULE FUNCTION NAME   *****************

 MODULE-FUNCTION-NAME.
     EXIT
     .

 PRIVATE-FUNCTION-NAME.
     MOVE OK-EVENT TO THE-NEXT-EVENT

     MOVE ERROR-EVENT TO THE-EXCEPTION-EVENT
     MOVE    "YES"    TO EXCEPTION-RAISED
     .
</PRE>

<P><A HREF="doc/calcpk.cob">A fuller example.</A></P>

<H4>Notes</H4>

<UL>
<LI>The dialog file can't have same name as the program (on some systems the
extension for a program and a copy book is the same); the schema gives an
error message in this case.  I suggest you use the <TT>-plusd</TT> option in
your dialog.</LI>
<LI>Since there is no way to distinguish the dialog paragraphs ('modules')
from private paragraphs, the schema turns-off idle module checking.</LI>
<LI>With some compilers (typically on IBM systems) you need to add a QUOTES
option to compile the generated code.  The generated code uses quotes, not
apostrophes - this is more portable, though maybe unusual for IBM'ers.</LI>
<LI>There is no FEEDBACK variable or RAISE-EXCEPTION function, in contrast
with most other schemas.</LI>
<LI>Assumes the old-fashioned 80-column format with 6-digit sequence number
and 8-character comment at right-hand side. Generates upper-case text.</LI>
</UL>

<P>COBOL has a reputation for encouraging large unwieldy programs.  This is
justified to the extent that the language is verbose.  I think it's more due
to the fact that COBOL programs tend to be written and maintained under
particular pressures: get it working, now, and who cares if it is a little
unwieldy.  You don't often see COBOL code competing on the open market for
software where program size and speed are important.</P>

<P>People working in COBOL expect monsters, so often get them. Now, I've
spent a lot of my life writing COBOL - perhaps half a million lines or so,
and I know that this unnecessary suffering. Of course it is possible to write
clean, organised, commented code without Libero.  It is just a lot more
effort, and I'm lazy.</P>

<P>This schema is for batch programs and subroutines.  Batch programs are
often the largest and most complex COBOL programs, and often benefit from a
dialog.  I've not seen a lot of subroutines that really needed a a dialog;
the expression calculator is one example.  Also, if you split a large batch
program into smaller subroutines, these can be complex enough to warrant a
dialog.  Very roughly, I would reckon that a COBOL program of more than 1000
lines is worth building around a dialog.</P>

<H4>Specific Schema Options</H4>
<UL>
<LI><B>-opt:ext=xxx</B> <TT>xxx</TT> is extension for copybook.  Default
value is <TT>cbl</TT>.  Recommended values are: <TT>cob</TT> for MS-DOS
Realia, <TT>cbl</TT> for UNIX, <TT>lib</TT> for VAX/VMS.</LI>

<LI><B>-opt:model=main</B>  The generated code does not define any linkage
section.  This is the default model.</LI>

<LI><B>-opt:model=called</B>  The generated code defines a linkage section
that contains a single 01-level data item.  You must detail this data item in
a copybook called MYPROGR.  The copybook must follow this general format,
with a 01-level header, then a comment line containing the text '*CONTENTS',
then the details of the linkage section.  For example:<BR>

<PRE>
000100 01  CALCPK-CONTROL.
000200*CONTENTS
000300     02  CALCPK-OPERATION        PIC X.
000400     02  CALCPK-FEEDBACK         PIC X.
000500     02  CALCPK-POINT-CHAR       PIC X.
000600     02  CALCPK-ERROR-RETURN.
000700         03  CALCPK-ERROR-CODE   PIC X(2).
000800         03  CALCPK-ERROR-MESG   PIC X(30).
000900     02  CALCPK-ERROR-POSN       PIC 9(2).
001000     02  CALCPK-EXPRESSION.
001100         03  EXPR-CHAR           PIC X          OCCURS 80 TIMES.
001200     02  CALCPK-RESULT           PIC S9(9)V9(9).
001300     02  CALCPK-VARIABLE         PIC S9(9)V9(9) OCCURS 5 TIMES.
</PRE></LI>

<LI><B>-opt:level=ansi74</B>  Generate ANSI 74 COBOL.  Some heritage COBOL
compilers don't support ANSI 85 COBOL.  This is the default level.</LI>

<LI><B>-opt:level=ansi85</B>  Generate ANSI 85 COBOL.  The ANSI 85 code runs
a little faster, since it uses an EVALUATE statement against a series of IF
statements in the ANSI 74 code.</LI>

<LI><B>-opt:console=name</B>  Display trace output and error messages on
specified device.  By default blank.  Some systems do not like DISPLAY by
itself, and require an output device name.  For example, to generate
statements DISPLAY ... UPON CONSOLE, use 'opt:console="UPON CONSOLE"'.  Note
that you must place quotes around the value for two reasons: it contains a
space, and you want to keep it in uppercase.</LI>
</UL>


<A NAME="bash">&nbsp;</A>
<H2><A NAME="TOC66">The GNU Borne-Again Shell Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is The GNU BASH?</DT>
<DD>GNU BASH is the GNU project's UNIX shell. It replaces the (not really)
standard UNIX Bourne and Korn shells.</DD>
<DT>Portability</DT>
<DD>BASH (<TT>/bin/bash</TT>) is available for all UNIX systems that I know
of.  BASH scripts can be ported to other UNIX shell languages: the closest is
the Korn shell.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: freely available and standardised. Follows the POSIX standard; has
the best of all the UNIX shells in one package.  Cons: not necessarily
installed on your UNIX box.</DD>
<DT>How To Get It</DT>
<DD>Get it from your local GNU shoppe. BASH and the other GNU tools are part
of all Linux distributions.</DD>
</DL>

<H3>Working With The GNU Borne-Again Shell</H3>

<UL>
<LI><B>Schema:</B> lrschema.bsh.</LI>
<LI><B>Program model:</B> executable UNIX script.</LI>
<LI><B>Good for:</B> complex scripts; portable to GNU systems.</LI>
<LI><B>Files used/made:</B> own work in <TT>myprog.mod</TT>; generates a
script called <TT>myprog</TT>.</LI>
<LI><B>Module functions:</B>
<PRE>
function module_function_name
{
</PRE></LI>
<LI><B>Private functions:</B> <TT>function private_function_name {</TT></LI>
<LI><B>Naming style:</B> any except -style=cobol.</LI>
<LI><B>Limits:</B> 254 modules, 254 events, 1000 states.  The schema checks
at generate-time that the dialog does not exceed these limits.  All tables
are defined dynamically, at runtime.</LI>
<LI><B>Development cycle:</B> run <TT>lr</TT> after you change the dialog or
<TT>.mod</TT> file.  When you add a new module, run <TT>lr</TT>, then edit
the <TT>.mod</TT> file, then run <TT>lr</TT> again.  Don't change the
generated script except for hacking - you'll lose your changes.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>

<PRE>
#################   MODULE FUNCTION NAME   #################

function module_function_name
{
    return                      # Empty module needs 'return'
}

function private_function_name {
    the_next_event=$ok_event
    raise_exception $error_event
}
</PRE>

<A NAME="unix_shells">&nbsp;</A>
<H3>Programming with UNIX Shells</H3>

<OL>
<LI>You must remember to assign events and other variables as follows:
<TT>the_next_event=$some_event</TT>.  If you make the common mistake of
forgetting the '$', the results are interesting but not useful.  The schema
checks against this error, at a slight cost in runtime.  You can skip these
checks by using the -nocheck option. The BASH language lets you declare
numeric variables explicitly, so this check is not required in the
lrschema.bsh schema.</LI>

<LI>Your <TT>.mod</TT> file is not copied entirely, but in sections. The
script schemas extract three sections marked with the keywords &lt;HELP&gt;
to &lt;END&gt;, &lt;DATA&gt; to &lt;END&gt;, and &lt;CODE&gt; to
&lt;END&gt;.  You will see :include commands in the schemas that do this.
The final &lt;END&gt; is optional, and probably best to ignore.</LI>

<LI>The &lt;HELP&gt; section is copied to the header of the script. Each line
in this section should start with '#'.  Some of my scripts are
self-anotating: if run with '-h' as argument, they do something like
this:

<PRE>
    expand $0 | egrep "^# |^#$" | cut -c 4-80 | more
</PRE></LI>

<LI>The module <TT>Initialise_the_program</TT> gets the command-line
arguments; ie. it can refer to $1, $2, in the normal way.</LI>

<LI>The <TT>script_name</TT> variable contains the command-line variable $0.
You could put something like this in initialise_the_program:

<PRE>
    if test "$1" = "-h"; then
       expand $script_name | egrep "^# |^#$" |        cut -c 4-80 | more
       exit
   fi
</PRE></LI>
</OL>

<P>Also note that:
<OL>
<LI>It is sometimes useful to start a script using the <TT>.</TT> operator.
For instance, to trace a script you could use these commands:<BR>
<TT>set -x; . scriptname</TT><BR>
If such a script ends with <TT>exit</TT> (and the generated ones do), you
exit the current shell. If it's your main shell, you are logged-out.  To
avoid this, enclose the entire command in parentheses:<BR>
<TT>(set -x; . scriptname)</TT>
or run a sub-shell first.</LI>

<LI>The auto-annotating function explained above won't work if you run the
script using the <TT>.</TT> operator ($0 becomes the name of the
shell...).</LI>

<LI>These shell script schemas are somewhat slow.  I optimised the code to
use as many internal commands as possible in place of external commands.
This cut the time spent in the dialog manager code by 60% over the first
version.  The bash and ksh versions are the most efficient; bsh does not have
a <TT>let</TT> command, so I need to use the clumsy <TT>a = `expr 1 + 1`</TT>
to increment a variable.  The bash shell version is the cleanest, since I can
use <TT>declare</TT> to define numeric variables.  Any attempt to assign text
to a numeric variable gives an explict shell error message.</LI>

<LI>I use a function <TT>LR_idx</TT> to access arrays of numbers by shifting
and returning a numeric value.  This is the fastest method I could find, and
it works in all three shell languages. As a consequence, there is a limit of
254 events (255 is the terminate_event).</LI>

<LI>If you are doing heavy shell-type programming, consider using Perl.</LI>
</OL></P>


<A NAME="java">&nbsp;</A>
<H2><A NAME="TOC67">The Java Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is Java?</DT>
<DD>If you've been living in a cave for the last few years you
might have missed the news that Java (also called 'Basic for
Toasters') is going to replace every other language out there.
This is perhaps a little exaggerated, but Java is a very
interesting language all the same.  Java is not too complex,
though you need to learn quite a lot about various 'class
libraries' before you can do anything useful with it.  The best
use for Java right now is to write portable 'plug-ins' that work
with any recent web browser on many platforms.</DD>

<DT>Portability</DT>
<DD>Java is in principle 100% portable, but this claim may be
qualified as Java gets implemented on more systems.</DD>

<DT>Pros and Cons</DT>
<DD>Pros: Java is similar to C++, though cleaner.  It's portable
and works well with post-1996 Internet browsers.
Cons: it's interpreted, so slowish.  You will spend some time
learning to do anything useful with it.</DD>

<DT>How To Get It</DT>
<DD>You can download Java kits from Sun; you can buy various
Java development environments.</DD>

<DT>Libero Supports</DT>
<DD>Java objects, console applications, and applets.</DD>
</DL>

<H3>Working With Java</H3>

<P>The README.DOC file included in the beta kit explains how to
develop Java programs using Libero.</P>

<P><A HREF="doc/calcexpr.htm">A fuller example.</A></P>



<A NAME="setup_basic">&nbsp;</A>
<H2><A NAME="TOC68">The Microsoft Setup Basic Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is Setup Basic?</DT>
<DD>Setup Basic is the Scripting language used and pushed by Microsoft for MS
Windows 3.x setup procedures.  It is identical to the MS-Test Basic language,
version 1.0.</DD>
<DT>Portability</DT>
<DD>Zero. Unless you are heavily into MS-Test.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: standard for setup procedures, easily available. Cons: you have to
be an experienced Windows developer, and have other visual development tools,
such as dialog editors, to use it.</DD>
<DT>How To Get It</DT>
<DD>It is part of the Windows SDK.</DD>
<DT>Libero Supports</DT>
<DD>MS Setup BASIC / Test Basic 1.0.</DD>
</DL>

<H3>Working With Microsoft Setup Basic</H3>

<UL>
<LI><B>Schema:</B> lrschema.mst.</LI>
<LI><B>Program model:</B> main <TT>.mst</TT> program, run using
<TT>_mssetup.exe</TT> driver. </LI>
<LI><B>Good for:</B> Win 3.x setup programs, as alternative to writing
complex logic directly into program code.</LI>
<LI><B>Files used/made:</B> own work in <TT>myprog.mst</TT>; generates
include file <TT>mydialog.inc</TT>.</LI>
<LI><B>Module functions:</B>
<TT>Static Sub module_function_name ()</TT></LI>
<LI><B>Private functions:</B>
<TT>Sub private_function_name Static (...)</TT></LI>
<LI><B>Naming style:</B> any except -style=cobol.</LI>
<LI><B>Limits:</B> standard Libero limits.  All tables are defined
dynamically at runtime.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>
<PRE>
'****************   MODULE FUNCTION NAME   *****************

Static Sub module_function_name ()

End Sub

Sub private_function_name Static (argument,...)
    the_next_event = ok_event
    raise_exception (error_event)
}
</PRE>

<H4>Notes</H4>
<P>This schema is still in a beta state; I've not used it in any real
program. However, if I ever have to write a setup script in this language,
this is the way to go.</P>

<P>When I started writing a setup program for 'Libero for Windows', I got
hold of the Microsoft Setup Toolkit, and discovered the joys of writing a
setup script.  The language is the cut-down Basic that was used in the MS
Test product: TestBasic version 1.0.  I call this almost-language MST.  At
least, unlike Visual Basic, MST supports an include statement.  So, the MST
schema puts the generated code into an .inc file.</P>

<P>The setup toolkit documentation suggests that you draw a flowchart of the
various stages of your install procedure, then code this into an MST program.
Hmm.  :-(  I hate flowcharts, for one thing.  For another, I have a much
simpler and useful technique up my sleeve, so some quick work on a schema,
and 'wallop!'.  MST, please meet Mr. Turing.</P>

<P>As it happens, I then decided that I did not want to use an MST setup
program, did not want to start designing dialog boxes and resources.  Now the
Libero for Windows installation package is a .zip file that you expand into
the directory of your choice, full stop.  Still, the MST schema is there and
it works, barring the odd lazy bug.</P>


<A NAME="vb">&nbsp;</A>
<H2><A NAME="TOC69">The MS Visual Basic Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is Visual Basic?</DT>
<DD>Visual Basic (VB) is Microsoft's rapid application development language.
It is the standard scripting language for MS applications such as Word and
Excel.</DD>
<DT>Portability</DT>
<DD>None.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: easy to use and widely used; lots of support from third-party
add-ons; interpreted language.  Cons: slow screen updates; interpreted
language.</DD>
<DT>How To Get It</DT>
<DD>Buy it from your local software shoppe.</DD>
<DT>Libero Supports</DT>
<DD>MS Visual Basic 3.0. Not tested with 4.0, but probably will work
unchanged.</DD>
</DL>

<H3>Working With Visual Basic</H3>

<UL>
<LI><B>Schema:</B> lrschema.vb.</LI>
<LI><B>Program model:</B> subroutine with arbitrary name and arguments.</LI>
<LI><B>Good for:</B> complex VB subroutines; batch programs.</LI>
<LI><B>Files used/made:</B> own work in <TT>myprog.bas</TT>; generates a
program called <TT>myprog.int</TT>.</LI>
<LI><B>Module functions:</B>
<TT>Private Sub module_function_name ()</TT></LI>
<LI><B>Private functions:</B>
<TT>Private Sub private_function_name ()</TT></LI>
<LI><B>Naming style:</B> any except -style=cobol.</LI>
<LI><B>Limits:</B> 999 states, events, modules.  (Libero allows 1000 of
anything.)  All tables are defined dynamically, at runtime.</LI>
<LI><B>Development cycle:</B> when you change the <TT>.bas</TT> source file,
you can run the VB application right away.  When you change the dialog, you
must regenerate the <TT>.int</TT> and <TT>.bas</TT> files, and either stop
and restart VB, or remove and re-insert the two files from your project</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>

<PRE>
'
'****************   MODULE FUNCTION NAME   *****************
'
Private Sub module_function_name ()

End Sub

Private Sub private_function_name (argument,...)
    the_next_event = ok_event
    exception_raised = True
    the_exception_event = error_event
}
</PRE>

<P><A HREF="doc/vbcalc.bas">A fuller example.</A></P>

<H4>Notes</H4>

<OL>
<LI>Since there is no way to distinguish module functions from private
functions, the schema turns-off idle module checking.</LI>
<LI>The <TT>.int</TT> code file is the dialog interpreter.  You have to
include both the <TT>.bas</TT> and <TT>.int</TT> files in your project.  I
make the split into two files so that you are not faced with the generated
code when you edit the <TT>.bas</TT> source file.</LI>
<LI>The <TT>.int</TT> interpreter calls the <TT>.bas</TT> source file via a
dispatcher function.  This function (which is generated) calls a particular
module and returns event information.  This is not particularly fast, but
works okay.</LI>
<LI>All functions are private; this allows several Liberated programs in the
same VB application.</LI>
<LI>VB sorts functions in a source file into alphabetical order; I called the
dispatcher 'ZzDis_...' to ensure that it comes at the end.  This is just for
cosmetic reasons.  If for some reason the dispatcher function comes somewhere
in the middle of the source, everything will still work okay.  (I have at
least one source file where VB did not arrange the functions correctly.)</LI>
</OL>

<H3>Specific Schema Options</H3>

<UL>
<LI><B>-opt:slice=shared</B> - the program will periodically calls DoEvents()
to allow other Windows applications to run at the same time.</LI>
<LI><B>-opt:slice=exclusive</B> - the program does not cooperate with Windows
multitasking.  This is the default option.</LI>
</UL>


<A NAME="perl">&nbsp;</A>
<H2><A NAME="TOC70">The Perl Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is Perl?</DT>
<DD>Perl is the mutant four-headed child of Awk, C, Sed, and the
UNIX shells, plus just about every other language and feature
that its creator, Larry Wall, could think of.  I like this
language.</DD>
<DT>Portability</DT>
<DD>Perl is fundamentally portable to UNIX boxes, and has also
been ported to many other systems.  Perl scripts are highly
portable so long as you stay away from system-specific
functions.  This is pretty much as you would expect.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: powerful and flexible; freely available; interpreted
language. Cons: if you can't handle type-free languages where
just about anything goes, return to Pascal.  Perl is (IMHO) not
a good place to start programming.</DD>
<DT>How To Get It</DT>
<DD>By Internet from ftp.uu.net and many other places.</DD>
<DT>Libero Supports</DT>
<DD>Libero supports Perl 5.x</DD>
</DL>

<H3>Working With Perl</H3>

<UL>
<LI><B>Schema:</B> lrschema.pl.</LI>
<LI><B>Program model:</B> Perl program.</LI>
<LI><B>Good for:</B> complex Perl programs.</LI>
<LI><B>Files used/made:</B> own work in <TT>myprog.pl</TT>;
generates an include file <TT>mydialog.d</TT>.</LI>
<LI><B>Module functions:</B>
<TT>sub module_function_name</TT>.</LI>
<LI><B>Private functions:</B>
<TT>sub private_function_name {</TT>.</LI>
<LI><B>Naming style:</B> any except -style=cobol.</LI>
<LI><B>Limits:</B> normal Libero limits.  All tables are defined
dynamically, at runtime.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>
<PRE>
#################   MODULE FUNCTION NAME   #################

sub module_function_name
{
                                   #  Empty module needs no code
}

function private_function_name {
    $the_next_event = $ok_event;
    &\raise_exception ($error_event);
}
</PRE>

<P><A HREF="doc/htmlpp.pl">A fuller example.</A></P>

<H4>Notes</H4>

<UL>
<LI>If you add your own 'require'd files, place them before the
dialog manager file.  Otherwise you may find that the code they
contain is not executed.</LI>
<LI>You can rename the generate program from <TT>xxxxx.pl</TT>
to just <TT>xxxxx</TT>, if you prefer.  Libero is quite okay
with this.</LI>
</UL>

<P>If you have used Perl, you will appreciate the way it
combines the best of all the UNIX text processing and
programming tools.  For example, you need only a few lines of
Perl to read and parse a parameter file ('ini file') like
this:</P>

<PRE>
#============================================================
#  Parameters for program
#============================================================

[General]
    OutBox=outbox             # Subdirectory for sent faxes

[Connect]
    HostName=Badoit           # For Telnet
    UserName=autofax
    Password=autofax

[FaxDriver]
    PauseChar="~"             # Substitute for commas

[Station]
    Id=Station1               # Name of this local system

    open (INI, "autofax.ini") || die "Can't open autofax.ini: $!\n";
    while (&lt;INI&gt;) {
        chop;                           #   Remove trailing newline
        #   [SectionName] followed by optional comment
        if (/^\s*\[(\w+)\]\W*(#.*)?$/) {
            ($section = $1) =~ tr/A-Z/a-z/;
        }
        #   Keyword=Value followed by optional comment
        if (/^\W*(\w+)=("[^"*]"|\w+)\W*(#.*)?$/) {
            ($keyword = $1) =~ tr/A-Z/a-z/;
            ($value = $2) =~ s/"//g;    #   Remove any quotes
            $initial {$section, $keyword} = $value;
        }
    }
    close (INI);
</PRE>

<P>Similar code in C is several pages.  This applies to many
aspects of Perl, so that a complex program may be only a few
hundred lines long.</P>

<P>Perl is also fast, and works well with Libero.  The 'require'
statement lets me hide the generated code in a separate
file.</P>

<P>The Perl development cycle is simple: when you change your
dialog, re-run Libero.  When you change the Perl program, re-run
it.  Hint: get your hands on the 'Programming Perl' Nutshell
Handbook.</P>


<A NAME="rexx">&nbsp;</A>
<H2><A NAME="TOC71">The Rexx Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is Rexx?</DT>
<DD>Rexx is scripting language that originated on the IBM VM/CMS
operating system.  You'll find it on most IBM operating systems,
including PC-DOS 7 and OS/2.  It also comes in free and
commercial versions for many systems including MS-DOS and Unix.
</DD>
<DT>Portability</DT>
<DD>Rexx is available on many platforms. Rexx scripts are
fairly portable if you don't rely on system-dependent commands.
There is an ANSI standard for Rexx (X3J18) based on the book
"The Rexx Language" by Mike Cowlishaw (who designed Rexx).</DD>
<DT>Pros and Cons</DT>
<DD>Pros: Rexx is pretty portable from PC's up to big
mainframes.  Cons: it's an IBM-ish language, almost unknown in
the UNIX and Microsoft worlds.</DD>
<DT>How To Get It</DT>
<DD>It comes as part of most IBM operating systems (PC-DOS 7,
OS/2.)  You can get free versions from the Internet.</DD>
<DT>Libero Supports</DT>
<DD>Libero supports a portable Rexx syntax.</DD>
</DL>

<H3>Working With Rexx</H3>

<UL>
<LI><B>Schema:</B> lrschema.Rex.</LI>
<LI><B>Program model:</B> Rexx program.</LI>
<LI><B>Good for:</B> large Rexx programs.</LI>
<LI><B>Files used/made:</B> Own work in <TT>myprog.mod</TT>;
generates program called myprog.rx.</LI>
<LI><B>Module functions:</B>
<TT>module_function_name:</TT></LI>
<LI><B>Private functions:</B>
<TT>private_function_name :</TT>  (note the space before ':')</LI>
<LI><B>Naming style:</B> Any except -style=cobol.</LI>
<LI><B>Limits:</B> Standard Libero limits, and system memory.
All tables are defined dynamically at runtime.</LI>
<LI><B>Development cycle:</B> Run <TT>lr</TT> after you change
the dialog or <TT>.mod</TT> file.  When you add a new module,
run lr, then edit the <TT>.mod</TT> file, then run <TT>lr</TT>
again.  Don't change the generated Rexx script except for tests
- you'll lose your changes.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>
<PRE>
/******************   MODULE FUNCTION NAME   ******************/

module_function_name:
    Return                     /*  All modules end in Return  */

private_function_name :
    the_next_event = ok_event
    Call raise_exception (error_event)
    Return
</PRE>
<P><A HREF="doc/exprrex.mod">A fuller example.</A></P>


<A NAME="csh">&nbsp;</A>
<H2><A NAME="TOC72">The UNIX C Shell Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is C Shell?</DT>
<DD>The C shell (/bin/csh) is a UNIX shell 'for C programmers'.</DD>
<DT>Portability</DT>
<DD>The C shell is very standard across UNIX boxes, as far as I know.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: standard. Your scripts will run on most if not all UNIX boxes.
Looks a bit like C. Cons: limited and out-dated.  No functions. Looks a bit
like C.</DD>
<DT>How To Get It</DT>
<DD>Should be part of your UNIX system.</DD>
</DL>

<H3>Working With The UNIX C Shell</H3>

<UL>
<LI><B>Schema:</B> lrschema.c.</LI>
<LI><B>Program model:</B> executable UNIX script.</LI>
<LI><B>Good for:</B> complex scripts.</LI>
<LI><B>Files used/made:</B> own work in <TT>myprog.mod</TT>; generates script
called <TT>myprog</TT>.</LI>
<LI><B>Module functions:</B> <TT>module_function_name: #</TT></LI>
<LI><B>Private functions:</B> <TT>private_function_name:</TT></LI>
<LI><B>Naming style:</B> any except -style=cobol.</LI>
<LI><B>Limits:</B> 254 modules, 254 events, 1000 states.  The schema checks
at generate-time that the dialog does not exceed these limits.  All tables
are defined dynamically, at runtime.</LI>
<LI><B>Development cycle:</B> run <TT>lr</TT> after you change the dialog or
<TT>.mod</TT> file.  When you add a new module, run <TT>lr</TT>, then edit
the <TT>.mod</TT> file, then run <TT>lr</TT> again.  Don't change the
generated script except for hacking - you'll lose your changes.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>

<PRE>
#################   MODULE FUNCTION NAME   #################

module_function_name: #
    return                      # All modules end in 'return'

private_function_name:          # Actually, not possible
    set the_next_event=$ok_event
    raise_exception $error_event

</PRE>

<P>The C shell has no functions (unless I missed something), so I use
labelled blocks of code.  Each such block must end with 'return'.  The schema
defines this alias to do a goto back to the dialog engine code.  Frankly, I
can't understand who would write or use this shell.  Get Perl, and use that
instead.  Flames welcome. Nuff sed.</P>

<P>See also: <A href="lrdoc.htm#unix_shells">Note on UNIX shells</A>.</P>


<A NAME="bsh">&nbsp;</A>
<H2><A NAME="TOC73">The UNIX Bourne Shell Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is Bourne Shell?</DT>
<DD>The Bourne shell (/bin/sh) is the original UNIX shell. It is basic and
slow.  Most systems provided an extended version that supports functions.</DD>
<DT>Portability</DT>
<DD>There are at least two flavours of Bourne shell; with and without
functions.  The simplest is portable to probably all UNIX systems; the
extended Bourne shell to most UNIX systems (I know only one that does not
provide it: NeXT.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: Most standard shell. Cons: functionally poor; like all shells,
slower than Awk or Perl or C.</DD>
<DT>How To Get It</DT>
<DD>Should be installed on your UNIX system.</DD>
</DL>

<H3>Working With The UNIX Bourne Shell</H3>

<UL>
<LI><B>Schema:</B> lrschema.sh.</LI>
<LI><B>Program model:</B> executable UNIX script.</LI>
<LI><B>Good for:</B> complex scripts; portable to GNU systems.</LI>
<LI><B>Files used/made:</B> own work in <TT>myprog.mod</TT>; generates a
script called <TT>myprog</TT>.</LI>
<LI><B>Module functions:</B> <TT>module_function_name ()</TT></LI>
<LI><B>Private functions:</B> <TT>private_function_name ()</TT>.  Since there
is no way to distinguish module functions from private functions, the schema
turns-off idle module checking.</LI>
<LI><B>Naming style:</B> any except -style=cobol.</LI>
<LI><B>Limits:</B> 254 modules, 254 events, 1000 states.  The schema checks
at generate-time that the dialog does not exceed these limits.  All tables
are defined dynamically, at runtime.</LI>
<LI><B>Development cycle:</B> run <TT>lr</TT> after you change the dialog or
<TT>.mod</TT> file.  When you add a new module, run <TT>lr</TT>, then edit
the <TT>.mod</TT> file, then run <TT>lr</TT> again.  Don't change the
generated script except for hacking - you'll lose your changes.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>
<PRE>
#################   MODULE FUNCTION NAME   #################

module_function_name ()
{
    return                      # Empty module needs 'return'
}

private_function_name ()
{
    the_next_event=$ok_event
    raise_exception $error_event
}
</PRE>

<P>See also: <A href="lrdoc.htm#unix_shells">Note on UNIX shells</A>.</P>


<A NAME="ksh">&nbsp;</A>
<H2><A NAME="TOC74">The UNIX Korn Shell Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is Korn Shell?</DT>
<DD>The Korn shell (/bin/ksh) is the most advanced 'standard' UNIX shell. It
extends the Bourne shell with lots of nice features, and is a lot faster.</DD>
<DT>Portability</DT>
<DD>The Korn shell is standard when available, but is not supplied on all UNIX
boxes.</DD>
<DT>Pros and Cons</DT>
<DD>Pros: supplied on most UNIXes; your scripts will run quickly. Cons: like
all shells, slower than Awk or Perl or C.</DD>
<DT>How To Get It</DT>
<DD>Korn shell is available in a public-domain version (by Eric Baalberger)
for Linux.</DD>
</DL>

<H3>Working With The UNIX Korn Shell</H3>

<UL>
<LI><B>Schema:</B> lrschema.ksh.</LI>
<LI><B>Program model:</B> executable UNIX script.</LI>
<LI><B>Good for:</B> complex scripts; portable to GNU systems.</LI>
<LI><B>Files used/made:</B> own work in <TT>myprog.mod</TT>; generates a
script called <TT>myprog</TT>.</LI>
<LI><B>Module functions:</B>
<PRE>
function module_function_name
{
</PRE></LI>
<LI><B>Private functions:</B> <TT>function private_function_name {</TT></LI>
<LI><B>Naming style:</B> any except -style=cobol.</LI>
<LI><B>Limits:</B> 254 modules, 254 events, 1000 states.  The schema checks
at generate-time that the dialog does not exceed these limits.  All tables
are defined dynamically, at runtime.</LI>
<LI><B>Development cycle:</B> run <TT>lr</TT> after you change the dialog or
<TT>.mod</TT> file.  When you add a new module, run <TT>lr</TT>, then edit
the <TT>.mod</TT> file, then run <TT>lr</TT> again.  Don't change the
generated script except for hacking - you'll lose your changes.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>
<PRE>
#################   MODULE FUNCTION NAME   #################

function module_function_name
{
    return                      # Empty module needs 'return'
}

function private_function_name {
    the_next_event=$ok_event
    raise_exception $error_event
}
</PRE>

<P><A HREF="doc/install.mod">A fuller example.</A></P>
<P>See also: <A href="lrdoc.htm#unix_shells">Note on UNIX shells</A>.</P>


<A NAME="80x86">&nbsp;</A>
<H2><A NAME="TOC75">The 80x86 Assembler Language</A></H2>

<H3>Overview</H3>

<DL>
<DT>What Is 80x86 Assembler?</DT>
<DD>This is the native language for most of the world's PCs. It is fast and
dangerous.  It gives you a 5-to-10 performance improvement over the best C
compilers.</DD>
<DT>Portability</DT>
<DD>Very portable to all compatible CPU's. Comes in various varieties,
following the evolution in 80x86 CPU's.  The lowest-common denominator is the
16-bit 8086.</DD>
<DT>Pros and Cons</DT>
<DD>Pros - can't get it faster; can't make it smaller. Cons: multiply your
development and maintenance costs by ten.</DD>
<DT>How To Get It</DT>
<DD>There are various free and shareware assemblers around, which are not all
compatible in terms of syntax.  The 'standards' are the Borland TASM and
Microsoft MASM products.</DD>
<DT>Libero Supports</DT>
<DD>MS MASM 5.0: .com files, .exe files, and subroutines.</DD>
</DL>

<H3>Working With 80x86 Assembler</H3>

<UL>
<LI><B>Schema:</B> lrschema.asm.</LI>
<LI><B>Program model:</B> .EXE file, .COM file, or large-model C
subroutine.</LI>
<LI><B>Good for:</B> anything complex in assembler.</LI>
<LI><B>Files used/made:</B> own work in <TT>myprog.asm</TT>; generates an
include file <TT>mydialog.d</TT>.</LI>
<LI><B>Module functions:</B>
<PRE>
MODULE module_function_name
 ...
ENDMODULE
</PRE></LI>
<LI><B>Private functions:</B>
<PRE>
private_function_name PROC NEAR
  ...
ENDP
</PRE></LI>
<LI><B>Naming style:</B> schema sets -style=plain automatically.</LI>
<LI><B>Limits:</B> 255 states, 254 modules, 253 events.  The schema checks at
generate-time that the dialog does not exceed these limits. All tables are
defined statically, at assembly time.</LI>
</UL>

<H3>Example of code</H3>

<P>Code fragments:</P>
<PRE>
;****************   MODULE FUNCTION NAME   *****************

MODULE module_function_name
       ret                        ; All modules end in 'ret'
ENDMODULE

private_function_name proc near
    mov the_next_event,ok_event
    raise_exception error_event
endp
</PRE>

<P><A HREF="doc/exprcom.asm">A fuller example.</A></P>

<H4>Specific Schema Options</H4>

<UL>
<LI><B>-opt:model=com</B> - generate code for a .COM program.  This is the
default model.</LI>
<LI><B>-opt:model=exe</B> - generate code for an .EXE program.</LI>
<LI><B>-opt:stack_size=nnnn</B> - size of stack for .EXE program; default is
1024.</LI>
<LI><B>-opt:model=lsub</B> - generate code for a large-model subroutine using
the Microsoft/Borland C calling convention.</LI>
</UL>

<P>The schema provides these data items, macros, and functions (above the
standard ones provided by all schemas):</P>

<UL>
<LI><TT>msg_helptext</TT> - example of help message; change to suit (COM, EXE
only).</LI>
<LI><TT>arg_text db 128 dup(0)</TT> - command line arguments, null-terminated
(COM, EXE only).</LI>
<LI><TT>arg_size db 0</TT> - size of arguments (0 = none) (COM, EXE
only).</LI>
<LI><TT>arg_help db 0</TT> - 1 if /? was specified on command line, else 0
(COM, EXE only).</LI>
<LI><TT>newline db '\n',0</TT> - newline as null-terminated string.</LI>
<LI><TT>the_next_event dw 0</TT> - next event from module.</LI>
<LI><TT>the_exception_event dw 0</TT> - exception event from module.</LI>
<LI><TT>exception_raised db 0</TT> - 1 if exception raised.</LI>
<LI><TT>feedback db 0</TT> - return code to system.</LI>
<LI><TT>xxxx_event</TT> - macro: defined for each event in the dialog, where
'xxxx' is the name used in the dialog.</LI>
<LI><TT>terminate_event</TT> - macro: when you move this to the_next_event,
the state machine halts.</LI>
<LI><TT>raise_exception</TT> - macro: raises an exception and sets
the_exception_event to the event specified.</LI>
<LI><TT>pushr</TT> -  macro: push one or more registers onto stack.</LI>
<LI><TT>popr</TT> - macro: pop one or more registers from stack.</LI>
<LI><TT>jmps</TT> - macro: short jump.</LI>
<LI><TT>echo</TT> - function: prints null-terminated message at DS:SI.  The
sequence \n is treated as newline.  All registers are safe except flags.</LI>
<LI><TT>echoch</TT> - function: prints character in AL using BIOS tty
function.  Does not change any registers except the flags.</LI>
<LI><TT>echonum</TT> - function: displays the value in AX as a signed decimal
number with one leading space, and optional sign.  Does not change any
registers except the flags.  Number is in range 32768..32767</LI>
<LI><TT>pause</TT> - function: waits for a keystroke; if [Esc] pressed, exits
program.  Does not change any registers except the flags.</LI>
</UL>

<H4>Programming with the COM model</H4>

<UL>
<LI>Assemble and link as a .COM file:
<PRE>
    masm $source;
    link $source;
    exe2bin $source.exe $source.com
    del $source.exe
</PRE></LI>
<LI>Code, data, and stack are in same segment: <TT>CS</TT>, <TT>DS</TT>,
<TT>ES</TT>, and <TT>SS</TT> point to the one segment, and never change.</LI>
</UL>

<H4>Programming with the EXE model</H4>

<UL>
<LI>Assemble and link as an .EXE file:
<PRE>
    masm $source;
    link $source;
</PRE></LI>
<LI>Code, data, and stack each have their own segment.  <TT>DS</TT> and
<TT>ES</TT> both point to the data segment.  Default stack size is 1024; you
can ask for a larger stack using '-opt:stack_size=nnnn'.</LI>
</UL>

<H4>Programming with the LSUB model</H4>

<UL>
<LI>Assemble and link with a large-model calling program
<PRE>
    masm $source;
    link caller+$source;
</PRE></LI>
<LI>Code, data, and stack each have their own segment.  <TT>DS</TT> and
<TT>ES</TT> both point to the data segment.  Stack is provided by calling
program.</LI>

<LI>The <TT>FUNCTION_OPEN</TT> macro defines the interface between your
function and calling programs.  The default is for C programming. In the
generated skeleton program, change the definition of <TT>function</TT> to
suit the name of your function.  Note that it must start with '_' for C
programming.  Define any parameters following the example param1 shown.  The
parameters to a function are passed on the stack starting at &lt;6[BP]&gt;.
Don't make these changes to the skeleton, but to the program that Libero
generates for you the first time.</LI>
</UL>

<H4>Programming with all models</H4>

<UL>
<LI>Do not rely on registers being safe between modules.  The dialog code
uses these freely without saving them.</LI>
<LI>You can freely use any of the working registers (AX, BX, CX, DX, ES, DS,
DI, SI) in a module function.</LI>
<LI>In a LSUB model program, do not change BP.</LI>
<LI>In an EXE or LSUB model program, ES is initialised to be equal to
DS.</LI>
</UL>







<H1><A NAME="TOC76">Libero Technical Reference</A></H1>


<H2><A NAME="TOC77">A First Look At Code Generation</A></H2>

<H3><A NAME="TOC78">The Schema</A></H3>

<UL>
<LI>The schema is like a program or script.  It tells the code generator what
to do, when, and how.  Libero executes the schema from start to end.

<LI>The code generator has a few ideas about what it has to generate, but the
schema usually has to tell it more.  For example, the schema can say 'please
generate numbers with 3 digits like this: 001'.

<LI>The schema decides what files to generate, under what conditions.  It
decides what they are called, and what they contain.
</UL>

<P>This is the basic logic of Libero's code generator:
<UL>
<LI>Read the schema line by line; ignore comment lines.

<LI>If the line contains a schema command, execute the command.

<LI>If the line does not contain a command, write it to the current output
file, if any.  If no output file is open, discard it.
</UL>

<P>This is a 'hello world' schema:

<PRE>
:echo "Hello, World."
</PRE>

<P>This is more realistic schema fragment:

<PRE>
!  Example Libero of schema
!
:if not exist $source.c
:echo "lr I: creating skeleton program $source.c..."
:output $source.c
/*===============================================================
 *  $source.c   description...
 *  Written:    $date       $author
 *  Revised:    $date
 *  Skeleton generated by LIBERO $version on $fulldate, $time.
 *===============================================================*/

#include "$dialog.d"                    /*  Include dialog data  */

/********************   INITIALISE THE PROGRAM  ******************/

MODULE $"initialise_the_program" (void)
{
    $"the_next_event" = $"ok_event";
}
:close
:endif
</PRE>

<P>How does this schema work?
<UL>
<LI>Any lines that starts with '!' is as a comment.  The code generator
discards all such lines.

<LI>Libero looks for names starting with '$', and replaces these by the value
of that variable.  Libero supplies a set of standard variables like '$date'
and '$source'.  You can also define your own variables.

<LI>When a line starts with ':xxxx', this is read by Libero as a schema
command.  Typical commands are ':if', ':echo'. ':open'. Command lines can
include variables.

<LI>Any other line is copied to the currently-open output.
</UL>

<P>When Libero replaces variables, it keeps the text as aligned as possible
by treating white-space (blanks or tabs) as elastic.  For instance, here is
some 'C' code before and after replacement. Notice how the right-hand margin
does not move:

<PRE>
/*  Source generated on $date - Libero $version                */
/*  Source generated on 93/07/12 - Libero 2.10                 */
</PRE>

<P>A variable name ends with the first non-name character (A-Z, a-z, 0-9, _).
To mark the end of a variable name that is 'pasted' to some text, use a '\'.
For instance, this is a line before and after inserting the $source
variable:

<PRE>
    :output $source\d.d
==&gt; :output myprogd.d
</PRE>

<P>If you capitalise (at least) the first letter of a variable name, Libero
inserts the whole value in uppercase.  For example:

<PRE>
    :output $Source\d.d
==&gt; :output MYPROGd.d
</PRE>

<P>To output a name that matches the current -style setting, do this
(e.g. -style=caps):

<PRE>
    $"the_next_event" = $"ok_event";
==&gt; TheNextEvent = OkEvent;
</PRE>

<P>To output a '$', use two '$'s together:

<PRE>
    $"the_next_event" = $$$"ok_event";
==&gt; TheNextEvent = $OkEvent;
</PRE>


<H2><A NAME="TOC79">Read-Only Variables</A></H2>

<P>You can use these read-only variables anywhere in a schema:

<DL>
<DT>$author</DT>
<DD>The value of the -author option.</DD>
<DT>$date</DT>
<DD>The current date in a shortened form: 'yy/mm/dd'. Libero
always uses this date format for short dates.</DD>
<DT>$time</DT>
<DD>The current time in a shortened form: 'hh:mm'.</DD>
<DT>$fulldate</DT>
<DD>The current date in a long form: 'dd Mmm, yyyy'. The month
is abbreviated to 3 letters, in English.</DD>
<DT>$fulltime</DT>
<DD>The current time including seconds: 'hh:mm:ss'.</DD>
<DT>$out_count</DT>
<DD>The number of lines output so far, including the current
line.  This starts at 1.</DD>
<DT>$dialog</DT>
<DD>The name of the dialog file being processed, without
extension.</DD>
<DT>$schema</DT>
<DD>The name of the schema being read.  This is the value of the
-schema option.</DD>
<DT>$source</DT>
<DD>The name of the source file for dialog, without an
extension.  This name is derived as follows: normally, it is the
same as the dialog file name.  If -plusd was specified, it is
formed by adding 'D' to the dialog file name.  If -source=xxx
was used, this explicitly tells the source name to use.</DD>
<DT>$style</DT>
<DD>The value of the -style option.</DD>
<DT>$defaults</DT>
<DD>The number of the defaults state, or zero if none was
specified.</DD>
<DT>$events</DT>
<DD>The number of events in the dialog.  This is used to
dimension various tables.</DD>
<DT>$maxaction</DT>
<DD>The maximum action number (largest vector).  This is used to
dimension various tables.</DD>
<DT>$modules</DT>
<DD>The number of modules in the dialog.  This is used to
dimension various tables.</DD>
<DT>$states</DT>
<DD>The number of states in the dialog.  This is used to
dimension various tables.</DD>
<DT>$vectors</DT>
<DD>The number of action vectors in the dialog.</DD>
<DT>$version</DT>
<DD>The current Libero version number as 4 characters: 'n.nn';
e.g. '2.32'.</DD>
</DL>
<P>Additionally, you can use <TT>$comma</TT>, <TT>$name</TT>,
<TT>$number</TT>, <TT>$offset</TT>, <TT>$tally</TT>, <TT>$row</TT>, and
<TT>$overflow</TT> within a <TT>:do</TT> block.  These variables are
explained later.  You cannot define a variable with the name of a standard
Libero variable.


<H2><A NAME="TOC80">Schema Commands</A></H2>

<P>You can use the following commands in a schema:
<DL> <DT>:output <I>filename</I></DT>
<DD>Sends output to <I>filename</I>.  Any existing data in the
file is lost.</DD>
<DT>:extend <I>filename</I></DT>
<DD>Appends output to <I>filename</I>.  Creates the file if it
does not already exist.</DD>
<DT>:close</DT>
<DD>Closes an output file opened by a previous <TT>:output</TT>
or <TT>:extend</TT>.  This command is never required, since
Libero does an implicit <TT>:close</TT> before any
<TT>:output</TT> or <TT>:extend</TT>, and at the end of the
schema.  If you use <TT>:close</TT> when no file is open you'll
get a warning message.</DD>
<DT>:copy <I>fromfile</I> <I>tofile</I></DT>
<DD>Copies one file to another.  The <I>tofile</I> is silently
overwritten if it already exists.</DD>
<DT>:rename <I>fromfile</I> <I>tofile</I></DT>
<DD>Renames one file to another.  The <I>tofile</I> may not
already exist.</DD>
<DT>:delete <I>filename</I></DT>
<DD>Deletes <I>filename</I> without any error if the file does
not exist.</DD>
<DT>:include [optional] <I>filename</I> [<I>from</I>
[<I>to</I>]]</DT>
<DD>Includes <I>filename</I> in the generated output code.  If
you specify <I>from</I>, Libero searches the file for a line
containing this text by itself, and starts copying from that
point on.  If you specify <I>to</I>, Libero ends copying when it
finds a line containing just this text.  You can put quotes
around from and to if these contain embedded spaces.  If you
use the optional keyword, Libero ignores the <TT>:include</TT>
command if it can't find the specified file.  The included file
can be anywhere on the path value.</DD>
<DT>:echo <I>text</I></DT>
<DD>Echoes <I>text</I> to the standard output, followed by a
newline.  If the text is enclosed in quotes, leading spaces are
not discarded.</DD>
<DT>:declare [int | string] [$]<I>name</I>
[=<I>expression</I>]</DT>
<DD>Defines a variable for later use in the schema.  Except for
those that Libero supplies as standard, you have to declare any
variables that you want to use. You can specify the variable
name with or without a '$' in the name.<BR> Variables are
either integers, strings, or variants (either type depending on
mood).  You cannot assign a string expression to an integer.
Otherwise Libero is pretty relaxed about how you mix variable
types.  The expression provides a default initial value for the
variable.  If you do not provide an initial value, strings are
empty and numbers are zero.  You can override any initial value
using an <TT>-option</TT> on the command-line or in the dialog.
Use: <TT>-opt:var="string"</TT> or <TT>
opt:var=expression</TT>.<BR> The name of a variable cannot be
<TT>int</TT> or <TT>string</TT>.  Variable names are
case-independent; <TT>:declare $drink</TT> and <TT>:declare
$DRINK</TT> refer to the same variable. If you declare an
existing variable, you'll get an error message.</DD>
<DT>:set [$]<I>name</I> = <I>expression</I></DT>
<DD>Assigns a new value to the variable specified.  You can use
a '$' before the variable name if you want to.  You cannot set a
read-only variable.</DD>
<DT>:push [$]<I>variable</I> [=<I>expression</I>]</DT>
<DD>Creates a new instance of the variable.  If you give an
expression the new variable gets this value.  The variable must
then be a read-write variable.  You can push a read-only
variable but not specify an expression.  This may sound
pointless, but can be useful: you can set some read-only
variables using the <TT>:option</TT> command, e.g. <TT>:option
-style=xxxx.</TT></DD>
<DT>:pop [$]<I>variable</I></DT>
<DD>Removes the last instance of a variable.  Use with
<TT>:push</TT> to change a variable within a block, then reset
it to its previous value.</DD>
<DT>:do <I>condition</I></DT>
<DD>Starts a code block that is output repeatedly depending on
condition.  Libero defines a standard set of conditions like
<TT>:do event</TT>.  You can also define your own conditions
using <TT>:do while</TT>  The do block ends with a matching
<TT>:enddo</TT>.</DD>
<DT>:do while <I>logical-condition</I></DT>
<DD>Repeats the code block while the logical_condition is
true.</DD>
<DT>:enddo [<I>condition</I>]</DT>
<DD>Ends the closest previous <TT>:do</TT> block.  If you
specify condition, the <TT>:do</TT> and <TT>:enddo</TT>
conditions must match; this makes your schemas more robust
against errors, but is not required.</DD>
<DT>:if <I>logical-condition</I></DT>
<DD>Starts a code block that is output if
<I>logical_condition</I> is true.  The <TT>:if</TT> block ends
with a matching <TT>:endif</TT>.</DD>
<DT>:else</DT>
<DD>Outputs the following block of code if the previous
<TT>:if</TT> condition was false.</DD>
<DT>:endif [all]</DT>
<DD>Ends the closest previous <TT>:if</TT> block.  If you
specify <TT>all</TT>, all open <TT>:if</TT>blocks are
closed.</DD>
<DT>:exit [<I>level</I>]</DT>
<DD>Aborts code generation.  Use levels 0 for okay, 1 for
errors.</DD>
<DT>:option -<I>name</I>[=<I>value</I>]</DT>
<DD>Enforces a Libero option For example: <TT>:option
-style=cobol</TT>.</DD>
<DT>:internal <I>module</I></DT>
<DD>Tells the code-generator that <I>module</I> is required by
the generated dialog code, but not by the dialog.  A typical
case is <TT>initialise_the_program</TT>.  This lets Libero
correctly indicate unused modules in the source code.</DD>
<DT>:substr <I>from</I> [<I>size</I>]</DT>
<DD>Specifies a substring for the next <TT>$name</TT> or
<TT>$row</TT> insertion.  <I>From</I> must be from 1 upwards.
If <I>size</I> is not specified, the remainder of the variable's
value is used.</DD>
</DL>

<H3><A NAME="TOC81">Notes</A></H3>

<UL>
<LI>All commands can contain variables anywhere in the line that makes
sense.

<LI>You can use '#' to start a comment in a command line.  Any text following
the '#' is ignored.  When a '#' is inside a string, or escaped by '\', it is
treated as the '#' character, not a comment.  You can change the comment
character by setting <TT>$comment_ind</TT>.

<LI>A line containing just ':' by itself is ignored.  This lets you separate
blocks of commands without outputting extra blank lines in the code.  For
instance:
<PRE>
  :if $index &gt; 0
  :  set $counter = $counter + 1
  :endif
  :
  :echo "\ncounter is $counter\n"
</PRE>

<LI>In a <TT>:set</TT> or <TT>:declare</TT> you can give the variable name
with or without the $.  Your preference will depend on the other languages
you use.  When I've used Perl a while, I want to stick a '$' everywhere.
When I've programmed in a UNIX shell, I want the $ only on the right.  When
I've been working in any other language I can't understand what all the fuss
is about, I just want something that works like I expect it to.  So, since
the meaning is unambiguous, Libero accepts both.

<LI>One or more spaces can come between the ':' and the command name.  This
is often a nice way to indent commands to show structure.
</UL>


<H2><A NAME="TOC82">Syntax Of Expressions</A></H2>

<P>The <TT>:set</TT> and <TT>:declare</TT> commands assign the value of an
expression to a variable.  A couple of examples:

<PRE>
:declare $count = 0
:set $count = $count + 1
</PRE>

<P>Libero handles the expression depending on the type of the variable:
<UL>
<LI>If it is an int, it looks for an arithmetic expression.

<LI>If it is a string, it treats the whole expression as a string.  Quotes
are optional; you should use these if the string contains spaces.

<LI>If the variable is a variant, Libero tries to evaluate the expression as
an arithmetic expression.  If this works, the variable gets the resulting
number as its new value.  If this fails, the variable gets the string as its
value.  To be certain to assign a string, use quotes.
</UL>

<P>An arithmetic expression can include '+', '-', '*', '/', parentheses.  All
number are four-byte signed long values, i.e. fall into the range
+2,147,483,647 to -2,147,483,648.

<P>Things pretty much work as you would expect, I hope.  In practice I always
declare variables as <TT>int</TT> or <TT>string</TT> and put explicit quotes
around strings.


<H2><A NAME="TOC83">Syntax Of Logical Conditions</A></H2>

<P>The <TT>:if</TT> and <TT>:do while</TT> commands output some code
depending on a logical-condition.  Some examples:

<PRE>
:if $debug
:  echo "version is $version"
:endif
:do while $counter &gt; 0
   ...
:enddo
</PRE>

<P>A logical condition has two possible forms:

<PRE>
:if [not] [test] <I>expr1</I> [<I>logical_operator</I> <I>expr2</I>]
:while [not] [test] <I>expr1</I> [<I>logical_operator</I> <I>expr2</I>]

:if [not] [<I>standard_test</I>]
:while [not] [<I>standard_test</I>]
</PRE>

<H3><A NAME="TOC84">Logical Operators</A></H3>

<P>You can make a condition by comparing two expressions.  The 'test' keyword
is optional and I normally don't use it.  The expressions can be numeric or
string; if either is a string, Libero treats both as strings.  The logical
operator can be one of:

<P>These are the logical operators:
<UL>
<LI><TT>=</TT> - <I>expr1</I> is equal to <I>expr2</I>. <TT>==</TT> is also
okay.

<LI><TT>&lt;&gt;</TT> - <I>expr1</I> is not equal to <I>expr2</I>.
<TT>!=</TT> is also okay.

<LI><TT>&lt;</TT> - <I>expr1</I> is less than <I>expr2</I>.

<LI><TT>&lt;=</TT> - <I>expr1</I> is less than or equal to <I>expr2</I>.

<LI><TT>&gt;</TT> - <I>expr1</I> is greater than <I>expr2</I>.

<LI><TT>&gt;=</TT> - <I>expr1</I> is greater than or equal to
<I>expr2</I>.
</UL>

<H3><A NAME="TOC85">Standard Tests</A></H3>

<P>Libero provides these standard tests:
<DL>
<DT>exist <I>filename</I></DT>
<DD><I>filename</I> exists in the current directory.</DD>
<DT>animate</DT>
<DD>The dialog uses the -animation option.</DD>
<DT>check</DT>
<DD>The dialog uses the -check option.</DD>
<DT>caps</DT>
<DD>The dialog uses the -style=caps option.</DD>
<DT>cobol</DT>
<DD>The dialog uses the -style=cobol option.</DD>
<DT>headline</DT>
<DD>The dialog uses the -style=headline option.</DD>
<DT>normal</DT>
<DD>The dialog uses the -style=normal option.</DD>
<DT>plain</DT>
<DD>The dialog uses the -style=plain option.</DD>
<DT>title</DT>
<DD>The dialog uses the -style=title option.</DD>
<DT>defaults</DT>
<DD>The dialog defines a Defaults state.</DD>
<DT>state <I>name</I></DT>
<DD><I>name</I> is a state in the dialog.</DD>
<DT>event <I>name</I></DT>
<DD><I>name</I> is an event in the dialog.</DD>
<DT>module <I>name</I></DT>
<DD><I>name</I> is a module in the dialog.</DD>
</DL>


<H2><A NAME="TOC86">Control Variables</A></H2>

<P>Libero supplies various <I>control variables</I>.  A control variable
affects some aspects of code generation; you set the control variable to tell
Libero how to handle something specific for the language you want to
generate.  Control variables are usually 'write-only'.  You don't normally
refer to these variables in the code, though you can if you want to.  To
change a control variable you use the <TT>:set</TT> command:
<DL>
<DT>$array_base</DT>
<DD>Specifies the base value for tables.  You use this when
building an array of values.  By default this is 0; in some
languages it is more useful to start at 1.  The
<TT>$array_base</TT> affects the value of <TT>$number</TT> in a
<TT>:do</TT> block.</DD>
<DT>$comma_before</DT>
<DD>This value is used as <TT>$comma</TT> when the current item
being output is not the last.  Default is <TT>","</TT>.</DD>
<DT>$comma_last</DT>
<DD>This value is used as <TT>$comma</TT> when the current item
being output is the last. Default is empty.</DD>
<DT>$comment_ind</DT>
<DD>Comment indicator in schema command lines. Default is
'#'.</DD>
<DT>$module_line</DT>
<DD>libero looks for single lines that look like this when
creating new module stubs.  By default: <TT>"MODULE %s
(void)"</TT>. The '%s' symbol represents the module name.</DD>
<DT>$number_fmt</DT>
<DD>This value is used to format the <TT>$number</TT> value;
numbers are always signed long ints.  It must be a valid printf
format string.  Default is <TT>"%ld"</TT>.</DD>
<DT>$row_first</DT>
<DD>This value is used to format the first numeric item in a
<TT>$row</TT> value.  It must be a valid printf format string.
Default is <TT>"%ld"</TT>.</DD>
<DT>$row_after</DT>
<DD>This value is used to format numeric items in a
<TT>$row</TT> value after the first one.  It must be a valid
printf format string.  Default is <TT>",%ld"</TT>.</DD>
<DT>$row_clean</DT>
<DD>Tells Libero to clean-up overflow rows.  You get overflow
rows when you generate a table that is wider than the
<TT>$row_width</TT>.  When <TT>$row_clean</TT> is 1, Libero
removes any non-numeric data from the start of overflow rows.
When 0, Libero leaves overflow rows as they are.  Default is
0.</DD>
<DT>$row_null</DT>
<DD>This value is used in <TT>$row</TT>s when there is no event
defined in a certain state.  This is by default 0, but can be
set to any numeric value by the schema.</DD>
<DT>$row_width</DT>
<DD>Maximum space, in characters, for a <TT>$row</TT> item in
the generated source.  Default is the compile-time constant
<TT>LR_ROW_WIDTH</TT>, defined as 60.  Rows longer than this
are chopped into 'overflow' pieces.</DD>
<DT>$run_away</DT>
<DD>If a <TT>:do</TT> loop does more than this number of
iterations, Libero halts it with an error message.  Default is
the compile-time constant LR_RUNAWAY_LIMIT, defined as 1000.
This lets you generate at  least a table with the maximum
number ofstates, events, or modules (up to 1000 depending on
the schema).</DD>
<DT>$stub_before</DT>
<DD>Used to generate new module stubs.  If this string value is
not empty, it is output before each module stub header. By
default it is <TT>""</TT> (empty).</DD>
<DT>$stub_between</DT>
<DD>Used to generate new module stubs: this string value is
repeated to build-up a stub header.  Default is
<TT>"*"</TT>.</DD>
<DT>$stub_first</DT>
<DD>Used to generate new module stubs: this string value is
output at the start of a stub header line.  Default is
<TT>"/"</TT>.</DD>
<DT>$stub_last</DT>
<DD>Used to generate new module stubs: this string value is
output at the end of a stub header line.  Default is
<TT>"/"</TT>.</DD>
<DT>$stub_width</DT>
<DD>Used to generate new module stubs: defines the width of the
stub line.  Default is the compile-time constant
<TT>LR_HEADER_WIDTH</TT>, defined as 79.</DD>
</DL>
<P>To see the value that a control variable had for
code-generation, use the -trace option when you generate code.
 The <TT>.lst</TT> file produced shows
the symbol table, including all control variables, as code
generation
ended.


<H2><A NAME="TOC87">Standard :do Conditions</A></H2>

<P>Libero defines this set of :do conditions:
<DL>
<DT>:do action</DT>
<DD>For each state defined in the dialog; generates the action
for each event in each state.</DD>
<DT>:do event</DT>
<DD>For each event defined in the dialog.</DD>
<DT>:do event local</DT>
<DD>For each event defined in the current :do state.</DD>
<DT>:do module</DT>
<DD>For each dialog module defined in the dialog.</DD>
<DT>:do module local</DT>
<DD>For each dialog module defined in the current :do event.</DD>
<DT>:do nextst</DT>
<DD>For each state defined in the dialog; generates the
next-state for each event in each state.</DD>
<DT>:do state</DT>
<DD>For each state defined in the dialog.</DD>
<DT>:do stubs [filename]...</DT>
<DD>For each dialog module defined in the dialog, but not yet
present in the source file (or filename(s) if specified).</DD>
<DT>:do vector</DT>
<DD>For each action vector required by the dialog.  An action
vector is the list of modules to execute for an event in a
state.  Libero collects these and builds a list of unique action
vectors.</DD>
</DL>

<P>You cannot nest these standard :do loops cannot be nested (i.e. twice the
same condition).


<H2><A NAME="TOC88">Extra Variables In A :do Loop</A></H2>

<P>Within the different types of :do loop, various extra variables are
available.  Usually you'll need these to construct tables or lists of
names.

<H3><A NAME="TOC89"><TT>:do while</TT> <I>condition</I></A></H3>
<P>Repeats the block of code while <I>condition</I> is true.  The condition
is a logical condition as described above.  The loop is executed 0..n
times.
<UL>
<LI><TT>$number</TT> - loop iteration 0..n-1, added to $array_base.
</UL>

<H3><A NAME="TOC90"><TT>:do event</TT></A></H3>
<P>Builds a list of events.  Outputs the block for each event in the
dialog.
<UL>
<LI><TT>$name</TT> - event name, with <TT>_event</TT> stuck onto the end, and
formatted using the current -style setting.
<LI><TT>$number</TT> - event number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
</UL>

<H3><A NAME="TOC91"><TT>:do event local</TT></A></H3>
<P>Builds a list of events.  Outputs the block for each event in the
current state, within a :do state loop.  Provides the same variables
as :do event, and also:
<UL>
<LI><TT>$next_state</TT> - name of next state, for this event.
</UL>

<H3><A NAME="TOC92"><TT>:do state</TT></A></H3>
<P>Builds a list of states.  Outputs the block for each state in the
dialog.
<UL>
<LI><TT>$name</TT> - state name, formatted using the current -style
setting.
<LI><TT>$number</TT> - state number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
</UL>

<H3><A NAME="TOC93"><TT>:do module</TT></A></H3>
<P>Builds list of modules.  Outputs the block for each module in the
dialog.
<UL>
<LI><TT>$name</TT> - module name, formatted using the current -style
setting.
<LI><TT>$number</TT> - module number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
</UL>

<H3><A NAME="TOC94"><TT>:do action</TT></A></H3>
<P>Builds table containing one row per state, with one item per row for each
event transition.  Each item is the number of an action vector.  Invalid
state/event transitions are filled by the value of <TT>$row_null</TT>.
<UL>
<LI><TT>$row</TT> - value of row, formatted according to <TT>$row_first</TT>,
<TT>$row_after</TT>, and <TT>$row_null</TT>.
<LI><TT>$number</TT> - state number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
<LI><TT>$offset</TT> - offset of start of current row, added to
<TT>$array_base</TT>.  The offset is counted up by 1 for each item in a
row.
<LI><TT>$tally</TT> - number of items in <TT>$row</TT>.
</UL>

<H3><A NAME="TOC95"><TT>:do nextst</TT></A></H3>
<P>Builds table containing one row per state, with one item per row for each
event transition.  Each item is the number of the next state.  Invalid
state/event transitions are marked by the value of <TT>$row_null</TT>.
<UL>
<LI><TT>$row</TT> - value of row, formatted according to <TT>$row_first</TT>,
<TT>$row_after</TT>, and <TT>$row_null</TT>.
<LI><TT>$number</TT> - state number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
<LI><TT>$offset</TT> - offset of start of current row, added to
<TT>$array_base</TT>.  The offset is counted up by 1 for each item in a
row.
<LI><TT>$tally</TT> - number of items in <TT>$row</TT>.
</UL>

<H3><A NAME="TOC96"><TT>:do vector</TT></A></H3>
<P>Builds table of action vectors.  An action vector is a list of modules
executed in series for a state/event transition.  Duplicate vectors are
collapsed.
<UL>
<LI><TT>$row</TT> - action vector, formatted according to
<TT>$row_first</TT>, <TT>$row_after</TT>, and <TT>$row_null</TT>.
<LI><TT>$number</TT> - vector number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
<LI><TT>$offset</TT> - offset of start of current row, added to
<TT>$array_base</TT>.  The offset is counted up by 1 for each item in a
row, including an assumed terminator value (0xFFFF).
<LI><TT>$tally</TT> - number of items in <TT>$row</TT>, including one
terminator value.
</UL>

<H3><A NAME="TOC97"><TT>:do overflow</TT></A></H3>
<P>Used to build source code that has to be output over several lines.  The
block is output until the overflow row is empty.
<UL>
<LI><TT>$row</TT> - overflow row, ie. part of main <TT>$row</TT> that did not
fit onto first line.
<LI><TT>$number</TT> - iteration number 0..n-1, added to
<TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
<LI><TT>$tally</TT> - number of items in <TT>$row</TT>.
</UL>

<H3><A NAME="TOC98"><TT>:do stubs</TT> [<I>filename</I>]...</A></H3>
<P>Builds a set of module stubs at the end of the filename.  If no filename
is specified, assumes you mean the $source file.  You can specify a list of
filenames; then Libero will scan each file in the list for existing modules,
and build stubs for any undefined modules at the end of the first filename.
This is useful if you define standard modules in generated code (e.g. an
include file).

<P>If you use the -nostubs option, Libero ignores the :stubs command.  If you
use the -noidle option, Libero does not check the source for idle (ie.
unused) modules.



<H2><A NAME="TOC99">General Rules for Code Generation</A></H2>

<UL>
<LI>A string may be delimited by a single or double quote character.
<LI>Inside a string, the sequence '\n' is treated as a newline character.
The sequence '\t' is treated as a tab character.  Any other character
prefixed by '\' is treated as itself.
<LI>Libero issues a warning message if a non-blank line has to be discarded
because there is no output open.
<LI>If you have trouble generating what you want, use the -trace option: this
shows each schema line, before and after any variable expansion.
</UL>


<H2><A NAME="TOC100">Generating Module Stubs</A></H2>

<P>Take a hypothetical language where a module stub looks like
this:

<PRE>
//###################  SOME FUNCTION   ##################//

MODULE some_function () {

}
</PRE>

<P>To generate stubs like this we add these commands to the schema:

<PRE>
:internal initialise_the_program
:internal get_external_event
:set $module_line  = "MODULE %s () {"
:set $stub_first   = "//"
:set $stub_between = "#"
:set $stub_last    = "//"
:do stubs

MODULE $name () {

}

:enddo stubs
</PRE>

<P>This is how it works:
<UL>
<LI>The <TT>:internal</TT> commands tell Libero to ignore these two modules
when it looks through the source file.  Without these two commands, Libero
would print a message saying that the source file contained modules no longer
used in the dialog.  We tell it that some modules are used internally by the
generated code.

<LI>The <TT>$module_line</TT> tells Libero what to look for when it is
running its idle module check.  This must always match the header of the stub
below.

<LI>Libero looks at each file specified in the <TT>:do stubs</TT> line.  If
you do not specify any files, Libero looks just at the source file.

<LI>When it builds a new module stub, Libero outputs a line containing
<TT>$stub_before</TT> before each stub.  Usually this is a blank line.

<LI>Libero uses <TT>$stub_first</TT>, <TT>$stub_between</TT>, and
<TT>$stub_last</TT> to build-up the header line.

<LI>The text between the <TT>:do</TT> and <TT>:enddo</TT> is repeated, with a
header, for each missing module.
</UL>

<P>The <TT>:do stubs</TT> command can come at any point in the schema.  It
does not do any output to the current output file.  However, in many cases it
is a good idea to list generated files in the <TT>:dostubs</TT> line, which
means that this should come at the end of the schema, when everything has
been generated.



<H2><A NAME="TOC101">Generating COBOL Code</A></H2>

<P>Libero has some built-in knowledge about the COBOL source format that
makes it a little easier to generate COBOL code.  The COBOL format is
80-column text, where the first six columns are a numeric sequence number.
The last eight columns are a comment.
<UL>
<LI>If the schema looks like COBOL, Libero generates COBOL as a result.  It
ignores anything in the first 6 or last 8 columns of the schema.

<LI>When the -style option is <TT>-style=cobol</TT>, Libero checks that data
names are not longer than 30 characters, which is the standard ANSI maximum
for data names.

<LI>You can set <TT>$cob_comment</TT> to control what Libero places in
columns 73-80 of the output source.  Normally this is the date, e.g.
<TT>96/01/31</TT>.
</UL>


<H2><A NAME="TOC102">The State Machine Algorithm</A></H2>

<P>This is the dialog manager logic as pseudo-code.  If you need to write a
schema for a new language, this section should be your main
specifications.

<P>The dialog manager consists of a basic loop, plus extra pieces that are
generated only if necessary.  For example, handling of the Defaults state,
error checking, and handling of the dialog stack.  For clarity, I've put
in the Defaults handling, but nothing else other than the basic loop.
The following code is loosely based on C:

<PRE>
    _LR_state = 0                       //  First state is always zero
    initialise_the_program ()
    while (the_next_event != terminate_event) {
        _LR_event  = the_next_event
        _LR_savest = _LR_state
        _LR_index  = _LR_action [_LR_state][_LR_event]

        if (_LR_index == 0) {           //  Try Defaults state
            _LR_state = _LR_defaults_state
            _LR_index = _LR_action [_LR_state][_LR_event]
        }
        the_exception_event = _LR_NULL_EVENT
        exception_raised    = FALSE

        Get first module in list
        for ever {
            if (we finished the module list OR exception_raised)
                break
            Execute next module in list
        }
        if (exception_raised) {
            if (the_exception_event != _LR_NULL_EVENT)
                _LR_event = the_exception_event
            the_next_event = _LR_event
        } else
            _LR_state = _LR_nextst [_LR_state][_LR_event]

        if (_LR_state == _LR_defaults_state)
            _LR_state = _LR_savest
        if (the_next_event == _LR_NULL_EVENT)
            get_external_event ()
    }
    return (feedback)
</PRE>


<H2><A NAME="TOC103">Compiled-In Limitations</A></H2>

<P>A number of more-or-less arbitrary limits are defined in the header file
<TT>lrpriv.h</TT>.  If you need to, you can increase these, then recompile
all Libero programs (and if you are smart, drop me a line explaining your
reasons):
<UL>
<LI><TT>LR_SYMBOLMAX</TT> - the size of Libero's symbol table.  This table is
used to hold all state, event, and module names.  Defined as 32000; maximum
value is 32767.

<LI><TT>LR_STATEMAX</TT> - the maximum number of states in the dialog.
Defined as 1000.  Maximum value is 16383, assuming schema can handle it.

<LI><TT>LR_EVENTMAX</TT> - the maximum number of different events in the
dialog.  Defined as 1000.  Maximum value is 16383, assuming schema can handle
it.

<LI><TT>LR_MODULEMAX</TT> - the maximum number of different modules in the
dialog.  Defined as 1000.  Maximum value is 16383, assuming schema can handle
it.

<LI><TT>LR_VECTORMAX</TT> - the maximum number of different vectors in the
dialog.  Defined as 1000.  <TT>LR_VECTORMAX * 2 * $maxaction</TT> should not
be larger than 32k.

<LI><TT>LR_FILENAMEMAX</TT> - the maximum size of a filename with extension,
but not path.  Defined as 128 characters.

<LI><TT>LR_HEADER_WIDTH</TT> - the default width of a header line.  For
various archaic reasons I like this to be 79.  You can change this in a
schema by setting <TT>$stub_width</TT>.

<LI><TT>LR_RUNAWAY_LIMIT</TT> - the number of times you can go through a
<TT>:do</TT> loop before Libero says thinks you are in trouble.  Defined as
1000.  Maximum value is 32767.

<LI><TT>LR_ROW_WIDTH</TT> - the default width of one line of a <TT>$row</TT>.
For various reasons I like this to be 60.  You can change this in a schema by
setting <TT>$row_width</TT>.
</UL>

<P>The header file <TT>prelude.h</TT> also defines a constant
<TT>LINE_MAX</TT>, with the value 255, which is used to allocate buffers for
input and full filenames (ie. including path).  You should not write dialogs
wider than a normal page (ie. 80 columns).

<P>Libero allocates memory dynamically to store its dialog definition, so the
maximum size of a dialog actually depends on available memory.  You should
only change the constants in <TT>lrpriv.h</TT> if you get a message that
specifically says that you have reached such a limit.

<P>The code that the standard C schema generates assumes that events can be
stored in a signed 16-bit word; while state, module, and action numbers can
be stored in an unsigned 16-bit word.  A more compact version could be made
by using 8-bit values.

<P>If you change Libero, or suspect bugs, compile with the symbol
<TT>DEBUG</TT> defined.  This switches on the assertions that are sprinkled
through the code.  The executable will be a little larger, but if a bug
corrupts Libero's internal data structures, you will (usually) get a nice
message instead of an unpredictable crash.



<H2><A NAME="TOC104">Quick Reference - Libero Schema Language</A></H2>

<H3><A NAME="TOC105">General</A></H3>

<P>
<TT>!</TT> at start of line - comment to end of line.<BR>
<TT>:</TT> at start of line - command line.<BR>
<TT>:</TT> by itself on line - ignored as comment.<BR>
<TT>#</TT> in command line - comment to end of line.<BR>
<TT>$xyz</TT> - insert value of variable xyz.<BR>
<TT>$xyz\text</TT> - insert value of variable xyz followed by
<TT>text</TT>.<BR>
<TT>$"text"</TT> - format <TT>text</TT> using <TT>-style</TT> setting.<BR>
<TT>$$</TT> - insert single '$'.


<H3><A NAME="TOC106">Read-Only Variables</A></H3>

<P>
<TT>$author</TT> - value of <TT>-author</TT> setting.<BR>
<TT>$date</TT> - current date: <TT>yy/mm/dd</TT>.<BR>
<TT>$time</TT> - current time: <TT>hh:mm</TT>.<BR>
<TT>$fulldate</TT> - current date: <TT>dd Mmm, yyyy</TT>.<BR>
<TT>$fulltime</TT> - current time: <TT>hh:mm:ss</TT>.<BR>
<TT>$out_count</TT> - lines output including current line (1 up).<BR>
<TT>$dialog</TT> - name of current dialog file, no extension.<BR>
<TT>$schema</TT> - name of schema being read; value of <TT>-schema</TT>.<BR>
<TT>$source</TT> - name of source file, no extension; value of
<TT>-source</TT>.<BR>
<TT>$style</TT> - value of <TT>-style</TT>.<BR>
<TT>$defaults</TT> - number of the <TT>defaults</TT> state, or zero.<BR>
<TT>$events</TT> - number of events in dialog.<BR>
<TT>$maxaction</TT> - maximum action number (largest vector).<BR>
<TT>$modules</TT> - number of modules in dialog.<BR>
<TT>$states</TT> - number of states in dialog.<BR>
<TT>$vectors</TT> - number of action vectors in dialog.<BR>
<TT>$version</TT> - current Libero version: e.g. <TT>2.32</TT>.

<H3><A NAME="TOC107">Schema Commands</A></H3>

<P>
<TT>:output <I>filename</I></TT> - outputs following schema text to
<I>filename</I>.<BR>
<TT>:extend <I>filename</I></TT> - appends following schema text to
<I>filename</I>.<BR>
<TT>:close</TT> - closes current output file.<BR>
<TT>:copy <I>fromfile</I> <I>tofile</I></TT> - copies one file to
another.<BR>
<TT>:rename <I>fromfile</I> <I>tofile</I></TT> - renames one file to
another.<BR>
<TT>:delete <I>filename</I></TT> - deletes <I>filename</I>.<BR>
<TT>:include [optional] <I>filename</I> [<I>from</I> [<I>to</I>]]</TT>
- includes <I>filename</I> in current output code.  <I>From</I> and <I>to</I>
are strings of text that sit by themselves on a line in filename.<BR>
<TT>:echo <I>text</I></TT> - echoes <I>text</I>.  "\n" is a newline.<BR>
<TT>:declare [int | string] $<I>variable</I> [= <I>expression</I>]
</TT> - defines <I>variable</I> for later use in the schema.<BR>
<TT>:set $<I>variable</I> = <I>expression</I></TT> - assigns new value
to <I>variable</I>.<BR>
<TT>:push [$]<I>variable</I> [= <I>expression</I>]</TT> - creates a
new instance of <I>variable</I>.<BR>
<TT>:pop [$]<I>variable</I></TT> - removes last instance of
<I>variable</I>.<BR>
<TT>:do <I>condition</I></TT> - starts code block output repeatedly
depending on <I>condition</I>.<BR>
<TT>:do while <I>logical-condition</I></TT> - repeats code block while
<I>logical-condition</I> is true.<BR>
<TT>:enddo [<I>condition</I>]</TT> - ends closest previous :do
block.<BR>
<TT>:if <I>logical-condition</I></TT> - outputs code block if
<I>logical-condition</I> is true.<BR>
<TT>:else</TT> - outputs code block if previous :if was false.<BR>
<TT>:endif [all]</TT> - ends closest previous :if block.<BR>
<TT>:exit [<I>level</I>]</TT> - aborts code generation: level 0 =
okay, 1= error.<BR>
<TT>:option -<I>name</I>[=<I>value</I>]</TT> - enforces Libero
option.<BR>
<TT>:internal <I>module</I></TT> - <I>module</I> required by generated
dialog code, but not by dialog.<BR>
<TT>:substr <I>from</I> [<I>size</I>]</TT> - specifies substring for
next <TT>$<I>name</I></TT> or <TT>$row</TT> insertion.  <I>From</I> starts at
1.  If <I>size</I> is not specified, remainder of value is used.

<H3><A NAME="TOC108">Expressions</A></H3>

<PRE>
:declare int $number = 1
:set $number = ($number + 10) / 2
:set "$string" = "$string\more_text"
</PRE>

<P>Strings: max. 255 characters.  Numbers: from -2,147,483,648 to
+2,147,483,647.

<H3><A NAME="TOC109">Logical Conditions</A></H3>

<PRE>
:if $flag            # non-zero number or non-empty string
:if not <I>condition</I>    # reverse test
:if $var1 =  $var2   # If strings or numbers are equal
:if $var1 == $var2   # If equal
:if $var1 != $var2   # If not equal
:if $var1 &lt;&gt; $var2   # If not equal
:if $var1 &lt;  $var2   # If less than
:if $var1 &gt;  $var2   # If greater than
:if $var1 &lt;= $var2   # If less than or equal
:if $var1 &gt;= $var2   # If greater than or equal

:if exist <I>file</I>       # file exists in current directory
:if animate          # -animate option
:if check            # -check option
:if caps             # -style=caps option
:if cobol            # -style=cobol option
:if headline         # -style=headline option
:if normal           # -style=normal option
:if plain            # -style=plain option
:if title            # -style=title option
:if defaults         # dialog defines a Defaults state
:if state <I>name</I>       # name is state in dialog
:if event <I>name</I>       # name is event in dialog
:if module <I>name</I>      # name is module in dialog
</PRE>

<H3><A NAME="TOC110">Control Variables</A></H3>

<P>
<TT>$array_base</TT> - base value for tables. Default 0.<BR>
<TT>$comma_before</TT> - used as <TT>$comma</TT> when current item is not last.
Default ",".<BR>
<TT>$comma_last</TT> - used as <TT>$comma</TT> when current item is last.
Default empty.<BR>
<TT>$comment_ind</TT> - comment indicator in schema command lines. Default
"#".<BR>
<TT>$module_line</TT> - template for module header in source file. Default
"MODULE %s (void)".<BR>
<TT>$number_fmt</TT> - used to format the <TT>$number</TT> value. Must be
valid printf format string.  Default "%ld".<BR>
<TT>$row_first</TT> - used to format first numeric item in a <TT>$row</TT>
value.  Must be a valid <TT>printf</TT> format string.  Default "%ld".<BR>
<TT>$row_after</TT> - used to format numeric items in <TT>$row</TT> after
first.  Must be valid <TT>printf</TT> format string.  Default ",%ld".<BR>
<TT>$row_clean</TT> - when 1, Libero removes non-numeric data from start of
overflow rows.  Default 0.<BR>
<TT>$row_null</TT> - used in <TT>$row</TT>'s when there is no event defined in
state.  Default 0.<BR>
<TT>$row_width</TT> - maximum size of <TT>$row</TT> item in generated source.
Default 60.  Longer rows are chopped into 'overflow' pieces.<BR>
<TT>$run_away</TT> - maximum times through any :do loop. Default 1000.<BR>
<TT>$stub_before</TT> - output before each stub header. Default ""
(empty).<BR>
<TT>$stub_first</TT> - output at start of stub header line. Default "/".<BR>
<TT>$stub_between</TT> - repeated to build-up stub header line. Default
"*".<BR>
<TT>$stub_last</TT> - output at end of stub header line. Default "/".<BR>
<TT>$stub_width</TT> - width of stub header line. Default 79.

<H3><A NAME="TOC111">Standard :do Conditions</A></H3>

<P><TT>:do while <I>condition</I></TT> - repeats while <I>condition</I> is
true.  Loop is executed 0..n times.  Loop variables: <TT>$number</TT>.

<P><TT>:do event</TT> - builds list of events.  Outputs block for each event
in dialog.  Loop variables: <TT>$name</TT>, <TT>$number</TT>,
<TT>$comma</TT>.

<P><TT>:do state</TT> - builds list of states.  Outputs block for each state
in dialog.    Loop variables: <TT>$name</TT>, <TT>$number</TT>,
<TT>$comma</TT>.

<P><TT>:do module</TT> - builds list of modules.  Outputs block for each
module in dialog.  Loop variables: <TT>$name</TT>, <TT>$number</TT>,
<TT>$comma</TT>.

<P><TT>:do action</TT> - builds table containing one row per state, with one
item per row for each event transition.  Each item is number of an action
vector.  Invalid state/event transitions are filled by value of $row_null.
Loop variables: <TT>$row</TT>, <TT>$number</TT>, <TT>$comma</TT>,
<TT>$offset</TT>, <TT>$tally</TT>.

<P><TT>:do nextst</TT> - builds table containing one row per state, with one
item per row for each event transition.  Each item is number of next state.
Invalid state/event transitions are marked by value of $row_null.  Loop
variables: <TT>$row</TT>, <TT>$number</TT>, <TT>$comma</TT>,
<TT>$offset</TT>, <TT>$tally</TT>.

<P><TT>:do vector</TT> - builds table of action vectors.  An action vector is
a list of modules executed in series for a state/event transition.
Duplicate vectors are collapsed.   Loop variables: <TT>$row</TT>,
<TT>$number</TT>, <TT>$comma</TT>, <TT>$offset</TT>, <TT>$tally</TT>.

<P><TT>:do overflow</TT> - used to build source code that has to be output
over several lines.  Block is output until overflow row is empty.    Loop
variables: <TT>$row</TT>, <TT>$number</TT>, <TT>$comma</TT>,
<TT>$tally</TT>.

<P><TT>:do stubs [<I>filename</I>]...</TT> builds a set of module stubs at
end of filename.
<HR>
<P><A HREF="../index.htm"><IMG SRC="im0096c.gif" ALT="iMatix"></A>
Designed by <A HREF="people/pieter.htm">Pieter Hintjens</A>
&#169; 1996 iMatix</P>
</BODY></HTML>
