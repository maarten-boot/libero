.---------------------------------------------------------------------
.-   lrtech.txt   Libero Technical Reference
.-
.define BASE      lrtech
.define author    Pieter Hintjens
.define written   24 Feb 1996
.define revised   15 Apr 1996, 18:33 12 Apr 1996
.---------------------------------------------------------------------
.include prelude.def

.page Libero Technical Reference
.ignore header $(ignore)
<H1>$(TITLE)</H1>

.include contents.def

<H2>A First Look At Code Generation</H2>

<H3>The Schema</H3>

<UL>
<LI>The schema is like a program or script.  It tells the code generator what
to do, when, and how.  Libero executes the schema from start to end.

<LI>The code generator has a few ideas about what it has to generate, but the
schema usually has to tell it more.  For example, the schema can say 'please
generate numbers with 3 digits like this: 001'.

<LI>The schema decides what files to generate, under what conditions.  It
decides what they are called, and what they contain.
</UL>

<P>This is the basic logic of Libero's code generator:
<UL>
<LI>Read the schema line by line; ignore comment lines.

<LI>If the line contains a schema command, execute the command.

<LI>If the line does not contain a command, write it to the current output
file, if any.  If no output file is open, discard it.
</UL>

<P>This is a 'hello world' schema:

<PRE>
:echo "Hello, World."
</PRE>

<P>This is more realistic schema fragment:

<PRE>
!  Example Libero of schema
!
:if not exist $source.c
:echo "lr I: creating skeleton program $source.c..."
:output $source.c
/*===============================================================
 *  $source.c   description...
 *  Written:    $date       $author
 *  Revised:    $date
 *  Skeleton generated by LIBERO $version on $fulldate, $time.
 *===============================================================*/

#include "$dialog.d"                    /*  Include dialog data  */

/********************   INITIALISE THE PROGRAM  ******************/

MODULE $"initialise_the_program" (void)
{
    $"the_next_event" = $"ok_event";
}
:close
:endif
</PRE>

<P>How does this schema work?
<UL>
<LI>Any lines that starts with '!' is as a comment.  The code generator
discards all such lines.

<LI>Libero looks for names starting with '$', and replaces these by the value
of that variable.  Libero supplies a set of standard variables like '$date'
and '$source'.  You can also define your own variables.

<LI>When a line starts with ':xxxx', this is read by Libero as a schema
command.  Typical commands are ':if', ':echo'. ':open'. Command lines can
include variables.

<LI>Any other line is copied to the currently-open output.
</UL>

<P>When Libero replaces variables, it keeps the text as aligned as possible
by treating white-space (blanks or tabs) as elastic.  For instance, here is
some 'C' code before and after replacement. Notice how the right-hand margin
does not move:

<PRE>
/*  Source generated on $date - Libero $version                */
/*  Source generated on 93/07/12 - Libero 2.10                 */
</PRE>

<P>A variable name ends with the first non-name character (A-Z, a-z, 0-9, _).
To mark the end of a variable name that is 'pasted' to some text, use a '\'.
For instance, this is a line before and after inserting the $source
variable:

<PRE>
    :output $source\d.d
==&gt; :output myprogd.d
</PRE>

<P>If you capitalise (at least) the first letter of a variable name, Libero
inserts the whole value in uppercase.  For example:

<PRE>
    :output $Source\d.d
==&gt; :output MYPROGd.d
</PRE>

<P>To output a name that matches the current -style setting, do this
(e.g. -style=caps):

<PRE>
    $"the_next_event" = $"ok_event";
==&gt; TheNextEvent = OkEvent;
</PRE>

<P>To output a '$', use two '$'s together:

<PRE>
    $"the_next_event" = $$$"ok_event";
==&gt; TheNextEvent = $OkEvent;
</PRE>

.---------------------------------------------------------------------
.page Read-Only Variables

<H2>$(TITLE)</H2>

<P>You can use these read-only variables anywhere in a schema:

<DL>
<DT>$author</DT>
<DD>The value of the -author option.</DD>
<DT>$date</DT>
<DD>The current date in a shortened form: 'yy/mm/dd'. Libero
always uses this date format for short dates.</DD>
<DT>$time</DT>
<DD>The current time in a shortened form: 'hh:mm'.</DD>
<DT>$fulldate</DT>
<DD>The current date in a long form: 'dd Mmm, yyyy'. The month
is abbreviated to 3 letters, in English.</DD>
<DT>$fulltime</DT>
<DD>The current time including seconds: 'hh:mm:ss'.</DD>
<DT>$out_count</DT>
<DD>The number of lines output so far, including the current
line.  This starts at 1.</DD>
<DT>$dialog</DT>
<DD>The name of the dialog file being processed, without
extension.</DD>
<DT>$schema</DT>
<DD>The name of the schema being read.  This is the value of the
-schema option.</DD>
<DT>$source</DT>
<DD>The name of the source file for dialog, without an
extension.  This name is derived as follows: normally, it is the
same as the dialog file name.  If -plusd was specified, it is
formed by adding 'D' to the dialog file name.  If -source=xxx
was used, this explicitly tells the source name to use.</DD>
<DT>$style</DT>
<DD>The value of the -style option.</DD>
<DT>$defaults</DT>
<DD>The number of the defaults state, or zero if none was
specified.</DD>
<DT>$events</DT>
<DD>The number of events in the dialog.  This is used to
dimension various tables.</DD>
<DT>$maxaction</DT>
<DD>The maximum action number (largest vector).  This is used to
dimension various tables.</DD>
<DT>$modules</DT>
<DD>The number of modules in the dialog.  This is used to
dimension various tables.</DD>
<DT>$states</DT>
<DD>The number of states in the dialog.  This is used to
dimension various tables.</DD>
<DT>$vectors</DT>
<DD>The number of action vectors in the dialog.</DD>
<DT>$version</DT>
<DD>The current Libero version number as 4 characters: 'n.nn';
e.g. '$(version)'.</DD>
</DL>
<P>Additionally, you can use <TT>$comma</TT>, <TT>$name</TT>,
<TT>$number</TT>, <TT>$offset</TT>, <TT>$tally</TT>, <TT>$row</TT>, and
<TT>$overflow</TT> within a <TT>:do</TT> block.  These variables are
explained later.  You cannot define a variable with the name of a standard
Libero variable.

.---------------------------------------------------------------------
.page Schema Commands

<H2>$(TITLE)</H2>

<P>You can use the following commands in a schema:
<DL> <DT>:output <I>filename</I></DT>
<DD>Sends output to <I>filename</I>.  Any existing data in the
file is lost.</DD>
<DT>:extend <I>filename</I></DT>
<DD>Appends output to <I>filename</I>.  Creates the file if it
does not already exist.</DD>
<DT>:close</DT>
<DD>Closes an output file opened by a previous <TT>:output</TT>
or <TT>:extend</TT>.  This command is never required, since
Libero does an implicit <TT>:close</TT> before any
<TT>:output</TT> or <TT>:extend</TT>, and at the end of the
schema.  If you use <TT>:close</TT> when no file is open you'll
get a warning message.</DD>
<DT>:copy <I>fromfile</I> <I>tofile</I></DT>
<DD>Copies one file to another.  The <I>tofile</I> is silently
overwritten if it already exists.</DD>
<DT>:rename <I>fromfile</I> <I>tofile</I></DT>
<DD>Renames one file to another.  The <I>tofile</I> may not
already exist.</DD>
<DT>:delete <I>filename</I></DT>
<DD>Deletes <I>filename</I> without any error if the file does
not exist.</DD>
<DT>:include [optional] <I>filename</I> [<I>from</I>
[<I>to</I>]]</DT>
<DD>Includes <I>filename</I> in the generated output code.  If
you specify <I>from</I>, Libero searches the file for a line
containing this text by itself, and starts copying from that
point on.  If you specify <I>to</I>, Libero ends copying when it
finds a line containing just this text.  You can put quotes
around from and to if these contain embedded spaces.  If you
use the optional keyword, Libero ignores the <TT>:include</TT>
command if it can't find the specified file.  The included file
can be anywhere on the path value.</DD>
<DT>:echo <I>text</I></DT>
<DD>Echoes <I>text</I> to the standard output, followed by a
newline.  If the text is enclosed in quotes, leading spaces are
not discarded.</DD>
<DT>:declare [int | string] [$]<I>name</I>
[=<I>expression</I>]</DT>
<DD>Defines a variable for later use in the schema.  Except for
those that Libero supplies as standard, you have to declare any
variables that you want to use. You can specify the variable
name with or without a '$' in the name.<BR> Variables are
either integers, strings, or variants (either type depending on
mood).  You cannot assign a string expression to an integer.
Otherwise Libero is pretty relaxed about how you mix variable
types.  The expression provides a default initial value for the
variable.  If you do not provide an initial value, strings are
empty and numbers are zero.  You can override any initial value
using an <TT>-option</TT> on the command-line or in the dialog.
Use: <TT>-opt:var="string"</TT> or <TT>
opt:var=expression</TT>.<BR> The name of a variable cannot be
<TT>int</TT> or <TT>string</TT>.  Variable names are
case-independent; <TT>:declare $drink</TT> and <TT>:declare
$DRINK</TT> refer to the same variable. If you declare an
existing variable, you'll get an error message.</DD>
<DT>:set [$]<I>name</I> = <I>expression</I></DT>
<DD>Assigns a new value to the variable specified.  You can use
a '$' before the variable name if you want to.  You cannot set a
read-only variable.</DD>
<DT>:push [$]<I>variable</I> [=<I>expression</I>]</DT>
<DD>Creates a new instance of the variable.  If you give an
expression the new variable gets this value.  The variable must
then be a read-write variable.  You can push a read-only
variable but not specify an expression.  This may sound
pointless, but can be useful: you can set some read-only
variables using the <TT>:option</TT> command, e.g. <TT>:option
-style=xxxx.</TT></DD>
<DT>:pop [$]<I>variable</I></DT>
<DD>Removes the last instance of a variable.  Use with
<TT>:push</TT> to change a variable within a block, then reset
it to its previous value.</DD>
<DT>:do <I>condition</I></DT>
<DD>Starts a code block that is output repeatedly depending on
condition.  Libero defines a standard set of conditions like
<TT>:do event</TT>.  You can also define your own conditions
using <TT>:do while</TT>  The do block ends with a matching
<TT>:enddo</TT>.</DD>
<DT>:do while <I>logical-condition</I></DT>
<DD>Repeats the code block while the logical_condition is
true.</DD>
<DT>:enddo [<I>condition</I>]</DT>
<DD>Ends the closest previous <TT>:do</TT> block.  If you
specify condition, the <TT>:do</TT> and <TT>:enddo</TT>
conditions must match; this makes your schemas more robust
against errors, but is not required.</DD>
<DT>:if <I>logical-condition</I></DT>
<DD>Starts a code block that is output if
<I>logical_condition</I> is true.  The <TT>:if</TT> block ends
with a matching <TT>:endif</TT>.</DD>
<DT>:else</DT>
<DD>Outputs the following block of code if the previous
<TT>:if</TT> condition was false.</DD>
<DT>:endif [all]</DT>
<DD>Ends the closest previous <TT>:if</TT> block.  If you
specify <TT>all</TT>, all open <TT>:if</TT>blocks are
closed.</DD>
<DT>:exit [<I>level</I>]</DT>
<DD>Aborts code generation.  Use levels 0 for okay, 1 for
errors.</DD>
<DT>:option -<I>name</I>[=<I>value</I>]</DT>
<DD>Enforces a Libero option For example: <TT>:option
-style=cobol</TT>.</DD>
<DT>:internal <I>module</I></DT>
<DD>Tells the code-generator that <I>module</I> is required by
the generated dialog code, but not by the dialog.  A typical
case is <TT>initialise_the_program</TT>.  This lets Libero
correctly indicate unused modules in the source code.</DD>
<DT>:substr <I>from</I> [<I>size</I>]</DT>
<DD>Specifies a substring for the next <TT>$name</TT> or
<TT>$row</TT> insertion.  <I>From</I> must be from 1 upwards.
If <I>size</I> is not specified, the remainder of the variable's
value is used.</DD>
</DL>

<H3>Notes</H3>

<UL>
<LI>All commands can contain variables anywhere in the line that makes
sense.

<LI>You can use '#' to start a comment in a command line.  Any text following
the '#' is ignored.  When a '#' is inside a string, or escaped by '\', it is
treated as the '#' character, not a comment.  You can change the comment
character by setting <TT>$comment_ind</TT>.

<LI>A line containing just ':' by itself is ignored.  This lets you separate
blocks of commands without outputting extra blank lines in the code.  For
instance:
<PRE>
  :if $index &gt; 0
  :  set $counter = $counter + 1
  :endif
  :
  :echo "\ncounter is $counter\n"
</PRE>

<LI>In a <TT>:set</TT> or <TT>:declare</TT> you can give the variable name
with or without the $.  Your preference will depend on the other languages
you use.  When I've used Perl a while, I want to stick a '$' everywhere.
When I've programmed in a UNIX shell, I want the $ only on the right.  When
I've been working in any other language I can't understand what all the fuss
is about, I just want something that works like I expect it to.  So, since
the meaning is unambiguous, Libero accepts both.

<LI>One or more spaces can come between the ':' and the command name.  This
is often a nice way to indent commands to show structure.
</UL>

.---------------------------------------------------------------------
.page Syntax Of Expressions

<H2>$(TITLE)</H2>

<P>The <TT>:set</TT> and <TT>:declare</TT> commands assign the value of an
expression to a variable.  A couple of examples:

<PRE>
:declare $count = 0
:set $count = $count + 1
</PRE>

<P>Libero handles the expression depending on the type of the variable:
<UL>
<LI>If it is an int, it looks for an arithmetic expression.

<LI>If it is a string, it treats the whole expression as a string.  Quotes
are optional; you should use these if the string contains spaces.

<LI>If the variable is a variant, Libero tries to evaluate the expression as
an arithmetic expression.  If this works, the variable gets the resulting
number as its new value.  If this fails, the variable gets the string as its
value.  To be certain to assign a string, use quotes.
</UL>

<P>An arithmetic expression can include '+', '-', '*', '/', parentheses.  All
number are four-byte signed long values, i.e. fall into the range
+2,147,483,647 to -2,147,483,648.

<P>Things pretty much work as you would expect, I hope.  In practice I always
declare variables as <TT>int</TT> or <TT>string</TT> and put explicit quotes
around strings.

.---------------------------------------------------------------------
.page Syntax Of Logical Conditions

<H2>$(TITLE)</H2>

<P>The <TT>:if</TT> and <TT>:do while</TT> commands output some code
depending on a logical-condition.  Some examples:

<PRE>
:if $debug
:  echo "version is $version"
:endif
:do while $counter &gt; 0
   ...
:enddo
</PRE>

<P>A logical condition has two possible forms:

<PRE>
:if [not] [test] <I>expr1</I> [<I>logical_operator</I> <I>expr2</I>]
:while [not] [test] <I>expr1</I> [<I>logical_operator</I> <I>expr2</I>]

:if [not] [<I>standard_test</I>]
:while [not] [<I>standard_test</I>]
</PRE>

<H3>Logical Operators</H3>

<P>You can make a condition by comparing two expressions.  The 'test' keyword
is optional and I normally don't use it.  The expressions can be numeric or
string; if either is a string, Libero treats both as strings.  The logical
operator can be one of:

<P>These are the logical operators:
<UL>
<LI><TT>=</TT> - <I>expr1</I> is equal to <I>expr2</I>. <TT>==</TT> is also
okay.

<LI><TT>&lt;&gt;</TT> - <I>expr1</I> is not equal to <I>expr2</I>.
<TT>!=</TT> is also okay.

<LI><TT>&lt;</TT> - <I>expr1</I> is less than <I>expr2</I>.

<LI><TT>&lt;=</TT> - <I>expr1</I> is less than or equal to <I>expr2</I>.

<LI><TT>&gt;</TT> - <I>expr1</I> is greater than <I>expr2</I>.

<LI><TT>&gt;=</TT> - <I>expr1</I> is greater than or equal to
<I>expr2</I>.
</UL>

<H3>Standard Tests</H3>

<P>Libero provides these standard tests:
<DL>
<DT>exist <I>filename</I></DT>
<DD><I>filename</I> exists in the current directory.</DD>
<DT>animate</DT>
<DD>The dialog uses the -animation option.</DD>
<DT>check</DT>
<DD>The dialog uses the -check option.</DD>
<DT>caps</DT>
<DD>The dialog uses the -style=caps option.</DD>
<DT>cobol</DT>
<DD>The dialog uses the -style=cobol option.</DD>
<DT>headline</DT>
<DD>The dialog uses the -style=headline option.</DD>
<DT>normal</DT>
<DD>The dialog uses the -style=normal option.</DD>
<DT>plain</DT>
<DD>The dialog uses the -style=plain option.</DD>
<DT>title</DT>
<DD>The dialog uses the -style=title option.</DD>
<DT>defaults</DT>
<DD>The dialog defines a Defaults state.</DD>
<DT>state <I>name</I></DT>
<DD><I>name</I> is a state in the dialog.</DD>
<DT>event <I>name</I></DT>
<DD><I>name</I> is an event in the dialog.</DD>
<DT>module <I>name</I></DT>
<DD><I>name</I> is a module in the dialog.</DD>
</DL>

.---------------------------------------------------------------------
.page Control Variables

<H2>$(TITLE)</H2>

<P>Libero supplies various <I>control variables</I>.  A control variable
affects some aspects of code generation; you set the control variable to tell
Libero how to handle something specific for the language you want to
generate.  Control variables are usually 'write-only'.  You don't normally
refer to these variables in the code, though you can if you want to.  To
change a control variable you use the <TT>:set</TT> command:
<DL>
<DT>$array_base</DT>
<DD>Specifies the base value for tables.  You use this when
building an array of values.  By default this is 0; in some
languages it is more useful to start at 1.  The
<TT>$array_base</TT> affects the value of <TT>$number</TT> in a
<TT>:do</TT> block.</DD>
<DT>$comma_before</DT>
<DD>This value is used as <TT>$comma</TT> when the current item
being output is not the last.  Default is <TT>","</TT>.</DD>
<DT>$comma_last</DT>
<DD>This value is used as <TT>$comma</TT> when the current item
being output is the last. Default is empty.</DD>
<DT>$comment_ind</DT>
<DD>Comment indicator in schema command lines. Default is
'#'.</DD>
<DT>$module_line</DT>
<DD>libero looks for single lines that look like this when
creating new module stubs.  By default: <TT>"MODULE %s
(void)"</TT>. The '%s' symbol represents the module name.</DD>
<DT>$number_fmt</DT>
<DD>This value is used to format the <TT>$number</TT> value;
numbers are always signed long ints.  It must be a valid printf
format string.  Default is <TT>"%ld"</TT>.</DD>
<DT>$row_first</DT>
<DD>This value is used to format the first numeric item in a
<TT>$row</TT> value.  It must be a valid printf format string.
Default is <TT>"%ld"</TT>.</DD>
<DT>$row_after</DT>
<DD>This value is used to format numeric items in a
<TT>$row</TT> value after the first one.  It must be a valid
printf format string.  Default is <TT>",%ld"</TT>.</DD>
<DT>$row_clean</DT>
<DD>Tells Libero to clean-up overflow rows.  You get overflow
rows when you generate a table that is wider than the
<TT>$row_width</TT>.  When <TT>$row_clean</TT> is 1, Libero
removes any non-numeric data from the start of overflow rows.
When 0, Libero leaves overflow rows as they are.  Default is
0.</DD>
<DT>$row_null</DT>
<DD>This value is used in <TT>$row</TT>s when there is no event
defined in a certain state.  This is by default 0, but can be
set to any numeric value by the schema.</DD>
<DT>$row_width</DT>
<DD>Maximum space, in characters, for a <TT>$row</TT> item in
the generated source.  Default is the compile-time constant
<TT>LR_ROW_WIDTH</TT>, defined as 60.  Rows longer than this
are chopped into 'overflow' pieces.</DD>
<DT>$run_away</DT>
<DD>If a <TT>:do</TT> loop does more than this number of
iterations, Libero halts it with an error message.  Default is
the compile-time constant LR_RUNAWAY_LIMIT, defined as 1000.
This lets you generate at  least a table with the maximum
number ofstates, events, or modules (up to 1000 depending on
the schema).</DD>
<DT>$stub_before</DT>
<DD>Used to generate new module stubs.  If this string value is
not empty, it is output before each module stub header. By
default it is <TT>""</TT> (empty).</DD>
<DT>$stub_between</DT>
<DD>Used to generate new module stubs: this string value is
repeated to build-up a stub header.  Default is
<TT>"*"</TT>.</DD>
<DT>$stub_first</DT>
<DD>Used to generate new module stubs: this string value is
output at the start of a stub header line.  Default is
<TT>"/"</TT>.</DD>
<DT>$stub_last</DT>
<DD>Used to generate new module stubs: this string value is
output at the end of a stub header line.  Default is
<TT>"/"</TT>.</DD>
<DT>$stub_width</DT>
<DD>Used to generate new module stubs: defines the width of the
stub line.  Default is the compile-time constant
<TT>LR_HEADER_WIDTH</TT>, defined as 79.</DD>
</DL>
<P>To see the value that a control variable had for
code-generation, use the -trace option when you generate code.
 The <TT>.lst</TT> file produced shows
the symbol table, including all control variables, as code
generation
ended.

.---------------------------------------------------------------------
.page Standard :do Conditions

<H2>$(TITLE)</H2>

<P>Libero defines this set of :do conditions:
<DL>
<DT>:do action</DT>
<DD>For each state defined in the dialog; generates the action
for each event in each state.</DD>
<DT>:do event</DT>
<DD>For each event defined in the dialog.</DD>
<DT>:do event local</DT>
<DD>For each event defined in the current :do state.</DD>
<DT>:do module</DT>
<DD>For each dialog module defined in the dialog.</DD>
<DT>:do module local</DT>
<DD>For each dialog module defined in the current :do event.</DD>
<DT>:do nextst</DT>
<DD>For each state defined in the dialog; generates the
next-state for each event in each state.</DD>
<DT>:do state</DT>
<DD>For each state defined in the dialog.</DD>
<DT>:do stubs [filename]...</DT>
<DD>For each dialog module defined in the dialog, but not yet
present in the source file (or filename(s) if specified).</DD>
<DT>:do vector</DT>
<DD>For each action vector required by the dialog.  An action
vector is the list of modules to execute for an event in a
state.  Libero collects these and builds a list of unique action
vectors.</DD>
</DL>

<P>You cannot nest these standard :do loops cannot be nested (i.e. twice the
same condition).

.---------------------------------------------------------------------
.page Extra Variables In A :do Loop

<H2>$(TITLE)</H2>

<P>Within the different types of :do loop, various extra variables are
available.  Usually you'll need these to construct tables or lists of
names.

<H3><TT>:do while</TT> <I>condition</I></H3>
<P>Repeats the block of code while <I>condition</I> is true.  The condition
is a logical condition as described above.  The loop is executed 0..n
times.
<UL>
<LI><TT>$number</TT> - loop iteration 0..n-1, added to $array_base.
</UL>

<H3><TT>:do event</TT></H3>
<P>Builds a list of events.  Outputs the block for each event in the
dialog.
<UL>
<LI><TT>$name</TT> - event name, with <TT>_event</TT> stuck onto the end, and
formatted using the current -style setting.
<LI><TT>$number</TT> - event number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
</UL>

<H3><TT>:do event local</TT></H3>
<P>Builds a list of events.  Outputs the block for each event in the
current state, within a :do state loop.  Provides the same variables
as :do event, and also:
<UL>
<LI><TT>$next_state</TT> - name of next state, for this event.
</UL>

<H3><TT>:do state</TT></H3>
<P>Builds a list of states.  Outputs the block for each state in the
dialog.
<UL>
<LI><TT>$name</TT> - state name, formatted using the current -style
setting.
<LI><TT>$number</TT> - state number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
</UL>

<H3><TT>:do module</TT></H3>
<P>Builds list of modules.  Outputs the block for each module in the
dialog.
<UL>
<LI><TT>$name</TT> - module name, formatted using the current -style
setting.
<LI><TT>$number</TT> - module number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
</UL>

<H3><TT>:do action</TT></H3>
<P>Builds table containing one row per state, with one item per row for each
event transition.  Each item is the number of an action vector.  Invalid
state/event transitions are filled by the value of <TT>$row_null</TT>.
<UL>
<LI><TT>$row</TT> - value of row, formatted according to <TT>$row_first</TT>,
<TT>$row_after</TT>, and <TT>$row_null</TT>.
<LI><TT>$number</TT> - state number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
<LI><TT>$offset</TT> - offset of start of current row, added to
<TT>$array_base</TT>.  The offset is counted up by 1 for each item in a
row.
<LI><TT>$tally</TT> - number of items in <TT>$row</TT>.
</UL>

<H3><TT>:do nextst</TT></H3>
<P>Builds table containing one row per state, with one item per row for each
event transition.  Each item is the number of the next state.  Invalid
state/event transitions are marked by the value of <TT>$row_null</TT>.
<UL>
<LI><TT>$row</TT> - value of row, formatted according to <TT>$row_first</TT>,
<TT>$row_after</TT>, and <TT>$row_null</TT>.
<LI><TT>$number</TT> - state number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
<LI><TT>$offset</TT> - offset of start of current row, added to
<TT>$array_base</TT>.  The offset is counted up by 1 for each item in a
row.
<LI><TT>$tally</TT> - number of items in <TT>$row</TT>.
</UL>

<H3><TT>:do vector</TT></H3>
<P>Builds table of action vectors.  An action vector is a list of modules
executed in series for a state/event transition.  Duplicate vectors are
collapsed.
<UL>
<LI><TT>$row</TT> - action vector, formatted according to
<TT>$row_first</TT>, <TT>$row_after</TT>, and <TT>$row_null</TT>.
<LI><TT>$number</TT> - vector number 0..n-1, added to <TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
<LI><TT>$offset</TT> - offset of start of current row, added to
<TT>$array_base</TT>.  The offset is counted up by 1 for each item in a
row, including an assumed terminator value (0xFFFF).
<LI><TT>$tally</TT> - number of items in <TT>$row</TT>, including one
terminator value.
</UL>

<H3><TT>:do overflow</TT></H3>
<P>Used to build source code that has to be output over several lines.  The
block is output until the overflow row is empty.
<UL>
<LI><TT>$row</TT> - overflow row, ie. part of main <TT>$row</TT> that did not
fit onto first line.
<LI><TT>$number</TT> - iteration number 0..n-1, added to
<TT>$array_base</TT>.
<LI><TT>$comma</TT> - the value of <TT>$comma_before</TT> until the last
iteration; then <TT>$comma_last</TT>.
<LI><TT>$tally</TT> - number of items in <TT>$row</TT>.
</UL>

<H3><TT>:do stubs</TT> [<I>filename</I>]...</H3>
<P>Builds a set of module stubs at the end of the filename.  If no filename
is specified, assumes you mean the $source file.  You can specify a list of
filenames; then Libero will scan each file in the list for existing modules,
and build stubs for any undefined modules at the end of the first filename.
This is useful if you define standard modules in generated code (e.g. an
include file).

<P>If you use the -nostubs option, Libero ignores the :stubs command.  If you
use the -noidle option, Libero does not check the source for idle (ie.
unused) modules.


.---------------------------------------------------------------------
.page General Rules for Code Generation

<H2>$(TITLE)</H2>

<UL>
<LI>A string may be delimited by a single or double quote character.
<LI>Inside a string, the sequence '\n' is treated as a newline character.
The sequence '\t' is treated as a tab character.  Any other character
prefixed by '\' is treated as itself.
<LI>Libero issues a warning message if a non-blank line has to be discarded
because there is no output open.
<LI>If you have trouble generating what you want, use the -trace option: this
shows each schema line, before and after any variable expansion.
</UL>

.---------------------------------------------------------------------
.page Generating Module Stubs

<H2>$(TITLE)</H2>

<P>Take a hypothetical language where a module stub looks like
this:

<PRE>
//###################  SOME FUNCTION   ##################//

MODULE some_function () {

}
</PRE>

<P>To generate stubs like this we add these commands to the schema:

<PRE>
:internal initialise_the_program
:internal get_external_event
:set $module_line  = "MODULE %s () {"
:set $stub_first   = "//"
:set $stub_between = "#"
:set $stub_last    = "//"
:do stubs

MODULE $name () {

}

:enddo stubs
</PRE>

<P>This is how it works:
<UL>
<LI>The <TT>:internal</TT> commands tell Libero to ignore these two modules
when it looks through the source file.  Without these two commands, Libero
would print a message saying that the source file contained modules no longer
used in the dialog.  We tell it that some modules are used internally by the
generated code.

<LI>The <TT>$module_line</TT> tells Libero what to look for when it is
running its idle module check.  This must always match the header of the stub
below.

<LI>Libero looks at each file specified in the <TT>:do stubs</TT> line.  If
you do not specify any files, Libero looks just at the source file.

<LI>When it builds a new module stub, Libero outputs a line containing
<TT>$stub_before</TT> before each stub.  Usually this is a blank line.

<LI>Libero uses <TT>$stub_first</TT>, <TT>$stub_between</TT>, and
<TT>$stub_last</TT> to build-up the header line.

<LI>The text between the <TT>:do</TT> and <TT>:enddo</TT> is repeated, with a
header, for each missing module.
</UL>

<P>The <TT>:do stubs</TT> command can come at any point in the schema.  It
does not do any output to the current output file.  However, in many cases it
is a good idea to list generated files in the <TT>:dostubs</TT> line, which
means that this should come at the end of the schema, when everything has
been generated.


.---------------------------------------------------------------------
.page Generating COBOL Code

<H2>$(TITLE)</H2>

<P>Libero has some built-in knowledge about the COBOL source format that
makes it a little easier to generate COBOL code.  The COBOL format is
80-column text, where the first six columns are a numeric sequence number.
The last eight columns are a comment.
<UL>
<LI>If the schema looks like COBOL, Libero generates COBOL as a result.  It
ignores anything in the first 6 or last 8 columns of the schema.

<LI>When the -style option is <TT>-style=cobol</TT>, Libero checks that data
names are not longer than 30 characters, which is the standard ANSI maximum
for data names.

<LI>You can set <TT>$cob_comment</TT> to control what Libero places in
columns 73-80 of the output source.  Normally this is the date, e.g.
<TT>96/01/31</TT>.
</UL>

.---------------------------------------------------------------------
.page The State Machine Algorithm

<H2>$(TITLE)</H2>

<P>This is the dialog manager logic as pseudo-code.  If you need to write a
schema for a new language, this section should be your main
specifications.

<P>The dialog manager consists of a basic loop, plus extra pieces that are
generated only if necessary.  For example, handling of the Defaults state,
error checking, and handling of the dialog stack.  For clarity, I've put
in the Defaults handling, but nothing else other than the basic loop.
The following code is loosely based on C:

<PRE>
    _LR_state = 0                       //  First state is always zero
    initialise_the_program ()
    while (the_next_event != terminate_event) {
        _LR_event  = the_next_event
        _LR_savest = _LR_state
        _LR_index  = _LR_action [_LR_state][_LR_event]

        if (_LR_index == 0) {           //  Try Defaults state
            _LR_state = _LR_defaults_state
            _LR_index = _LR_action [_LR_state][_LR_event]
        }
        the_exception_event = _LR_NULL_EVENT
        exception_raised    = FALSE

        Get first module in list
        for ever {
            if (we finished the module list OR exception_raised)
                break
            Execute next module in list
        }
        if (exception_raised) {
            if (the_exception_event != _LR_NULL_EVENT)
                _LR_event = the_exception_event
            the_next_event = _LR_event
        } else
            _LR_state = _LR_nextst [_LR_state][_LR_event]

        if (_LR_state == _LR_defaults_state)
            _LR_state = _LR_savest
        if (the_next_event == _LR_NULL_EVENT)
            get_external_event ()
    }
    return (feedback)
</PRE>

.---------------------------------------------------------------------
.page Compiled-In Limitations

<H2>$(TITLE)</H2>

<P>A number of more-or-less arbitrary limits are defined in the header file
<TT>lrpriv.h</TT>.  If you need to, you can increase these, then recompile
all Libero programs (and if you are smart, drop me a line explaining your
reasons):
<UL>
<LI><TT>LR_SYMBOLMAX</TT> - the size of Libero's symbol table.  This table is
used to hold all state, event, and module names.  Defined as 32000; maximum
value is 32767.

<LI><TT>LR_STATEMAX</TT> - the maximum number of states in the dialog.
Defined as 1000.  Maximum value is 16383, assuming schema can handle it.

<LI><TT>LR_EVENTMAX</TT> - the maximum number of different events in the
dialog.  Defined as 1000.  Maximum value is 16383, assuming schema can handle
it.

<LI><TT>LR_MODULEMAX</TT> - the maximum number of different modules in the
dialog.  Defined as 1000.  Maximum value is 16383, assuming schema can handle
it.

<LI><TT>LR_VECTORMAX</TT> - the maximum number of different vectors in the
dialog.  Defined as 1000.  <TT>LR_VECTORMAX * 2 * $maxaction</TT> should not
be larger than 32k.

<LI><TT>LR_FILENAMEMAX</TT> - the maximum size of a filename with extension,
but not path.  Defined as 128 characters.

<LI><TT>LR_HEADER_WIDTH</TT> - the default width of a header line.  For
various archaic reasons I like this to be 79.  You can change this in a
schema by setting <TT>$stub_width</TT>.

<LI><TT>LR_RUNAWAY_LIMIT</TT> - the number of times you can go through a
<TT>:do</TT> loop before Libero says thinks you are in trouble.  Defined as
1000.  Maximum value is 32767.

<LI><TT>LR_ROW_WIDTH</TT> - the default width of one line of a <TT>$row</TT>.
For various reasons I like this to be 60.  You can change this in a schema by
setting <TT>$row_width</TT>.
</UL>

<P>The header file <TT>prelude.h</TT> also defines a constant
<TT>LINE_MAX</TT>, with the value 255, which is used to allocate buffers for
input and full filenames (ie. including path).  You should not write dialogs
wider than a normal page (ie. 80 columns).

<P>Libero allocates memory dynamically to store its dialog definition, so the
maximum size of a dialog actually depends on available memory.  You should
only change the constants in <TT>lrpriv.h</TT> if you get a message that
specifically says that you have reached such a limit.

<P>The code that the standard C schema generates assumes that events can be
stored in a signed 16-bit word; while state, module, and action numbers can
be stored in an unsigned 16-bit word.  A more compact version could be made
by using 8-bit values.

<P>If you change Libero, or suspect bugs, compile with the symbol
<TT>DEBUG</TT> defined.  This switches on the assertions that are sprinkled
through the code.  The executable will be a little larger, but if a bug
corrupts Libero's internal data structures, you will (usually) get a nice
message instead of an unpredictable crash.


.---------------------------------------------------------------------
.page Quick Reference - Libero Schema Language

<H2>$(TITLE)</H2>

<H3>General</H3>

<P>
<TT>!</TT> at start of line - comment to end of line.<BR>
<TT>:</TT> at start of line - command line.<BR>
<TT>:</TT> by itself on line - ignored as comment.<BR>
<TT>#</TT> in command line - comment to end of line.<BR>
<TT>$xyz</TT> - insert value of variable xyz.<BR>
<TT>$xyz\text</TT> - insert value of variable xyz followed by
<TT>text</TT>.<BR>
<TT>$"text"</TT> - format <TT>text</TT> using <TT>-style</TT> setting.<BR>
<TT>$$</TT> - insert single '$'.


<H3>Read-Only Variables</H3>

<P>
<TT>$author</TT> - value of <TT>-author</TT> setting.<BR>
<TT>$date</TT> - current date: <TT>yy/mm/dd</TT>.<BR>
<TT>$time</TT> - current time: <TT>hh:mm</TT>.<BR>
<TT>$fulldate</TT> - current date: <TT>dd Mmm, yyyy</TT>.<BR>
<TT>$fulltime</TT> - current time: <TT>hh:mm:ss</TT>.<BR>
<TT>$out_count</TT> - lines output including current line (1 up).<BR>
<TT>$dialog</TT> - name of current dialog file, no extension.<BR>
<TT>$schema</TT> - name of schema being read; value of <TT>-schema</TT>.<BR>
<TT>$source</TT> - name of source file, no extension; value of
<TT>-source</TT>.<BR>
<TT>$style</TT> - value of <TT>-style</TT>.<BR>
<TT>$defaults</TT> - number of the <TT>defaults</TT> state, or zero.<BR>
<TT>$events</TT> - number of events in dialog.<BR>
<TT>$maxaction</TT> - maximum action number (largest vector).<BR>
<TT>$modules</TT> - number of modules in dialog.<BR>
<TT>$states</TT> - number of states in dialog.<BR>
<TT>$vectors</TT> - number of action vectors in dialog.<BR>
<TT>$version</TT> - current Libero version: e.g. <TT>$(version)</TT>.

<H3>Schema Commands</H3>

<P>
<TT>:output <I>filename</I></TT> - outputs following schema text to
<I>filename</I>.<BR>
<TT>:extend <I>filename</I></TT> - appends following schema text to
<I>filename</I>.<BR>
<TT>:close</TT> - closes current output file.<BR>
<TT>:copy <I>fromfile</I> <I>tofile</I></TT> - copies one file to
another.<BR>
<TT>:rename <I>fromfile</I> <I>tofile</I></TT> - renames one file to
another.<BR>
<TT>:delete <I>filename</I></TT> - deletes <I>filename</I>.<BR>
<TT>:include [optional] <I>filename</I> [<I>from</I> [<I>to</I>]]</TT>
- includes <I>filename</I> in current output code.  <I>From</I> and <I>to</I>
are strings of text that sit by themselves on a line in filename.<BR>
<TT>:echo <I>text</I></TT> - echoes <I>text</I>.  "\n" is a newline.<BR>
<TT>:declare [int | string] $<I>variable</I> [= <I>expression</I>]
</TT> - defines <I>variable</I> for later use in the schema.<BR>
<TT>:set $<I>variable</I> = <I>expression</I></TT> - assigns new value
to <I>variable</I>.<BR>
<TT>:push [$]<I>variable</I> [= <I>expression</I>]</TT> - creates a
new instance of <I>variable</I>.<BR>
<TT>:pop [$]<I>variable</I></TT> - removes last instance of
<I>variable</I>.<BR>
<TT>:do <I>condition</I></TT> - starts code block output repeatedly
depending on <I>condition</I>.<BR>
<TT>:do while <I>logical-condition</I></TT> - repeats code block while
<I>logical-condition</I> is true.<BR>
<TT>:enddo [<I>condition</I>]</TT> - ends closest previous :do
block.<BR>
<TT>:if <I>logical-condition</I></TT> - outputs code block if
<I>logical-condition</I> is true.<BR>
<TT>:else</TT> - outputs code block if previous :if was false.<BR>
<TT>:endif [all]</TT> - ends closest previous :if block.<BR>
<TT>:exit [<I>level</I>]</TT> - aborts code generation: level 0 =
okay, 1= error.<BR>
<TT>:option -<I>name</I>[=<I>value</I>]</TT> - enforces Libero
option.<BR>
<TT>:internal <I>module</I></TT> - <I>module</I> required by generated
dialog code, but not by dialog.<BR>
<TT>:substr <I>from</I> [<I>size</I>]</TT> - specifies substring for
next <TT>$<I>name</I></TT> or <TT>$row</TT> insertion.  <I>From</I> starts at
1.  If <I>size</I> is not specified, remainder of value is used.

<H3>Expressions</H3>

<PRE>
:declare int $number = 1
:set $number = ($number + 10) / 2
:set "$string" = "$string\more_text"
</PRE>

<P>Strings: max. 255 characters.  Numbers: from -2,147,483,648 to
+2,147,483,647.

<H3>Logical Conditions</H3>

<PRE>
:if $flag            # non-zero number or non-empty string
:if not <I>condition</I>    # reverse test
:if $var1 =  $var2   # If strings or numbers are equal
:if $var1 == $var2   # If equal
:if $var1 != $var2   # If not equal
:if $var1 &lt;&gt; $var2   # If not equal
:if $var1 &lt;  $var2   # If less than
:if $var1 &gt;  $var2   # If greater than
:if $var1 &lt;= $var2   # If less than or equal
:if $var1 &gt;= $var2   # If greater than or equal

:if exist <I>file</I>       # file exists in current directory
:if animate          # -animate option
:if check            # -check option
:if caps             # -style=caps option
:if cobol            # -style=cobol option
:if headline         # -style=headline option
:if normal           # -style=normal option
:if plain            # -style=plain option
:if title            # -style=title option
:if defaults         # dialog defines a Defaults state
:if state <I>name</I>       # name is state in dialog
:if event <I>name</I>       # name is event in dialog
:if module <I>name</I>      # name is module in dialog
</PRE>

<H3>Control Variables</H3>

<P>
<TT>$array_base</TT> - base value for tables. Default 0.<BR>
<TT>$comma_before</TT> - used as <TT>$comma</TT> when current item is not last.
Default ",".<BR>
<TT>$comma_last</TT> - used as <TT>$comma</TT> when current item is last.
Default empty.<BR>
<TT>$comment_ind</TT> - comment indicator in schema command lines. Default
"#".<BR>
<TT>$module_line</TT> - template for module header in source file. Default
"MODULE %s (void)".<BR>
<TT>$number_fmt</TT> - used to format the <TT>$number</TT> value. Must be
valid printf format string.  Default "%ld".<BR>
<TT>$row_first</TT> - used to format first numeric item in a <TT>$row</TT>
value.  Must be a valid <TT>printf</TT> format string.  Default "%ld".<BR>
<TT>$row_after</TT> - used to format numeric items in <TT>$row</TT> after
first.  Must be valid <TT>printf</TT> format string.  Default ",%ld".<BR>
<TT>$row_clean</TT> - when 1, Libero removes non-numeric data from start of
overflow rows.  Default 0.<BR>
<TT>$row_null</TT> - used in <TT>$row</TT>'s when there is no event defined in
state.  Default 0.<BR>
<TT>$row_width</TT> - maximum size of <TT>$row</TT> item in generated source.
Default 60.  Longer rows are chopped into 'overflow' pieces.<BR>
<TT>$run_away</TT> - maximum times through any :do loop. Default 1000.<BR>
<TT>$stub_before</TT> - output before each stub header. Default ""
(empty).<BR>
<TT>$stub_first</TT> - output at start of stub header line. Default "/".<BR>
<TT>$stub_between</TT> - repeated to build-up stub header line. Default
"*".<BR>
<TT>$stub_last</TT> - output at end of stub header line. Default "/".<BR>
<TT>$stub_width</TT> - width of stub header line. Default 79.

<H3>Standard :do Conditions</H3>

<P><TT>:do while <I>condition</I></TT> - repeats while <I>condition</I> is
true.  Loop is executed 0..n times.  Loop variables: <TT>$number</TT>.

<P><TT>:do event</TT> - builds list of events.  Outputs block for each event
in dialog.  Loop variables: <TT>$name</TT>, <TT>$number</TT>,
<TT>$comma</TT>.

<P><TT>:do state</TT> - builds list of states.  Outputs block for each state
in dialog.    Loop variables: <TT>$name</TT>, <TT>$number</TT>,
<TT>$comma</TT>.

<P><TT>:do module</TT> - builds list of modules.  Outputs block for each
module in dialog.  Loop variables: <TT>$name</TT>, <TT>$number</TT>,
<TT>$comma</TT>.

<P><TT>:do action</TT> - builds table containing one row per state, with one
item per row for each event transition.  Each item is number of an action
vector.  Invalid state/event transitions are filled by value of $row_null.
Loop variables: <TT>$row</TT>, <TT>$number</TT>, <TT>$comma</TT>,
<TT>$offset</TT>, <TT>$tally</TT>.

<P><TT>:do nextst</TT> - builds table containing one row per state, with one
item per row for each event transition.  Each item is number of next state.
Invalid state/event transitions are marked by value of $row_null.  Loop
variables: <TT>$row</TT>, <TT>$number</TT>, <TT>$comma</TT>,
<TT>$offset</TT>, <TT>$tally</TT>.

<P><TT>:do vector</TT> - builds table of action vectors.  An action vector is
a list of modules executed in series for a state/event transition.
Duplicate vectors are collapsed.   Loop variables: <TT>$row</TT>,
<TT>$number</TT>, <TT>$comma</TT>, <TT>$offset</TT>, <TT>$tally</TT>.

<P><TT>:do overflow</TT> - used to build source code that has to be output
over several lines.  Block is output until overflow row is empty.    Loop
variables: <TT>$row</TT>, <TT>$number</TT>, <TT>$comma</TT>,
<TT>$tally</TT>.

<P><TT>:do stubs [<I>filename</I>]...</TT> builds a set of module stubs at
end of filename.
