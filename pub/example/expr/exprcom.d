;----------------------------------------------------------------------------
;   exprcom.d - LIBERO dialog data definitions for exprcom.asm, model=com.
;   Generated by LIBERO 2.10 on  7 Dec, 1995, 15:00.
;   Schema file used: lrschema.asm
;----------------------------------------------------------------------------

LR_version       equ     '2.10'
LR_null_event    equ     255
LR_stop_action   equ     255
terminate_event  equ     254
end_mark_event   equ     0
error_event      equ     1
exception_event  equ     2
factor_op_event  equ     3
left_par_event   equ     4
number_event     equ     5
ok_event         equ     6
other_event      equ     7
right_par_event  equ     8
term_op_event    equ     9
LR_defaults      equ     3
LR_STATE_after_init equ  0
LR_STATE_expecting_operand equ 1
LR_STATE_expecting_operator equ 2
LR_STATE_defaults equ    3

ZERO             equ     00h
SPACE            equ     20h
O                equ     <offset>
B                equ     <byte ptr>
W                equ     <word ptr>


;--------------- Macros ------------------------------------------------------

CODE_SEG         macro                 ; Define code segment
                 .code
                 endm
DATA_SEG         macro                 ; Define null data segment
                 endm

MODULE           macro   modname       ; Start of dialog module procedure
endname          equ     <modname>     ; Name to use in ENDMODULE
                 CODE_SEG              ; Open code segment
modname          proc    near          ; Open procedure
                 endm

ENDMODULE        macro                 ; End previous procedure
endname          endp                  ; Close procedure
                 endm

raise_exception  macro   optevent      ; Optional event
                 irp     event,<optevent>
                 mov     the_exception_event,event
                 endm
                 mov     exception_raised,1
                 endm

pushr            macro   rl            ; Push one or more registers onto stack
                 irp     r,<rl>        ; Registers listed between <...>
                 push    r
                 endm
                 endm

popr             macro   rl            ; Pop one or more registers from stack
                 irp     r,<rl>        ; Registers listed between <...>
                 pop     r
                 endm
                 endm

jmps             macro   addr          ; Short jump
                 jmp     short addr
                 endm

LR_move          macro   dest,src      ; Move 16-bit memory to memory
                 mov     ax,src
                 mov     dest,ax
                 endm

LR_load          macro   dest,src      ; Load item from LR table
                 xor     ax,ax         ; Tables are 8-bits wide
                 mov     al,src        ;
                 mov     dest,ax       ; LR registers are 16-bits wide
                 endm

;--------------- Main function -----------------------------------------------

                 .model  small         ; Use near pointers by default
                 assume  ds:_text,es:_text
                 CODE_SEG
                 org     100h          ; Start after PSP
program          label   near

LR_main          proc    near          ; Main function:
                 call    LR_args       ;   Parse command line arguments
                 call    LR_motor      ;   Run state machine until done
                 mov     al,feedback   ; Exit program:
                 mov     ah,4Ch        ;   Function 4Ch: terminate program
                 int     21h           ;     with exit code in AL
LR_main          endp

;--------------- Parse arguments ---------------------------------------------
;
;  Scan command line arguments, copying text to arg_text.  Puts size of
;  argument text into arg_size.  If /? found, sets arg_help to 1, else 0.
;  Changes registers AX, SI, DI.  Stores binary zero at end of arg_text.
;
LR_args          proc    near
                 mov     si,81h        ; Point SI to command tail in PSP
                 mov     di,O arg_text ; Point DI to arg_text
                 xor     cx,cx         ; Clear help switch and arg size
LR_argNext:      lodsb                 ; Get next char at DS:SI, bump SI
                 cmp     al,0Dh        ; Do we have end of line?
                 je      LR_argExit    ; yes - exit
                 cmp     al,'/'        ; Do we have '/'?
                 jne     LR_argSpace   ; no - go store character (maybe skip)
LR_argSlash:     mov     ah,[si]       ; Get switch character
                 cmp     ah,'?'        ; Is it '?'
                 jne     LR_argPut     ; no - go store character
                 mov     ch,1          ; /? was found
                 inc     si            ; Bump SI to skip ?
                 jmps    LR_argNext    ;   and loop
LR_argSpace:     cmp     al,' '        ; Do we have leading space?
                 jne     LR_argPut     ; no - go store character
                 jcxz    LR_argNext    ; yes - go get next
LR_argPut:       stosb                 ; Write char at ES:DI, bump DI
                 inc     cl            ;   bump argument size
                 jmps    LR_argNext    ;   and loop
LR_argExit:      xor     al,al         ; Store binary zero
                 stosb                 ;   at end of argument text
                 mov     arg_help,ch   ; 1 if /? found, else 0
                 mov     arg_size,cl   ; Size of argument text in bytes
                 ret                   ; Return to caller
LR_args          endp

;--------------- State machine motor -----------------------------------------
;
;  Runs the state machine until it halts normally, or due to an error.  If
;  there is an error, sets feedback to 1.  Fatal errors cause a message to
;  be displayed.

LR_motor         proc    near
                 mov     LR_state,0
                 call    initialise_the_program

LR_motorLoop     label   near
                 cmp     the_next_event,terminate_event
                 jne     LR_motorLoop1
                 jmp     LR_motorExit  ; Finished - end state machine
LR_motorLoop1    label   near
                 ;       Check that event is not >= nbr-events or < 0
                 cmp     the_next_event,10
                 jge     LR_motorLoop2
                 cmp     the_next_event,0
                 jge     LR_motorLoop3
LR_motorLoop2:   jmp     LR_errorBad   ; Show message and abort
LR_motorLoop3    label   near

                 LR_move LR_event,the_next_event
                 call    LR_get_action ; Get action for state/event
                 LR_move LR_savest,LR_state
                 ; If no action for this event, try the defaults state
                 cmp     LR_index,0
                 jne     LR_indexOkay
                 mov     LR_state,LR_defaults
                 call    LR_get_action ; Get action for state/event
LR_indexOkay     label   near
                 cmp     LR_index,0    ; Is event valid in state?
                 jnz     LR_indexOkay1 ; Yes - continue
                 jmp     LR_errorBad   ; No - show message and exit
LR_indexOkay1    label   near

                 mov     the_next_event,LR_null_event
                 mov     the_exception_event,LR_null_event
                 mov     exception_raised,0
                 ; set-up SI to point to first module number in vector
                 mov     bx,LR_index
                 shl     bx,1          ; Each offset is two bytes
                 mov     bx,LR_vectoroffset[bx]
                 mov     LR_index,bx

LR_vectorNext    label   near
                 mov     bx,LR_index   ; LR_index points into vector
                 mov     bl,LR_vector[bx]
                 xor     bh,bh         ; BX is number of next module
                 cmp     bx,LR_stop_action
                 je      LR_vectorStop ; Done if hit LR_stop_action
                 cmp     exception_raised,1
                 je      LR_vectorStop ; Done if exception was raised
                 shl     bx,1          ; Each module address is 2 bytes
                 call    W LR_module[bx]
                 inc     LR_index      ; Bump LR_index
                 jmps    LR_vectorNext ;   and do next module
LR_vectorStop    label   near

                 cmp     exception_raised,1
                 jne     LR_set_nextst
                 cmp     the_exception_event,LR_null_event
                 je      LR_exception
                 LR_move LR_event,the_exception_event
LR_exception     label   near
                 LR_move the_next_event,LR_event
                 jmps    LR_have_state

LR_set_nextst    label   near          ; Set new state if no exception
                 mov     ax,10         ; Compute AX = LR_state
                 mul     LR_state      ;            * nbr-events
                 add     ax,LR_event   ;            + LR_event
                 xchg    ax,bx         ; Get result into BX
                 LR_load LR_state,LR_nextst[bx]
LR_have_state    label   near

                 cmp     LR_state,LR_defaults
                 jne     LR_not_defaults
                 LR_move LR_state,LR_savest
LR_not_defaults  label   near

                 cmp     the_next_event,LR_null_event
                 jne     LR_eventset
                 call    get_external_event
                 cmp     the_next_event,LR_null_event
                 je      LR_errorNull  ; Show message and abort
LR_eventset      label   near

                 jmp     LR_motorLoop

LR_errorNull     label near            ;
                 lea     si,LR_emsg3   ; echo 'No event set after event'
                 jmps    LR_error2     ; ... go do rest

LR_errorBad      label   near          ;
                 lea     si,LR_emsg1   ;
LR_error2:       call    echo          ; echo 'Invalid event '
                 mov     ax,LR_event   ;
                 call    echonum       ; echo LR_event
                 lea     si,LR_emsg2   ;
                 call    echo          ; echo 'in state '
                 mov     ax,LR_state   ;
                 call    echonum       ; echo LR_state
                 lea     si,newline    ;
                 call    echo          ; echo '\n'

LR_error         label   near          ; Error in dialog
                 mov     feedback,1    ;   Signal error

LR_motorExit     label   near          ; Finished with dialog
                 ret                   ;   Return to caller
LR_motor         endp


;--------------- LR Get Action -----------------------------------------------
;   LR_index = LR_action [LR_state][LR_event]
;
LR_get_action    proc    near
                 mov     ax,10         ; Compute AX = LR_state
                 mul     LR_state      ;            * nbr-events
                 add     ax,LR_event   ;            + LR_event
                 xchg    ax,bx         ; Get result into BX
                 LR_load LR_index,LR_action[bx]
                 ret
LR_get_action    endp


;--------------- Echo --------------------------------------------------------
;  Prints the null-terminated message pointed at DS:SI.  The sequence '\n' is
;  treated as a new-line.  Does not change any registers except the flags.
;
echo             proc    near
                 pushr   <ax,si>       ; Save registers
echoNext:        lodsb                 ; Get next character at DS:SI
                 cmp     al,0          ; A zero byte
                 jz      echoExit      ;   marks the end of the string
                 cmp     al,'\'        ; Do we have '\'?
                 jne     echoOkay      ; no - go echo it
                 xchg    al,ah         ;   save backslash
                 lodsb                 ;   get char after backslash
                 cmp     al,'n'        ;   do we have '\n' after all?
                 jne     echoBoth      ;   no - output AH and AL
                 mov     ax,0A0Dh      ;   yes - prepare CRLF (reversed)
echoBoth:        xchg    al,ah         ;   swap to get right order
                 call    echoch        ;   output first of two chars
                 mov     al,ah         ;   get second
                 cmp     al,0          ;
                 je      echoExit      ;   if zero, we have end of line
echoOkay:        call    echoch        ;   else echo it
                 jmps    echoNext      ;   and loop to do next
echoExit:        popr    <si,ax>       ; Restore registers
                 ret                   ; Return to caller
echo             endp

;--------------- Echo character ----------------------------------------------
;  Prints the character in AL.  Calls the BIOS tty display functions.
;  Does not change any registers except the flags.
;
echoch           proc    near          ; AL = character to echo
                 pushr   <ax,dx>       ; Save work registers
                 mov     dl,al         ; DL = character to echo
                 mov     ah,02h        ; Function 02: echo character
                 int     21h           ; Call DOS
                 popr    <dx,ax>       ; Restore work registers
                 ret                   ; Return to caller
echoch           endp

;--------------- Echo number -------------------------------------------------
;  Displays the value in AX as a signed decimal number with one leading space,
;  and optional sign.  Does not change any registers except the flags.
;
                 DATA_SEG
LR_sign          db      0             ; Sign character, if any

                 CODE_SEG
echonum          proc    near          ; AX = value to display, -32768..32767
                 pushr   <ax,bx,cx,dx> ; Save work registers
                 mov     LR_sign,' '   ; Clear sign character
                 cmp     ax,0          ; If < zero,
                 jge     echonumFlat   ;
                 xor     ax,0FFFFh     ; Get negative of number
                 inc     ax            ;
                 mov     LR_sign,'-'   ; Sign is minus
echonumFlat:     mov     bx,10         ; Dividend is 10
                 mov     cx,5          ; Repeat 5 times
echonumDiv:      xor     dx,dx         ;   Clear DX
                 div     bx            ;   Divide DX:AX by 10
                 push    dx            ;   Save remainder on stack
                 loop    echonumDiv    ; Until no more digits
                 mov     al,LR_sign    ;
                 cmp     al,' '        ; Print sign if wanted
                 je      echonumPrt    ;
                 call    echoch        ;
echonumPrt:      xor     dx,dx         ; Skip leading zeroes while DX=0
                 mov     cx,5          ; Repeat 5 times
echonumPop:      pop     ax            ;   Get result from stack
                 cmp     ax,0          ;   Is it zero?
                 jnz     echonumOut    ;   No - echo digit
                 cmp     dx,0          ;   If not leading zeroes,
                 jne     echonumOut    ;     echo digit
                 cmp     cx,1          ;   If 0 is not last digit
                 jne     echonumSkip   ;     skip until finished
echonumOut:      add     ax,'0'        ;   Turn into ASCII digit
                 call    echoch        ;     and echo to screen
                 inc     dx            ;   No more leading zeroes
echonumSkip:     loop    echonumPop    ; Until no more digits
                 mov     al,' '        ; Echo one trailing space
                 call    echoch        ;
                 popr    <dx,cx,bx,ax> ; Restore work registers
                 ret                   ; Return to caller
echonum          endp

;--------------- Pause -------------------------------------------------------
;  Waits for a keystroke; if [Esc] pressed, exits program
;  Does not change any registers except the flags.
;
pause            proc    near
                 pushr   <ax>
                 mov     ah,00h        ; Function 00h: wait for key
                 int     16h           ; Do BIOS keyboard interrupt
                 cmp     al,27
                 jne     pause_1
                 mov     ah,4Ch        ;   Function 4Ch: terminate program
                 int     21h           ;     with exit code in AL
pause_1:         popr    <ax>
                 ret                   ; Return to caller
pause            endp


;-- Static areas -------------------------------------------------------------
;   All event and state numbers are 8 bits wide
;   All counters and indices are 16 bits wide
;
                 DATA_SEG

LR_nextst        label   byte          ; State/event gives next state
                 db      0,0,0,0,0,0,1,0,0,0
                 db      0,0,0,0,1,2,0,0,0,1
                 db      2,0,0,1,0,0,0,0,2,1
                 db      3,0,3,3,3,3,0,3,3,3

LR_action        label   byte          ; State/event gives action
                 db      0,2,0,0,0,0,1,0,0,0
                 db      0,0,0,0,5,4,0,0,0,3
                 db      7,0,0,6,0,0,0,0,8,6
                 db      10,0,2,9,9,9,0,9,9,9

LR_vectoroffset  label   word          ; Action gives address into vector table
                 dw      0             ; Table starts at 1, not 0
                 dw      0
                 dw      2
                 dw      4
                 dw      8
                 dw      11
                 dw      14
                 dw      18
                 dw      22
                 dw      26
                 dw      29

LR_vector        label   byte          ; Address gives vector of module numbers
                 db      1,255
                 db      6,255
                 db      0,2,6,255
                 db      4,1,255
                 db      5,1,255
                 db      8,5,1,255
                 db      7,9,6,255
                 db      7,10,1,255
                 db      2,6,255
                 db      3,6,255

LR_module        label   word          ; Module number gives address of module
                 dw      allow_signed_number
                 dw      get_next_token
                 dw      signal_invalid_token
                 dw      signal_token_missing
                 dw      stack_the_number
                 dw      stack_the_operator
                 dw      terminate_the_program
                 dw      unstack_all_operators
                 dw      unstack_ge_operators
                 dw      unstack_if_end_mark
                 dw      unstack_if_left_par

LR_emsg1         db      'Invalid event ',0
LR_emsg2         db      'in state ',0
LR_emsg3         db      'No event set after event ',0
newline          db      '\n',0

;-- Variables used by dialog interpreter -------------------------------------
;   All event and state variables are 16 bits wide

LR_event         dw      0             ; Event for state transition
LR_state         dw      0             ; Current dialog state
LR_savest        dw      0             ; Saved dialog state
LR_index         dw      0             ; Index into vector table

the_next_event   dw      0             ; Next event from module
the_exception_event dw   0             ; Exception event from module
exception_raised db      0             ; 1 if exception raised
feedback         db      0             ; Return code to system
arg_text         db      128 dup(0)    ; Command line arguments
arg_size         db      0             ; Size of arguments (0 = none)
arg_help         db      0             ; 1 if /? specified, else 0
