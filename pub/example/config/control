#! /bin/ksh
#----------------------------------------------------------------------------
#
#   control     Example of configuration management script
#
#   Written:    95/10/22  Pieter Hintjens
#   Revised:    95/10/22
#
#   Syntax:     control program operation
#
#               operation   One of checkin / checkout / delete / integ /
#                           browse / undelete / ...
#
#               Returns 0 if the operation is allowed, 1 if not.
#-  control - generated script; do not modify directly. See control.l
#-  Generated by LIBERO 2.10 on  7 Dec, 1995, 15:07.
#-  Schema used: lrschema.ksh
#----------------------------------------------------------------------------

#-- Symbolic constants and event numbers ------------------------------------

DATABASE=$CONTROL\CONTROL.dat
terminate_event=255
browse_event=1
checkin_event=2
checkout_event=3
compile_event=4
delete_event=5
edit_event=6
error_event=7
integrate_event=8
ok_event=9
request_event=10
undelete_event=11
LR_STATE_after_init=1
LR_STATE_available=2
LR_STATE_checked_out=3
LR_STATE_deleted=4
LR_STATE_integration=5
LR_STATE_defaults=6
LR_defaults_state=6

#-- Public dialog variables -------------------------------------------------

the_next_event=0                        #   Next event from module
the_exception_event=0                   #   Exception event from module
feedback=0                              #   Return code from this function
exception_raised=FALSE                  #   TRUE if exception raised
script_name=""                          #   Name of script including path

#-- Variables used by dialog interpreter ------------------------------------

LR_event=0                              #   Event for state transition
LR_state=0                              #   Current dialog state
LR_savest=0                             #   Saved dialog state
LR_index=0                              #   Index into vector table
LR_vecptr=0                             #   Index into module vector

#-- Static areas ------------------------------------------------------------

LR_nextst1="0 0 0 0 0 0 1 0 2 0 0"
LR_nextst2="0 0 3 0 4 0 0 5 0 0 0"
LR_nextst3="0 2 0 3 4 3 0 0 0 0 0"
LR_nextst4="0 0 0 0 0 0 0 0 0 0 2"
LR_nextst5="0 0 0 0 0 0 0 0 0 2 0"
LR_nextst6="6 6 6 6 6 6 0 6 0 6 6"

LR_action1="0 0 0 0 0 0 2 0 1 0 0"
LR_action2="0 0 3 0 4 0 0 5 0 0 0"
LR_action3="0 6 0 8 9 7 0 0 0 0 0"
LR_action4="0 0 0 0 0 0 0 0 0 0 10"
LR_action5="0 0 0 0 0 0 0 0 0 5 0"
LR_action6="11 12 12 12 12 12 0 12 0 12 12"

LR_vector1="3 10 255"
LR_vector2="8 9 255"
LR_vector3="6 255"
LR_vector4="4 255"
LR_vector5=" 255"
LR_vector6="12 255"
LR_vector7="5 255"
LR_vector8="2 255"
LR_vector9="12 4 255"
LR_vector10="11 255"
LR_vector11="1 255"
LR_vector12="7 255"

LR_module1=browse_the_program
LR_module2=compile_the_program
LR_module3=define_new_program
LR_module4=delete_the_program
LR_module5=edit_the_program
LR_module6=lock_the_program
LR_module7=reject_operation
LR_module8=signal_invalid_operation
LR_module9=terminate_the_program
LR_module10=trigger_the_same_event
LR_module11=undelete_the_program
LR_module12=unlock_the_program


set_event ()
{
    if   test "$1" = "browse"; then
        return $browse_event
    elif test "$1" = "checkin"; then
        return $checkin_event
    elif test "$1" = "checkout"; then
        return $checkout_event
    elif test "$1" = "compile"; then
        return $compile_event
    elif test "$1" = "delete"; then
        return $delete_event
    elif test "$1" = "edit"; then
        return $edit_event
    elif test "$1" = "integrate"; then
        return $integrate_event
    elif test "$1" = "request"; then
        return $request_event
    elif test "$1" = "undelete"; then
        return $undelete_event
    else
        echo control: no operation $1 defined
        return $error_event
    fi
}


##########################   INITIALISE THE PROGRAM   #########################

function initialise_the_program
{
    #   Read state of program from CONTROL.dat; if not found, we set Ok;
    #   if there is an error we set error and display a message; if found
    #   we set LR_state to the appropriate state number, and call the
    #   set_event function to set an appropriate next event for the
    #   operation specified as argument.

    #   $1 is program name; $2 is operation name

    PROG=`echo $1 | tr "[a-z]" "[A-Z]"`
    OPERATION=`echo $2 | tr "[A-Z]" "[a-z]"`

    #  CONTROL.dat is in the $CONTROL directory.  Each line contains the
    #  program name, then state name, and possible other info afterwards.

    STATE=`egrep "^$PROG" $DATABASE | cut -f1 -d" "`

    if test "$STATE" = ""; then
        the_next_event=$ok_event
    else
        LR_state=`eval echo '$LR_STATE_'$STATE`
        START_STATE=$LR_state           #   Original state for program
        set_event $OPERATION
        the_next_event=$?
    fi
}


############################   DEFINE NEW PROGRAM   ###########################

function define_new_program
{
    #   Define new program in database
    return
}


#############################   LOCK THE PROGRAM   ############################

function lock_the_program
{
    #   Copy program to developer's directory, lock in central directory
    return
}


############################   UNLOCK THE PROGRAM   ###########################

function unlock_the_program
{
    #   Return program to central directory, if changed, and ask developer
    #   to give reason for changes.
    return
}


############################   BROWSE THE PROGRAM   ###########################

function browse_the_program
{
    #   Call editor in read-only mode
    return
}


###########################   COMPILE THE PROGRAM   ###########################

function compile_the_program
{
    #   Compile & link program
    return
}


#############################   EDIT THE PROGRAM   ############################

function edit_the_program
{
    #   Call editor in read-write mode
    return
}


############################   DELETE THE PROGRAM   ###########################

function delete_the_program
{
    #   Move program to central 'deleted' directory
    return
}


###########################   UNDELETE THE PROGRAM   ##########################

function undelete_the_program
{
    #   Move program to central source directory
    return
}


##########################   TRIGGER THE SAME EVENT   #########################

function trigger_the_same_event
{
    #   Re-set the-next-event by calling SET_EVENT

    set_event $OPERATION
    the_next_event=$?
}


#############################   REJECT OPERATION   ############################

function reject_operation
{
    echo 'control: $OPERATION is not allowed on $PROG'
    echo 'control: check administrator for details'
    feedback=1                          #   Return code to caller; reject
}


############################   GET EXTERNAL EVENT   ###########################

function get_external_event
{
    #   This module is called before we get to the next state, except in
    #   the cases where we do a 'trigger-the-same-event'.
    #   We update the program's state in CONTROL.dat.

    if [ $START_STATE -ne $LR_state ] ; then
        STATE=`eval echo '$LR_STATE_NAME_'$LR_state`
        gate $DATABASE \
        "egrep -v ^$PROG $DATABASE>tmp;cat $PROG $STATE>>tmp;mv tmp $DATABASE"
    fi

    #   Set the next event to terminate_event - this ends the dialog.

    the_next_event=$terminate_event
}


#########################   SIGNAL INVALID OPERATION   ########################

function signal_invalid_operation
{
    echo "control: invalid operation code " $OPERATION " - rejected"
}


##########################   TERMINATE THE PROGRAM    #########################

function terminate_the_program
{
    the_next_event=$terminate_event
}

function LR_idx {                       #   Extract one item from array
    shift $1
    return $1
}

function raise_exception {
    exception_raised=TRUE
    test "$1" != "" && the_exception_event=$1
}

###################################   MAIN   ##################################

LR_state=1
script_name=$0
initialise_the_program $*
while [ $the_next_event != $terminate_event ]; do
    LR_event=$the_next_event
    if [ $LR_event -gt 11 -o $LR_event -lt 1 \
    -o `expr $LR_event : ".*"` -gt 3 ]; then
        echo State $LR_state - event $LR_event is out of range
        exit 1
    fi
    eval "LR_idx $LR_event \$LR_action$LR_state"; LR_index=$?
    LR_savest=$LR_state

    #   If no action for this event, try the defaults state
    if [ $LR_index -eq 0 ]; then
        LR_state=$LR_defaults_state
        eval "LR_idx $LR_event \$LR_action$LR_state"; LR_index=$?
        if [ $LR_index -eq 0 ]; then
            echo State $LR_state - event $LR_event is not accepted
            exit 1
        fi
    fi

    the_next_event=0
    the_exception_event=0
    exception_raised=FALSE

    #   Execute module list for state transition
    LR_vecptr=1
    while true; do
        eval "LR_idx $LR_vecptr \$LR_vector$LR_index"; LR_modnbr=$?
        if [ $LR_modnbr -eq 255 -o $exception_raised = TRUE ]; then
            break
        fi
        eval "\$LR_module$LR_modnbr"    #   Execute the module of code
        let LR_vecptr=$LR_vecptr+1
    done

    #   Handle exception if any was raised
    if [ $exception_raised = TRUE ]; then
        if [ $the_exception_event -ne 0 ]; then
            LR_event=$the_exception_event
        fi
        the_next_event=$LR_event
    else
        eval "LR_idx $LR_event \$LR_nextst$LR_state"; LR_state=$?
    fi
    if [ $LR_state -eq $LR_defaults_state ]; then
        LR_state=$LR_savest
    fi
    if [ $the_next_event -eq 0 ]; then
        get_external_event
        if [ $the_next_event -eq 0 ]; then
            echo No event set after event $LR_event in state $LR_state
            exit 1
        fi
    fi
done
exit $feedback
