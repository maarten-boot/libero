/*---------------------------------------------------------------------------*
 *  testast.d - LIBERO dialog data definitions for testast.                  *
 *  Generated by LIBERO 2.10 on  7 Dec, 1995, 14:53.                         *
 *  Schema file used: lrschast.c                                             *
 *---------------------------------------------------------------------------*/

/*- Symbolic constants and event numbers ------------------------------------*/

#define _LR_STOP_ACTION                 0xFFFFL
#define _LR_NULL_EVENT                  -2
#define TerminateEvent                  -1
#define AgainEvent                      0
#define ErrorEvent                      1
#define ExitEvent                       2
#define IoErrorEvent                    3
#define OkEvent                         4
#define _LR_STATE_AfterInit             0
#define _LR_STATE_HaveMessage           1
#define _LR_STATE_Defaults              2

/*- Definition of context block for thread ----------------------------------*/

typedef struct {                        /*  Context for thread               */
    int
        _LR_event,                      /*  Event for state transition       */
        _LR_state,                      /*  Current dialog state             */
        _LR_savest,                     /*  Saved dialog state               */
        _LR_index,                      /*  Index into vector table          */
        TheNextEvent,                   /*  Next event from module           */
        TheExceptionEvent;              /*  Exception event from module      */
    word
        *_LR_vecptr;                    /*  Pointer into vector table        */
    Bool
        AnimationEnabled,               /*  If TRUE, animation switched on   */
        ExceptionRaised;                /*  TRUE if exception raised         */
    CONTEXT
        *Data;                          /*  Pointer to user data area        */
} THREAD;

/*- Function prototypes -----------------------------------------------------*/

#ifndef MODULE
#define MODULE  static void             /*  Libero dialog modules            */
#endif

local  _LR_before_actions               (THREAD *Thread);
local  _LR_after_actions                (THREAD *Thread);
local  ASTInitialise                    (CONTEXT *Data);
local  ASTContinue                      (THREAD *Thread);
local  RaiseException                   (THREAD *Thread, int event);
MODULE InitialiseTheThread              (THREAD *Thread);
MODULE CheckIoStatusBlock               (THREAD *Thread);
MODULE CheckMessageContents             (THREAD *Thread);
MODULE CloseTerminalChannel             (THREAD *Thread);
MODULE OpenTerminalChannel              (THREAD *Thread);
MODULE ReadMessageFromChannel           (THREAD *Thread);
MODULE TerminateTheThread               (THREAD *Thread);
MODULE WriteMessageToChannel            (THREAD *Thread);

/*- Static areas shared by all threads --------------------------------------*/

static word _LR_nextst [][5] =
{
    { 0,0,0,0,1 },
    { 1,0,1,0,0 },
    { 0,0,0,2,0 }
};

static word _LR_action [][5] =
{
    { 0,2,0,0,1 },
    { 3,0,4,0,0 },
    { 0,0,0,4,0 }
};

static word _LR_vector [][6+1] = {
    {0},
    {3,6,0,4,0,1,0xFFFFL},
    {5,0xFFFFL},
    {6,0,4,0,1,0xFFFFL},
    {2,5,0xFFFFL}
};

typedef void (*ASTfunction) (THREAD *);
static ASTfunction _LR_module [] = {
    CheckIoStatusBlock,
    CheckMessageContents,
    CloseTerminalChannel,
    OpenTerminalChannel,
    ReadMessageFromChannel,
    TerminateTheThread,
    WriteMessageToChannel
};


local _LR_before_actions (THREAD *Thread)
{
    if (Thread-> TheNextEvent == TerminateEvent) {
        free (Thread);                  /*  Release thread context           */
        return;                         /*    and give-up AST control        */
    }
    if ((Thread-> TheNextEvent >= 5)
    OR  (Thread-> TheNextEvent < 0)) {
        fprintf (stderr, "Invalid event %d in state %d\n",
                 Thread-> TheNextEvent, Thread-> _LR_state);
        sys_exit (0);                   /*  Fatal error in dialog            */
    }
    Thread-> _LR_event  = Thread-> TheNextEvent;
    Thread-> _LR_index  = _LR_action [Thread-> _LR_state]
                                     [Thread-> _LR_event];
    Thread-> _LR_savest = Thread-> _LR_state;
    /*  If no action for this event, try the defaults state                  */
    if (Thread-> _LR_index == 0) {
        Thread-> _LR_state = 2;
        Thread-> _LR_index = _LR_action [Thread-> _LR_state]
                                        [Thread-> _LR_event];
    }
    if (Thread-> _LR_index == 0) {
        fprintf (stderr, "Bad event %d in state %d\n",
                 Thread-> _LR_event, Thread-> _LR_savest);
        sys_exit (0);                   /*  Fatal error in dialog            */
    }
    Thread-> TheNextEvent           = _LR_NULL_EVENT;
    Thread-> TheExceptionEvent = _LR_NULL_EVENT;
    Thread-> ExceptionRaised        = FALSE;
    Thread-> _LR_vecptr = _LR_vector [Thread-> _LR_index];
    ASTContinue (Thread);
}

local _LR_after_actions (THREAD *Thread)
{
    if (Thread-> ExceptionRaised) {
        if (Thread-> TheExceptionEvent != _LR_NULL_EVENT)
            Thread-> _LR_event = Thread-> TheExceptionEvent;
        Thread-> TheNextEvent = Thread-> _LR_event;
    } else
        Thread-> _LR_state = _LR_nextst [Thread-> _LR_state]
                                        [Thread-> _LR_event];
    if (Thread-> TheNextEvent == _LR_NULL_EVENT) {
        fprintf (stderr, "No next event set after event %d in state %d\n",
                 Thread-> _LR_event, Thread-> _LR_savest);
        sys_exit (0);                   /*  Fatal error in dialog            */
    }
    if (Thread-> _LR_state == 2)
        Thread-> _LR_state = Thread-> _LR_savest;
    _LR_before_actions (Thread);        /*  Do main state-machine loop       */
}

/*- Standard dialog routines ------------------------------------------------*/

local ASTInitialise (CONTEXT *Data)
{
    THREAD *Thread;

    Thread = (THREAD *) malloc (sizeof (THREAD));
    if (Thread == NULL) {
        fprintf (stderr, "LIBERO: Out of memory error.\n");
        return;                         /*  Abort if no memory available     */
    }
    Thread-> AnimationEnabled = FALSE;
    Thread-> Data = Data;               /*  Attach user context to Thread    */
    Thread-> _LR_state = 0;             /*  First state is always 0          */
    InitialiseTheThread (Thread);       /*  Call user initialisations        */
    _LR_before_actions (Thread);        /*    and start with state machine   */
}

local ASTContinue (THREAD *Thread)
{
    if ((*Thread-> _LR_vecptr == _LR_STOP_ACTION)
    OR   (Thread-> ExceptionRaised))
        _LR_after_actions (Thread);
    else {
        (*_LR_module [*Thread-> _LR_vecptr++]) (Thread);
    }
}

local RaiseException (THREAD *Thread, int event)
{
    Thread-> ExceptionRaised = TRUE;
    if (event >= 0)
        Thread-> TheExceptionEvent = event;
}
